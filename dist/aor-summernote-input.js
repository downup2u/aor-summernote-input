(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "jquery"], factory);
	else if(typeof exports === 'object')
		exports["RichTextEditorInput"] = factory(require("react"), require("jquery"));
	else
		root["RichTextEditorInput"] = factory(root["React"], root["jquery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _reactSummernote = __webpack_require__(2);

	var _reactSummernote2 = _interopRequireDefault(_reactSummernote);

	__webpack_require__(4);

	__webpack_require__(11);

	var _reduxForm = __webpack_require__(12);

	__webpack_require__(249);

	__webpack_require__(250);

	__webpack_require__(251);

	__webpack_require__(252);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // import styles
	// you can import any other locale

	//https://github.com/Vnkitaev/react-summernote
	// Import bootstrap(v3 or v4) dependencies


	var RichTextEditor = function (_Component) {
	  _inherits(RichTextEditor, _Component);

	  function RichTextEditor() {
	    _classCallCheck(this, RichTextEditor);

	    return _possibleConstructorReturn(this, (RichTextEditor.__proto__ || Object.getPrototypeOf(RichTextEditor)).apply(this, arguments));
	  }

	  _createClass(RichTextEditor, [{
	    key: 'render',
	    value: function render() {
	      var input = this.props.input;

	      return _react2.default.createElement(_reactSummernote2.default, {
	        value: input.value,
	        options: {
	          lang: 'zh-CN',
	          height: 350,
	          dialogsInBody: true,
	          toolbar: [['style', ['style']], ['font', ['bold', 'underline', 'clear']], ['fontname', ['fontname']], ['para', ['ul', 'ol', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture', 'video']], ['view', ['fullscreen', 'codeview']]]
	        },
	        onChange: input.onChange
	      });
	    }
	  }]);

	  return RichTextEditor;
	}(_react.Component);

	var RichTextEditorInput = function RichTextEditorInput(_ref) {
	  var source = _ref.source;

	  return _react2.default.createElement(
	    'span',
	    null,
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(_reduxForm.Field, { name: source, component: RichTextEditor })
	  );
	};

	exports.default = RichTextEditorInput;

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(3), __webpack_require__(1));
		else if(typeof define === 'function' && define.amd)
			define(["jquery", "react"], factory);
		else if(typeof exports === 'object')
			exports["ReactSummernote"] = factory(require("jquery"), require("react"));
		else
			root["ReactSummernote"] = factory(root["jquery"], root["React"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_15__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function($) {'use strict';

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

		__webpack_require__(2);

		__webpack_require__(5);

		__webpack_require__(13);

		var _react = __webpack_require__(15);

		var _react2 = _interopRequireDefault(_react);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global $ */

		var randomUid = function randomUid() {
		  return Math.floor(Math.random() * 100000);
		};

		var ReactSummernote = function (_Component) {
		  _inherits(ReactSummernote, _Component);

		  _createClass(ReactSummernote, null, [{
		    key: 'reset',
		    value: function reset() {
		      this.editor.summernote('reset');
		    }
		  }, {
		    key: 'insertImage',
		    value: function insertImage(url, filenameOrCallback) {
		      this.editor.summernote('insertImage', url, filenameOrCallback);
		    }
		  }, {
		    key: 'insertNode',
		    value: function insertNode(node) {
		      this.editor.summernote('insertNode', node);
		    }
		  }, {
		    key: 'insertText',
		    value: function insertText(text) {
		      this.editor.summernote('insertText', text);
		    }
		  }]);

		  function ReactSummernote(props) {
		    _classCallCheck(this, ReactSummernote);

		    var _this = _possibleConstructorReturn(this, (ReactSummernote.__proto__ || Object.getPrototypeOf(ReactSummernote)).call(this, props));

		    _this.uid = 'react-summernote-' + randomUid();
		    _this.editor = {};

		    ReactSummernote.reset = ReactSummernote.reset.bind(_this);
		    ReactSummernote.insertImage = ReactSummernote.insertImage.bind(_this);
		    ReactSummernote.insertNode = ReactSummernote.insertNode.bind(_this);
		    ReactSummernote.insertText = ReactSummernote.insertText.bind(_this);

		    _this.onImageUpload = _this.onImageUpload.bind(_this);
		    _this.insertImage = _this.insertImage.bind(_this);
		    return _this;
		  }

		  _createClass(ReactSummernote, [{
		    key: 'componentDidMount',
		    value: function componentDidMount() {
		      var options = this.props.options || {};
		      options.callbacks = this.callbacks;

		      this.editor = $('#' + this.uid);
		      this.editor.summernote(options);
		      this.manageModalScroll(true);
		    }
		  }, {
		    key: 'shouldComponentUpdate',
		    value: function shouldComponentUpdate() {
		      return false;
		    }
		  }, {
		    key: 'componentWillUnmount',
		    value: function componentWillUnmount() {
		      if (this.editor) {
		        this.editor.summernote('destroy');
		      }

		      this.manageModalScroll(false);
		    }
		  }, {
		    key: 'onImageUpload',
		    value: function onImageUpload(images) {
		      var onImageUpload = this.props.onImageUpload;


		      if (typeof onImageUpload === 'function') {
		        onImageUpload(images, this.insertImage);
		      }
		    }
		  }, {
		    key: 'insertImage',
		    value: function insertImage(url, filenameOrCallback) {
		      this.editor.summernote('insertImage', url, filenameOrCallback);
		    }
		  }, {
		    key: 'manageModalScroll',
		    value: function manageModalScroll(mount) {
		      var $body = $('body');
		      var hasClassName = false;
		      if (mount) {
		        $('.note-editor .modal').on('show.bs.modal', function () {
		          hasClassName = $body.hasClass('modal-open');
		        });
		        $('.note-editor .modal').on('hidden.bs.modal', function () {
		          $body.toggleClass('modal-open', hasClassName);
		        });
		      } else {
		        $('.note-editor .modal').off('show.bs.modal');
		        $('.note-editor .modal').off('hidden.bs.modal');
		      }
		    }
		  }, {
		    key: 'render',
		    value: function render() {
		      return _react2.default.createElement('div', { id: this.uid, dangerouslySetInnerHTML: { __html: this.props.value } });
		    }
		  }, {
		    key: 'callbacks',
		    get: function get() {
		      var props = this.props;

		      return {
		        onInit: props.onInit,
		        onEnter: props.onEnter,
		        onFocus: props.onFocus,
		        onBlur: props.onBlur,
		        onKeyup: props.onKeyUp,
		        onKeydown: props.onKeyDown,
		        onPaste: props.onPaste,
		        onChange: props.onChange,
		        onImageUpload: this.onImageUpload
		      };
		    }
		  }]);

		  return ReactSummernote;
		}(_react.Component);

		ReactSummernote.propTypes = {
		  value: _react.PropTypes.string,
		  options: _react.PropTypes.object,
		  onInit: _react.PropTypes.func,
		  onEnter: _react.PropTypes.func,
		  onFocus: _react.PropTypes.func,
		  onBlur: _react.PropTypes.func,
		  onKeyUp: _react.PropTypes.func,
		  onKeyDown: _react.PropTypes.func,
		  onPaste: _react.PropTypes.func,
		  onChange: _react.PropTypes.func,
		  onImageUpload: _react.PropTypes.func
		};

		exports.default = ReactSummernote;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

	/***/ },
	/* 1 */
	/***/ function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
		 * Super simple wysiwyg editor v0.8.2
		 * http://summernote.org/
		 *
		 * summernote.js
		 * Copyright 2013-2016 Alan Hong. and other contributors
		 * summernote may be freely distributed under the MIT license./
		 *
		 * Date: 2016-08-07T05:11Z
		 */
		(function (factory) {
		  /* global define */
		  if (true) {
		    // AMD. Register as an anonymous module.
		    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  } else if (typeof module === 'object' && module.exports) {
		    // Node/CommonJS
		    module.exports = factory(require('jquery'));
		  } else {
		    // Browser globals
		    factory(window.jQuery);
		  }
		}(function ($) {
		  'use strict';

		  /**
		   * @class core.func
		   *
		   * func utils (for high-order func's arg)
		   *
		   * @singleton
		   * @alternateClassName func
		   */
		  var func = (function () {
		    var eq = function (itemA) {
		      return function (itemB) {
		        return itemA === itemB;
		      };
		    };

		    var eq2 = function (itemA, itemB) {
		      return itemA === itemB;
		    };

		    var peq2 = function (propName) {
		      return function (itemA, itemB) {
		        return itemA[propName] === itemB[propName];
		      };
		    };

		    var ok = function () {
		      return true;
		    };

		    var fail = function () {
		      return false;
		    };

		    var not = function (f) {
		      return function () {
		        return !f.apply(f, arguments);
		      };
		    };

		    var and = function (fA, fB) {
		      return function (item) {
		        return fA(item) && fB(item);
		      };
		    };

		    var self = function (a) {
		      return a;
		    };

		    var invoke = function (obj, method) {
		      return function () {
		        return obj[method].apply(obj, arguments);
		      };
		    };

		    var idCounter = 0;

		    /**
		     * generate a globally-unique id
		     *
		     * @param {String} [prefix]
		     */
		    var uniqueId = function (prefix) {
		      var id = ++idCounter + '';
		      return prefix ? prefix + id : id;
		    };

		    /**
		     * returns bnd (bounds) from rect
		     *
		     * - IE Compatibility Issue: http://goo.gl/sRLOAo
		     * - Scroll Issue: http://goo.gl/sNjUc
		     *
		     * @param {Rect} rect
		     * @return {Object} bounds
		     * @return {Number} bounds.top
		     * @return {Number} bounds.left
		     * @return {Number} bounds.width
		     * @return {Number} bounds.height
		     */
		    var rect2bnd = function (rect) {
		      var $document = $(document);
		      return {
		        top: rect.top + $document.scrollTop(),
		        left: rect.left + $document.scrollLeft(),
		        width: rect.right - rect.left,
		        height: rect.bottom - rect.top
		      };
		    };

		    /**
		     * returns a copy of the object where the keys have become the values and the values the keys.
		     * @param {Object} obj
		     * @return {Object}
		     */
		    var invertObject = function (obj) {
		      var inverted = {};
		      for (var key in obj) {
		        if (obj.hasOwnProperty(key)) {
		          inverted[obj[key]] = key;
		        }
		      }
		      return inverted;
		    };

		    /**
		     * @param {String} namespace
		     * @param {String} [prefix]
		     * @return {String}
		     */
		    var namespaceToCamel = function (namespace, prefix) {
		      prefix = prefix || '';
		      return prefix + namespace.split('.').map(function (name) {
		        return name.substring(0, 1).toUpperCase() + name.substring(1);
		      }).join('');
		    };

		    /**
		     * Returns a function, that, as long as it continues to be invoked, will not
		     * be triggered. The function will be called after it stops being called for
		     * N milliseconds. If `immediate` is passed, trigger the function on the
		     * leading edge, instead of the trailing.
		     * @param {Function} func
		     * @param {Number} wait
		     * @param {Boolean} immediate
		     * @return {Function}
		     */
		    var debounce = function (func, wait, immediate) {
		      var timeout;
		      return function () {
		        var context = this, args = arguments;
		        var later = function () {
		          timeout = null;
		          if (!immediate) {
		            func.apply(context, args);
		          }
		        };
		        var callNow = immediate && !timeout;
		        clearTimeout(timeout);
		        timeout = setTimeout(later, wait);
		        if (callNow) {
		          func.apply(context, args);
		        }
		      };
		    };

		    return {
		      eq: eq,
		      eq2: eq2,
		      peq2: peq2,
		      ok: ok,
		      fail: fail,
		      self: self,
		      not: not,
		      and: and,
		      invoke: invoke,
		      uniqueId: uniqueId,
		      rect2bnd: rect2bnd,
		      invertObject: invertObject,
		      namespaceToCamel: namespaceToCamel,
		      debounce: debounce
		    };
		  })();

		  /**
		   * @class core.list
		   *
		   * list utils
		   *
		   * @singleton
		   * @alternateClassName list
		   */
		  var list = (function () {
		    /**
		     * returns the first item of an array.
		     *
		     * @param {Array} array
		     */
		    var head = function (array) {
		      return array[0];
		    };

		    /**
		     * returns the last item of an array.
		     *
		     * @param {Array} array
		     */
		    var last = function (array) {
		      return array[array.length - 1];
		    };

		    /**
		     * returns everything but the last entry of the array.
		     *
		     * @param {Array} array
		     */
		    var initial = function (array) {
		      return array.slice(0, array.length - 1);
		    };

		    /**
		     * returns the rest of the items in an array.
		     *
		     * @param {Array} array
		     */
		    var tail = function (array) {
		      return array.slice(1);
		    };

		    /**
		     * returns item of array
		     */
		    var find = function (array, pred) {
		      for (var idx = 0, len = array.length; idx < len; idx ++) {
		        var item = array[idx];
		        if (pred(item)) {
		          return item;
		        }
		      }
		    };

		    /**
		     * returns true if all of the values in the array pass the predicate truth test.
		     */
		    var all = function (array, pred) {
		      for (var idx = 0, len = array.length; idx < len; idx ++) {
		        if (!pred(array[idx])) {
		          return false;
		        }
		      }
		      return true;
		    };

		    /**
		     * returns index of item
		     */
		    var indexOf = function (array, item) {
		      return $.inArray(item, array);
		    };

		    /**
		     * returns true if the value is present in the list.
		     */
		    var contains = function (array, item) {
		      return indexOf(array, item) !== -1;
		    };

		    /**
		     * get sum from a list
		     *
		     * @param {Array} array - array
		     * @param {Function} fn - iterator
		     */
		    var sum = function (array, fn) {
		      fn = fn || func.self;
		      return array.reduce(function (memo, v) {
		        return memo + fn(v);
		      }, 0);
		    };
		  
		    /**
		     * returns a copy of the collection with array type.
		     * @param {Collection} collection - collection eg) node.childNodes, ...
		     */
		    var from = function (collection) {
		      var result = [], idx = -1, length = collection.length;
		      while (++idx < length) {
		        result[idx] = collection[idx];
		      }
		      return result;
		    };

		    /**
		     * returns whether list is empty or not
		     */
		    var isEmpty = function (array) {
		      return !array || !array.length;
		    };
		  
		    /**
		     * cluster elements by predicate function.
		     *
		     * @param {Array} array - array
		     * @param {Function} fn - predicate function for cluster rule
		     * @param {Array[]}
		     */
		    var clusterBy = function (array, fn) {
		      if (!array.length) { return []; }
		      var aTail = tail(array);
		      return aTail.reduce(function (memo, v) {
		        var aLast = last(memo);
		        if (fn(last(aLast), v)) {
		          aLast[aLast.length] = v;
		        } else {
		          memo[memo.length] = [v];
		        }
		        return memo;
		      }, [[head(array)]]);
		    };
		  
		    /**
		     * returns a copy of the array with all false values removed
		     *
		     * @param {Array} array - array
		     * @param {Function} fn - predicate function for cluster rule
		     */
		    var compact = function (array) {
		      var aResult = [];
		      for (var idx = 0, len = array.length; idx < len; idx ++) {
		        if (array[idx]) { aResult.push(array[idx]); }
		      }
		      return aResult;
		    };

		    /**
		     * produces a duplicate-free version of the array
		     *
		     * @param {Array} array
		     */
		    var unique = function (array) {
		      var results = [];

		      for (var idx = 0, len = array.length; idx < len; idx ++) {
		        if (!contains(results, array[idx])) {
		          results.push(array[idx]);
		        }
		      }

		      return results;
		    };

		    /**
		     * returns next item.
		     * @param {Array} array
		     */
		    var next = function (array, item) {
		      var idx = indexOf(array, item);
		      if (idx === -1) { return null; }

		      return array[idx + 1];
		    };

		    /**
		     * returns prev item.
		     * @param {Array} array
		     */
		    var prev = function (array, item) {
		      var idx = indexOf(array, item);
		      if (idx === -1) { return null; }

		      return array[idx - 1];
		    };

		    return { head: head, last: last, initial: initial, tail: tail,
		             prev: prev, next: next, find: find, contains: contains,
		             all: all, sum: sum, from: from, isEmpty: isEmpty,
		             clusterBy: clusterBy, compact: compact, unique: unique };
		  })();

		  var isSupportAmd = "function" === 'function' && __webpack_require__(3);

		  /**
		   * returns whether font is installed or not.
		   *
		   * @param {String} fontName
		   * @return {Boolean}
		   */
		  var isFontInstalled = function (fontName) {
		    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
		    var $tester = $('<div>').css({
		      position: 'absolute',
		      left: '-9999px',
		      top: '-9999px',
		      fontSize: '200px'
		    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);

		    var originalWidth = $tester.css('fontFamily', testFontName).width();
		    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();

		    $tester.remove();

		    return originalWidth !== width;
		  };

		  var userAgent = navigator.userAgent;
		  var isMSIE = /MSIE|Trident/i.test(userAgent);
		  var browserVersion;
		  if (isMSIE) {
		    var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);
		    if (matches) {
		      browserVersion = parseFloat(matches[1]);
		    }
		    matches = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(userAgent);
		    if (matches) {
		      browserVersion = parseFloat(matches[1]);
		    }
		  }

		  var isEdge = /Edge\/\d+/.test(userAgent);

		  var hasCodeMirror = !!window.CodeMirror;
		  if (!hasCodeMirror && isSupportAmd && "function" !== 'undefined') {
		    if (true) {
		      try {
		        // If CodeMirror can't be resolved, `require.resolve` will throw an
		        // exception and `hasCodeMirror` won't be set to `true`.
		        /*require.resolve*/(4);
		        hasCodeMirror = true;
		      } catch (e) {
		        // Do nothing.
		      }
		    } else if (typeof eval('require').specified !== 'undefined') {
		      hasCodeMirror = eval('require').specified('codemirror');
		    }
		  }

		  /**
		   * @class core.agent
		   *
		   * Object which check platform and agent
		   *
		   * @singleton
		   * @alternateClassName agent
		   */
		  var agent = {
		    isMac: navigator.appVersion.indexOf('Mac') > -1,
		    isMSIE: isMSIE,
		    isEdge: isEdge,
		    isFF: !isEdge && /firefox/i.test(userAgent),
		    isPhantom: /PhantomJS/i.test(userAgent),
		    isWebkit: !isEdge && /webkit/i.test(userAgent),
		    isChrome: !isEdge && /chrome/i.test(userAgent),
		    isSafari: !isEdge && /safari/i.test(userAgent),
		    browserVersion: browserVersion,
		    jqueryVersion: parseFloat($.fn.jquery),
		    isSupportAmd: isSupportAmd,
		    hasCodeMirror: hasCodeMirror,
		    isFontInstalled: isFontInstalled,
		    isW3CRangeSupport: !!document.createRange
		  };


		  var NBSP_CHAR = String.fromCharCode(160);
		  var ZERO_WIDTH_NBSP_CHAR = '\ufeff';

		  /**
		   * @class core.dom
		   *
		   * Dom functions
		   *
		   * @singleton
		   * @alternateClassName dom
		   */
		  var dom = (function () {
		    /**
		     * @method isEditable
		     *
		     * returns whether node is `note-editable` or not.
		     *
		     * @param {Node} node
		     * @return {Boolean}
		     */
		    var isEditable = function (node) {
		      return node && $(node).hasClass('note-editable');
		    };

		    /**
		     * @method isControlSizing
		     *
		     * returns whether node is `note-control-sizing` or not.
		     *
		     * @param {Node} node
		     * @return {Boolean}
		     */
		    var isControlSizing = function (node) {
		      return node && $(node).hasClass('note-control-sizing');
		    };

		    /**
		     * @method makePredByNodeName
		     *
		     * returns predicate which judge whether nodeName is same
		     *
		     * @param {String} nodeName
		     * @return {Function}
		     */
		    var makePredByNodeName = function (nodeName) {
		      nodeName = nodeName.toUpperCase();
		      return function (node) {
		        return node && node.nodeName.toUpperCase() === nodeName;
		      };
		    };

		    /**
		     * @method isText
		     *
		     *
		     *
		     * @param {Node} node
		     * @return {Boolean} true if node's type is text(3)
		     */
		    var isText = function (node) {
		      return node && node.nodeType === 3;
		    };

		    /**
		     * @method isElement
		     *
		     *
		     *
		     * @param {Node} node
		     * @return {Boolean} true if node's type is element(1)
		     */
		    var isElement = function (node) {
		      return node && node.nodeType === 1;
		    };

		    /**
		     * ex) br, col, embed, hr, img, input, ...
		     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
		     */
		    var isVoid = function (node) {
		      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());
		    };

		    var isPara = function (node) {
		      if (isEditable(node)) {
		        return false;
		      }

		      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph
		      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
		    };

		    var isHeading = function (node) {
		      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());
		    };

		    var isPre = makePredByNodeName('PRE');

		    var isLi = makePredByNodeName('LI');

		    var isPurePara = function (node) {
		      return isPara(node) && !isLi(node);
		    };

		    var isTable = makePredByNodeName('TABLE');

		    var isData = makePredByNodeName('DATA');

		    var isInline = function (node) {
		      return !isBodyContainer(node) &&
		             !isList(node) &&
		             !isHr(node) &&
		             !isPara(node) &&
		             !isTable(node) &&
		             !isBlockquote(node) &&
		             !isData(node);
		    };

		    var isList = function (node) {
		      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
		    };

		    var isHr = makePredByNodeName('HR');

		    var isCell = function (node) {
		      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
		    };

		    var isBlockquote = makePredByNodeName('BLOCKQUOTE');

		    var isBodyContainer = function (node) {
		      return isCell(node) || isBlockquote(node) || isEditable(node);
		    };

		    var isAnchor = makePredByNodeName('A');

		    var isParaInline = function (node) {
		      return isInline(node) && !!ancestor(node, isPara);
		    };

		    var isBodyInline = function (node) {
		      return isInline(node) && !ancestor(node, isPara);
		    };

		    var isBody = makePredByNodeName('BODY');

		    /**
		     * returns whether nodeB is closest sibling of nodeA
		     *
		     * @param {Node} nodeA
		     * @param {Node} nodeB
		     * @return {Boolean}
		     */
		    var isClosestSibling = function (nodeA, nodeB) {
		      return nodeA.nextSibling === nodeB ||
		             nodeA.previousSibling === nodeB;
		    };

		    /**
		     * returns array of closest siblings with node
		     *
		     * @param {Node} node
		     * @param {function} [pred] - predicate function
		     * @return {Node[]}
		     */
		    var withClosestSiblings = function (node, pred) {
		      pred = pred || func.ok;

		      var siblings = [];
		      if (node.previousSibling && pred(node.previousSibling)) {
		        siblings.push(node.previousSibling);
		      }
		      siblings.push(node);
		      if (node.nextSibling && pred(node.nextSibling)) {
		        siblings.push(node.nextSibling);
		      }
		      return siblings;
		    };

		    /**
		     * blank HTML for cursor position
		     * - [workaround] old IE only works with &nbsp;
		     * - [workaround] IE11 and other browser works with bogus br
		     */
		    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';

		    /**
		     * @method nodeLength
		     *
		     * returns #text's text size or element's childNodes size
		     *
		     * @param {Node} node
		     */
		    var nodeLength = function (node) {
		      if (isText(node)) {
		        return node.nodeValue.length;
		      }
		      
		      if (node) {
		        return node.childNodes.length;
		      }
		      
		      return 0;
		      
		    };

		    /**
		     * returns whether node is empty or not.
		     *
		     * @param {Node} node
		     * @return {Boolean}
		     */
		    var isEmpty = function (node) {
		      var len = nodeLength(node);

		      if (len === 0) {
		        return true;
		      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
		        // ex) <p><br></p>, <span><br></span>
		        return true;
		      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {
		        // ex) <p></p>, <span></span>
		        return true;
		      }

		      return false;
		    };

		    /**
		     * padding blankHTML if node is empty (for cursor position)
		     */
		    var paddingBlankHTML = function (node) {
		      if (!isVoid(node) && !nodeLength(node)) {
		        node.innerHTML = blankHTML;
		      }
		    };

		    /**
		     * find nearest ancestor predicate hit
		     *
		     * @param {Node} node
		     * @param {Function} pred - predicate function
		     */
		    var ancestor = function (node, pred) {
		      while (node) {
		        if (pred(node)) { return node; }
		        if (isEditable(node)) { break; }

		        node = node.parentNode;
		      }
		      return null;
		    };

		    /**
		     * find nearest ancestor only single child blood line and predicate hit
		     *
		     * @param {Node} node
		     * @param {Function} pred - predicate function
		     */
		    var singleChildAncestor = function (node, pred) {
		      node = node.parentNode;

		      while (node) {
		        if (nodeLength(node) !== 1) { break; }
		        if (pred(node)) { return node; }
		        if (isEditable(node)) { break; }

		        node = node.parentNode;
		      }
		      return null;
		    };

		    /**
		     * returns new array of ancestor nodes (until predicate hit).
		     *
		     * @param {Node} node
		     * @param {Function} [optional] pred - predicate function
		     */
		    var listAncestor = function (node, pred) {
		      pred = pred || func.fail;

		      var ancestors = [];
		      ancestor(node, function (el) {
		        if (!isEditable(el)) {
		          ancestors.push(el);
		        }

		        return pred(el);
		      });
		      return ancestors;
		    };

		    /**
		     * find farthest ancestor predicate hit
		     */
		    var lastAncestor = function (node, pred) {
		      var ancestors = listAncestor(node);
		      return list.last(ancestors.filter(pred));
		    };

		    /**
		     * returns common ancestor node between two nodes.
		     *
		     * @param {Node} nodeA
		     * @param {Node} nodeB
		     */
		    var commonAncestor = function (nodeA, nodeB) {
		      var ancestors = listAncestor(nodeA);
		      for (var n = nodeB; n; n = n.parentNode) {
		        if ($.inArray(n, ancestors) > -1) { return n; }
		      }
		      return null; // difference document area
		    };

		    /**
		     * listing all previous siblings (until predicate hit).
		     *
		     * @param {Node} node
		     * @param {Function} [optional] pred - predicate function
		     */
		    var listPrev = function (node, pred) {
		      pred = pred || func.fail;

		      var nodes = [];
		      while (node) {
		        if (pred(node)) { break; }
		        nodes.push(node);
		        node = node.previousSibling;
		      }
		      return nodes;
		    };

		    /**
		     * listing next siblings (until predicate hit).
		     *
		     * @param {Node} node
		     * @param {Function} [pred] - predicate function
		     */
		    var listNext = function (node, pred) {
		      pred = pred || func.fail;

		      var nodes = [];
		      while (node) {
		        if (pred(node)) { break; }
		        nodes.push(node);
		        node = node.nextSibling;
		      }
		      return nodes;
		    };

		    /**
		     * listing descendant nodes
		     *
		     * @param {Node} node
		     * @param {Function} [pred] - predicate function
		     */
		    var listDescendant = function (node, pred) {
		      var descendants = [];
		      pred = pred || func.ok;

		      // start DFS(depth first search) with node
		      (function fnWalk(current) {
		        if (node !== current && pred(current)) {
		          descendants.push(current);
		        }
		        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
		          fnWalk(current.childNodes[idx]);
		        }
		      })(node);

		      return descendants;
		    };

		    /**
		     * wrap node with new tag.
		     *
		     * @param {Node} node
		     * @param {Node} tagName of wrapper
		     * @return {Node} - wrapper
		     */
		    var wrap = function (node, wrapperName) {
		      var parent = node.parentNode;
		      var wrapper = $('<' + wrapperName + '>')[0];

		      parent.insertBefore(wrapper, node);
		      wrapper.appendChild(node);

		      return wrapper;
		    };

		    /**
		     * insert node after preceding
		     *
		     * @param {Node} node
		     * @param {Node} preceding - predicate function
		     */
		    var insertAfter = function (node, preceding) {
		      var next = preceding.nextSibling, parent = preceding.parentNode;
		      if (next) {
		        parent.insertBefore(node, next);
		      } else {
		        parent.appendChild(node);
		      }
		      return node;
		    };

		    /**
		     * append elements.
		     *
		     * @param {Node} node
		     * @param {Collection} aChild
		     */
		    var appendChildNodes = function (node, aChild) {
		      $.each(aChild, function (idx, child) {
		        node.appendChild(child);
		      });
		      return node;
		    };

		    /**
		     * returns whether boundaryPoint is left edge or not.
		     *
		     * @param {BoundaryPoint} point
		     * @return {Boolean}
		     */
		    var isLeftEdgePoint = function (point) {
		      return point.offset === 0;
		    };

		    /**
		     * returns whether boundaryPoint is right edge or not.
		     *
		     * @param {BoundaryPoint} point
		     * @return {Boolean}
		     */
		    var isRightEdgePoint = function (point) {
		      return point.offset === nodeLength(point.node);
		    };

		    /**
		     * returns whether boundaryPoint is edge or not.
		     *
		     * @param {BoundaryPoint} point
		     * @return {Boolean}
		     */
		    var isEdgePoint = function (point) {
		      return isLeftEdgePoint(point) || isRightEdgePoint(point);
		    };

		    /**
		     * returns whether node is left edge of ancestor or not.
		     *
		     * @param {Node} node
		     * @param {Node} ancestor
		     * @return {Boolean}
		     */
		    var isLeftEdgeOf = function (node, ancestor) {
		      while (node && node !== ancestor) {
		        if (position(node) !== 0) {
		          return false;
		        }
		        node = node.parentNode;
		      }

		      return true;
		    };

		    /**
		     * returns whether node is right edge of ancestor or not.
		     *
		     * @param {Node} node
		     * @param {Node} ancestor
		     * @return {Boolean}
		     */
		    var isRightEdgeOf = function (node, ancestor) {
		      if (!ancestor) {
		        return false;
		      }
		      while (node && node !== ancestor) {
		        if (position(node) !== nodeLength(node.parentNode) - 1) {
		          return false;
		        }
		        node = node.parentNode;
		      }

		      return true;
		    };

		    /**
		     * returns whether point is left edge of ancestor or not.
		     * @param {BoundaryPoint} point
		     * @param {Node} ancestor
		     * @return {Boolean}
		     */
		    var isLeftEdgePointOf = function (point, ancestor) {
		      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);
		    };

		    /**
		     * returns whether point is right edge of ancestor or not.
		     * @param {BoundaryPoint} point
		     * @param {Node} ancestor
		     * @return {Boolean}
		     */
		    var isRightEdgePointOf = function (point, ancestor) {
		      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);
		    };

		    /**
		     * returns offset from parent.
		     *
		     * @param {Node} node
		     */
		    var position = function (node) {
		      var offset = 0;
		      while ((node = node.previousSibling)) {
		        offset += 1;
		      }
		      return offset;
		    };

		    var hasChildren = function (node) {
		      return !!(node && node.childNodes && node.childNodes.length);
		    };

		    /**
		     * returns previous boundaryPoint
		     *
		     * @param {BoundaryPoint} point
		     * @param {Boolean} isSkipInnerOffset
		     * @return {BoundaryPoint}
		     */
		    var prevPoint = function (point, isSkipInnerOffset) {
		      var node, offset;

		      if (point.offset === 0) {
		        if (isEditable(point.node)) {
		          return null;
		        }

		        node = point.node.parentNode;
		        offset = position(point.node);
		      } else if (hasChildren(point.node)) {
		        node = point.node.childNodes[point.offset - 1];
		        offset = nodeLength(node);
		      } else {
		        node = point.node;
		        offset = isSkipInnerOffset ? 0 : point.offset - 1;
		      }

		      return {
		        node: node,
		        offset: offset
		      };
		    };

		    /**
		     * returns next boundaryPoint
		     *
		     * @param {BoundaryPoint} point
		     * @param {Boolean} isSkipInnerOffset
		     * @return {BoundaryPoint}
		     */
		    var nextPoint = function (point, isSkipInnerOffset) {
		      var node, offset;

		      if (nodeLength(point.node) === point.offset) {
		        if (isEditable(point.node)) {
		          return null;
		        }

		        node = point.node.parentNode;
		        offset = position(point.node) + 1;
		      } else if (hasChildren(point.node)) {
		        node = point.node.childNodes[point.offset];
		        offset = 0;
		      } else {
		        node = point.node;
		        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
		      }

		      return {
		        node: node,
		        offset: offset
		      };
		    };

		    /**
		     * returns whether pointA and pointB is same or not.
		     *
		     * @param {BoundaryPoint} pointA
		     * @param {BoundaryPoint} pointB
		     * @return {Boolean}
		     */
		    var isSamePoint = function (pointA, pointB) {
		      return pointA.node === pointB.node && pointA.offset === pointB.offset;
		    };

		    /**
		     * returns whether point is visible (can set cursor) or not.
		     *
		     * @param {BoundaryPoint} point
		     * @return {Boolean}
		     */
		    var isVisiblePoint = function (point) {
		      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {
		        return true;
		      }

		      var leftNode = point.node.childNodes[point.offset - 1];
		      var rightNode = point.node.childNodes[point.offset];
		      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {
		        return true;
		      }

		      return false;
		    };

		    /**
		     * @method prevPointUtil
		     *
		     * @param {BoundaryPoint} point
		     * @param {Function} pred
		     * @return {BoundaryPoint}
		     */
		    var prevPointUntil = function (point, pred) {
		      while (point) {
		        if (pred(point)) {
		          return point;
		        }

		        point = prevPoint(point);
		      }

		      return null;
		    };

		    /**
		     * @method nextPointUntil
		     *
		     * @param {BoundaryPoint} point
		     * @param {Function} pred
		     * @return {BoundaryPoint}
		     */
		    var nextPointUntil = function (point, pred) {
		      while (point) {
		        if (pred(point)) {
		          return point;
		        }

		        point = nextPoint(point);
		      }

		      return null;
		    };

		    /**
		     * returns whether point has character or not.
		     *
		     * @param {Point} point
		     * @return {Boolean}
		     */
		    var isCharPoint = function (point) {
		      if (!isText(point.node)) {
		        return false;
		      }

		      var ch = point.node.nodeValue.charAt(point.offset - 1);
		      return ch && (ch !== ' ' && ch !== NBSP_CHAR);
		    };

		    /**
		     * @method walkPoint
		     *
		     * @param {BoundaryPoint} startPoint
		     * @param {BoundaryPoint} endPoint
		     * @param {Function} handler
		     * @param {Boolean} isSkipInnerOffset
		     */
		    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {
		      var point = startPoint;

		      while (point) {
		        handler(point);

		        if (isSamePoint(point, endPoint)) {
		          break;
		        }

		        var isSkipOffset = isSkipInnerOffset &&
		                           startPoint.node !== point.node &&
		                           endPoint.node !== point.node;
		        point = nextPoint(point, isSkipOffset);
		      }
		    };

		    /**
		     * @method makeOffsetPath
		     *
		     * return offsetPath(array of offset) from ancestor
		     *
		     * @param {Node} ancestor - ancestor node
		     * @param {Node} node
		     */
		    var makeOffsetPath = function (ancestor, node) {
		      var ancestors = listAncestor(node, func.eq(ancestor));
		      return ancestors.map(position).reverse();
		    };

		    /**
		     * @method fromOffsetPath
		     *
		     * return element from offsetPath(array of offset)
		     *
		     * @param {Node} ancestor - ancestor node
		     * @param {array} offsets - offsetPath
		     */
		    var fromOffsetPath = function (ancestor, offsets) {
		      var current = ancestor;
		      for (var i = 0, len = offsets.length; i < len; i++) {
		        if (current.childNodes.length <= offsets[i]) {
		          current = current.childNodes[current.childNodes.length - 1];
		        } else {
		          current = current.childNodes[offsets[i]];
		        }
		      }
		      return current;
		    };

		    /**
		     * @method splitNode
		     *
		     * split element or #text
		     *
		     * @param {BoundaryPoint} point
		     * @param {Object} [options]
		     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
		     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
		     * @return {Node} right node of boundaryPoint
		     */
		    var splitNode = function (point, options) {
		      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
		      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;

		      // edge case
		      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
		        if (isLeftEdgePoint(point)) {
		          return point.node;
		        } else if (isRightEdgePoint(point)) {
		          return point.node.nextSibling;
		        }
		      }

		      // split #text
		      if (isText(point.node)) {
		        return point.node.splitText(point.offset);
		      } else {
		        var childNode = point.node.childNodes[point.offset];
		        var clone = insertAfter(point.node.cloneNode(false), point.node);
		        appendChildNodes(clone, listNext(childNode));

		        if (!isSkipPaddingBlankHTML) {
		          paddingBlankHTML(point.node);
		          paddingBlankHTML(clone);
		        }

		        return clone;
		      }
		    };

		    /**
		     * @method splitTree
		     *
		     * split tree by point
		     *
		     * @param {Node} root - split root
		     * @param {BoundaryPoint} point
		     * @param {Object} [options]
		     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
		     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
		     * @return {Node} right node of boundaryPoint
		     */
		    var splitTree = function (root, point, options) {
		      // ex) [#text, <span>, <p>]
		      var ancestors = listAncestor(point.node, func.eq(root));

		      if (!ancestors.length) {
		        return null;
		      } else if (ancestors.length === 1) {
		        return splitNode(point, options);
		      }

		      return ancestors.reduce(function (node, parent) {
		        if (node === point.node) {
		          node = splitNode(point, options);
		        }

		        return splitNode({
		          node: parent,
		          offset: node ? dom.position(node) : nodeLength(parent)
		        }, options);
		      });
		    };

		    /**
		     * split point
		     *
		     * @param {Point} point
		     * @param {Boolean} isInline
		     * @return {Object}
		     */
		    var splitPoint = function (point, isInline) {
		      // find splitRoot, container
		      //  - inline: splitRoot is a child of paragraph
		      //  - block: splitRoot is a child of bodyContainer
		      var pred = isInline ? isPara : isBodyContainer;
		      var ancestors = listAncestor(point.node, pred);
		      var topAncestor = list.last(ancestors) || point.node;

		      var splitRoot, container;
		      if (pred(topAncestor)) {
		        splitRoot = ancestors[ancestors.length - 2];
		        container = topAncestor;
		      } else {
		        splitRoot = topAncestor;
		        container = splitRoot.parentNode;
		      }

		      // if splitRoot is exists, split with splitTree
		      var pivot = splitRoot && splitTree(splitRoot, point, {
		        isSkipPaddingBlankHTML: isInline,
		        isNotSplitEdgePoint: isInline
		      });

		      // if container is point.node, find pivot with point.offset
		      if (!pivot && container === point.node) {
		        pivot = point.node.childNodes[point.offset];
		      }

		      return {
		        rightNode: pivot,
		        container: container
		      };
		    };

		    var create = function (nodeName) {
		      return document.createElement(nodeName);
		    };

		    var createText = function (text) {
		      return document.createTextNode(text);
		    };

		    /**
		     * @method remove
		     *
		     * remove node, (isRemoveChild: remove child or not)
		     *
		     * @param {Node} node
		     * @param {Boolean} isRemoveChild
		     */
		    var remove = function (node, isRemoveChild) {
		      if (!node || !node.parentNode) { return; }
		      if (node.removeNode) { return node.removeNode(isRemoveChild); }

		      var parent = node.parentNode;
		      if (!isRemoveChild) {
		        var nodes = [];
		        var i, len;
		        for (i = 0, len = node.childNodes.length; i < len; i++) {
		          nodes.push(node.childNodes[i]);
		        }

		        for (i = 0, len = nodes.length; i < len; i++) {
		          parent.insertBefore(nodes[i], node);
		        }
		      }

		      parent.removeChild(node);
		    };

		    /**
		     * @method removeWhile
		     *
		     * @param {Node} node
		     * @param {Function} pred
		     */
		    var removeWhile = function (node, pred) {
		      while (node) {
		        if (isEditable(node) || !pred(node)) {
		          break;
		        }

		        var parent = node.parentNode;
		        remove(node);
		        node = parent;
		      }
		    };

		    /**
		     * @method replace
		     *
		     * replace node with provided nodeName
		     *
		     * @param {Node} node
		     * @param {String} nodeName
		     * @return {Node} - new node
		     */
		    var replace = function (node, nodeName) {
		      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
		        return node;
		      }

		      var newNode = create(nodeName);

		      if (node.style.cssText) {
		        newNode.style.cssText = node.style.cssText;
		      }

		      appendChildNodes(newNode, list.from(node.childNodes));
		      insertAfter(newNode, node);
		      remove(node);

		      return newNode;
		    };

		    var isTextarea = makePredByNodeName('TEXTAREA');

		    /**
		     * @param {jQuery} $node
		     * @param {Boolean} [stripLinebreaks] - default: false
		     */
		    var value = function ($node, stripLinebreaks) {
		      var val = isTextarea($node[0]) ? $node.val() : $node.html();
		      if (stripLinebreaks) {
		        return val.replace(/[\n\r]/g, '');
		      }
		      return val;
		    };

		    /**
		     * @method html
		     *
		     * get the HTML contents of node
		     *
		     * @param {jQuery} $node
		     * @param {Boolean} [isNewlineOnBlock]
		     */
		    var html = function ($node, isNewlineOnBlock) {
		      var markup = value($node);

		      if (isNewlineOnBlock) {
		        var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
		        markup = markup.replace(regexTag, function (match, endSlash, name) {
		          name = name.toUpperCase();
		          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&
		                                       !!endSlash;
		          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);

		          return match + ((isEndOfInlineContainer || isBlockNode) ? '\n' : '');
		        });
		        markup = $.trim(markup);
		      }

		      return markup;
		    };

		    var posFromPlaceholder = function (placeholder) {
		      var $placeholder = $(placeholder);
		      var pos = $placeholder.offset();
		      var height = $placeholder.outerHeight(true); // include margin

		      return {
		        left: pos.left,
		        top: pos.top + height
		      };
		    };

		    var attachEvents = function ($node, events) {
		      Object.keys(events).forEach(function (key) {
		        $node.on(key, events[key]);
		      });
		    };

		    var detachEvents = function ($node, events) {
		      Object.keys(events).forEach(function (key) {
		        $node.off(key, events[key]);
		      });
		    };

		    return {
		      /** @property {String} NBSP_CHAR */
		      NBSP_CHAR: NBSP_CHAR,
		      /** @property {String} ZERO_WIDTH_NBSP_CHAR */
		      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,
		      /** @property {String} blank */
		      blank: blankHTML,
		      /** @property {String} emptyPara */
		      emptyPara: '<p>' + blankHTML + '</p>',
		      makePredByNodeName: makePredByNodeName,
		      isEditable: isEditable,
		      isControlSizing: isControlSizing,
		      isText: isText,
		      isElement: isElement,
		      isVoid: isVoid,
		      isPara: isPara,
		      isPurePara: isPurePara,
		      isHeading: isHeading,
		      isInline: isInline,
		      isBlock: func.not(isInline),
		      isBodyInline: isBodyInline,
		      isBody: isBody,
		      isParaInline: isParaInline,
		      isPre: isPre,
		      isList: isList,
		      isTable: isTable,
		      isData: isData,
		      isCell: isCell,
		      isBlockquote: isBlockquote,
		      isBodyContainer: isBodyContainer,
		      isAnchor: isAnchor,
		      isDiv: makePredByNodeName('DIV'),
		      isLi: isLi,
		      isBR: makePredByNodeName('BR'),
		      isSpan: makePredByNodeName('SPAN'),
		      isB: makePredByNodeName('B'),
		      isU: makePredByNodeName('U'),
		      isS: makePredByNodeName('S'),
		      isI: makePredByNodeName('I'),
		      isImg: makePredByNodeName('IMG'),
		      isTextarea: isTextarea,
		      isEmpty: isEmpty,
		      isEmptyAnchor: func.and(isAnchor, isEmpty),
		      isClosestSibling: isClosestSibling,
		      withClosestSiblings: withClosestSiblings,
		      nodeLength: nodeLength,
		      isLeftEdgePoint: isLeftEdgePoint,
		      isRightEdgePoint: isRightEdgePoint,
		      isEdgePoint: isEdgePoint,
		      isLeftEdgeOf: isLeftEdgeOf,
		      isRightEdgeOf: isRightEdgeOf,
		      isLeftEdgePointOf: isLeftEdgePointOf,
		      isRightEdgePointOf: isRightEdgePointOf,
		      prevPoint: prevPoint,
		      nextPoint: nextPoint,
		      isSamePoint: isSamePoint,
		      isVisiblePoint: isVisiblePoint,
		      prevPointUntil: prevPointUntil,
		      nextPointUntil: nextPointUntil,
		      isCharPoint: isCharPoint,
		      walkPoint: walkPoint,
		      ancestor: ancestor,
		      singleChildAncestor: singleChildAncestor,
		      listAncestor: listAncestor,
		      lastAncestor: lastAncestor,
		      listNext: listNext,
		      listPrev: listPrev,
		      listDescendant: listDescendant,
		      commonAncestor: commonAncestor,
		      wrap: wrap,
		      insertAfter: insertAfter,
		      appendChildNodes: appendChildNodes,
		      position: position,
		      hasChildren: hasChildren,
		      makeOffsetPath: makeOffsetPath,
		      fromOffsetPath: fromOffsetPath,
		      splitTree: splitTree,
		      splitPoint: splitPoint,
		      create: create,
		      createText: createText,
		      remove: remove,
		      removeWhile: removeWhile,
		      replace: replace,
		      html: html,
		      value: value,
		      posFromPlaceholder: posFromPlaceholder,
		      attachEvents: attachEvents,
		      detachEvents: detachEvents
		    };
		  })();

		  /**
		   * @param {jQuery} $note
		   * @param {Object} options
		   * @return {Context}
		   */
		  var Context = function ($note, options) {
		    var self = this;

		    var ui = $.summernote.ui;
		    this.memos = {};
		    this.modules = {};
		    this.layoutInfo = {};
		    this.options = options;

		    /**
		     * create layout and initialize modules and other resources
		     */
		    this.initialize = function () {
		      this.layoutInfo = ui.createLayout($note, options);
		      this._initialize();
		      $note.hide();
		      return this;
		    };

		    /**
		     * destroy modules and other resources and remove layout
		     */
		    this.destroy = function () {
		      this._destroy();
		      $note.removeData('summernote');
		      ui.removeLayout($note, this.layoutInfo);
		    };

		    /**
		     * destory modules and other resources and initialize it again
		     */
		    this.reset = function () {
		      var disabled = self.isDisabled();
		      this.code(dom.emptyPara);
		      this._destroy();
		      this._initialize();

		      if (disabled) {
		        self.disable();
		      }
		    };

		    this._initialize = function () {
		      // add optional buttons
		      var buttons = $.extend({}, this.options.buttons);
		      Object.keys(buttons).forEach(function (key) {
		        self.memo('button.' + key, buttons[key]);
		      });

		      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});

		      // add and initialize modules
		      Object.keys(modules).forEach(function (key) {
		        self.module(key, modules[key], true);
		      });

		      Object.keys(this.modules).forEach(function (key) {
		        self.initializeModule(key);
		      });
		    };

		    this._destroy = function () {
		      // destroy modules with reversed order
		      Object.keys(this.modules).reverse().forEach(function (key) {
		        self.removeModule(key);
		      });

		      Object.keys(this.memos).forEach(function (key) {
		        self.removeMemo(key);
		      });
		    };

		    this.code = function (html) {
		      var isActivated = this.invoke('codeview.isActivated');

		      if (html === undefined) {
		        this.invoke('codeview.sync');
		        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
		      } else {
		        if (isActivated) {
		          this.layoutInfo.codable.val(html);
		        } else {
		          this.layoutInfo.editable.html(html);
		        }
		        $note.val(html);
		        this.triggerEvent('change', html);
		      }
		    };

		    this.isDisabled = function () {
		      return this.layoutInfo.editable.attr('contenteditable') === 'false';
		    };

		    this.enable = function () {
		      this.layoutInfo.editable.attr('contenteditable', true);
		      this.invoke('toolbar.activate', true);
		    };

		    this.disable = function () {
		      // close codeview if codeview is opend
		      if (this.invoke('codeview.isActivated')) {
		        this.invoke('codeview.deactivate');
		      }
		      this.layoutInfo.editable.attr('contenteditable', false);
		      this.invoke('toolbar.deactivate', true);
		    };

		    this.triggerEvent = function () {
		      var namespace = list.head(arguments);
		      var args = list.tail(list.from(arguments));

		      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];
		      if (callback) {
		        callback.apply($note[0], args);
		      }
		      $note.trigger('summernote.' + namespace, args);
		    };

		    this.initializeModule = function (key) {
		      var module = this.modules[key];
		      module.shouldInitialize = module.shouldInitialize || func.ok;
		      if (!module.shouldInitialize()) {
		        return;
		      }

		      // initialize module
		      if (module.initialize) {
		        module.initialize();
		      }

		      // attach events
		      if (module.events) {
		        dom.attachEvents($note, module.events);
		      }
		    };

		    this.module = function (key, ModuleClass, withoutIntialize) {
		      if (arguments.length === 1) {
		        return this.modules[key];
		      }

		      this.modules[key] = new ModuleClass(this);

		      if (!withoutIntialize) {
		        this.initializeModule(key);
		      }
		    };

		    this.removeModule = function (key) {
		      var module = this.modules[key];
		      if (module.shouldInitialize()) {
		        if (module.events) {
		          dom.detachEvents($note, module.events);
		        }

		        if (module.destroy) {
		          module.destroy();
		        }
		      }

		      delete this.modules[key];
		    };

		    this.memo = function (key, obj) {
		      if (arguments.length === 1) {
		        return this.memos[key];
		      }
		      this.memos[key] = obj;
		    };

		    this.removeMemo = function (key) {
		      if (this.memos[key] && this.memos[key].destroy) {
		        this.memos[key].destroy();
		      }

		      delete this.memos[key];
		    };

		    this.createInvokeHandler = function (namespace, value) {
		      return function (event) {
		        event.preventDefault();
		        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));
		      };
		    };

		    this.invoke = function () {
		      var namespace = list.head(arguments);
		      var args = list.tail(list.from(arguments));

		      var splits = namespace.split('.');
		      var hasSeparator = splits.length > 1;
		      var moduleName = hasSeparator && list.head(splits);
		      var methodName = hasSeparator ? list.last(splits) : list.head(splits);

		      var module = this.modules[moduleName || 'editor'];
		      if (!moduleName && this[methodName]) {
		        return this[methodName].apply(this, args);
		      } else if (module && module[methodName] && module.shouldInitialize()) {
		        return module[methodName].apply(module, args);
		      }
		    };

		    return this.initialize();
		  };

		  $.fn.extend({
		    /**
		     * Summernote API
		     *
		     * @param {Object|String}
		     * @return {this}
		     */
		    summernote: function () {
		      var type = $.type(list.head(arguments));
		      var isExternalAPICalled = type === 'string';
		      var hasInitOptions = type === 'object';

		      var options = hasInitOptions ? list.head(arguments) : {};

		      options = $.extend({}, $.summernote.options, options);
		      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);
		      options.icons = $.extend(true, {}, $.summernote.options.icons, options.icons);

		      this.each(function (idx, note) {
		        var $note = $(note);
		        if (!$note.data('summernote')) {
		          var context = new Context($note, options);
		          $note.data('summernote', context);
		          $note.data('summernote').triggerEvent('init', context.layoutInfo);
		        }
		      });

		      var $note = this.first();
		      if ($note.length) {
		        var context = $note.data('summernote');
		        if (isExternalAPICalled) {
		          return context.invoke.apply(context, list.from(arguments));
		        } else if (options.focus) {
		          context.invoke('editor.focus');
		        }
		      }

		      return this;
		    }
		  });


		  var Renderer = function (markup, children, options, callback) {
		    this.render = function ($parent) {
		      var $node = $(markup);

		      if (options && options.contents) {
		        $node.html(options.contents);
		      }

		      if (options && options.className) {
		        $node.addClass(options.className);
		      }

		      if (options && options.data) {
		        $.each(options.data, function (k, v) {
		          $node.attr('data-' + k, v);
		        });
		      }

		      if (options && options.click) {
		        $node.on('click', options.click);
		      }

		      if (children) {
		        var $container = $node.find('.note-children-container');
		        children.forEach(function (child) {
		          child.render($container.length ? $container : $node);
		        });
		      }

		      if (callback) {
		        callback($node, options);
		      }

		      if (options && options.callback) {
		        options.callback($node);
		      }

		      if ($parent) {
		        $parent.append($node);
		      }

		      return $node;
		    };
		  };

		  var renderer = {
		    create: function (markup, callback) {
		      return function () {
		        var children = $.isArray(arguments[0]) ? arguments[0] : [];
		        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];
		        if (options && options.children) {
		          children = options.children;
		        }
		        return new Renderer(markup, children, options, callback);
		      };
		    }
		  };

		  var editor = renderer.create('<div class="note-editor note-frame panel panel-default"/>');
		  var toolbar = renderer.create('<div class="note-toolbar panel-heading"/>');
		  var editingArea = renderer.create('<div class="note-editing-area"/>');
		  var codable = renderer.create('<textarea class="note-codable"/>');
		  var editable = renderer.create('<div class="note-editable panel-body" contentEditable="true"/>');
		  var statusbar = renderer.create([
		    '<div class="note-statusbar">',
		    '  <div class="note-resizebar">',
		    '    <div class="note-icon-bar"/>',
		    '    <div class="note-icon-bar"/>',
		    '    <div class="note-icon-bar"/>',
		    '  </div>',
		    '</div>'
		  ].join(''));

		  var airEditor = renderer.create('<div class="note-editor"/>');
		  var airEditable = renderer.create('<div class="note-editable" contentEditable="true"/>');

		  var buttonGroup = renderer.create('<div class="note-btn-group btn-group">');
		  var button = renderer.create('<button type="button" class="note-btn btn btn-default btn-sm" tabindex="-1">', function ($node, options) {
		    if (options && options.tooltip) {
		      $node.attr({
		        title: options.tooltip
		      }).tooltip({
		        container: 'body',
		        trigger: 'hover',
		        placement: 'bottom'
		      });
		    }
		  });

		  var dropdown = renderer.create('<div class="dropdown-menu">', function ($node, options) {
		    var markup = $.isArray(options.items) ? options.items.map(function (item) {
		      var value = (typeof item === 'string') ? item : (item.value || '');
		      var content = options.template ? options.template(item) : item;
		      return '<li><a href="#" data-value="' + value + '">' + content + '</a></li>';
		    }).join('') : options.items;

		    $node.html(markup);
		  });

		  var dropdownCheck = renderer.create('<div class="dropdown-menu note-check">', function ($node, options) {
		    var markup = $.isArray(options.items) ? options.items.map(function (item) {
		      var value = (typeof item === 'string') ? item : (item.value || '');
		      var content = options.template ? options.template(item) : item;
		      return '<li><a href="#" data-value="' + value + '">' + icon(options.checkClassName) + ' ' + content + '</a></li>';
		    }).join('') : options.items;
		    $node.html(markup);
		  });

		  var palette = renderer.create('<div class="note-color-palette"/>', function ($node, options) {
		    var contents = [];
		    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {
		      var eventName = options.eventName;
		      var colors = options.colors[row];
		      var buttons = [];
		      for (var col = 0, colSize = colors.length; col < colSize; col++) {
		        var color = colors[col];
		        buttons.push([
		          '<button type="button" class="note-color-btn"',
		          'style="background-color:', color, '" ',
		          'data-event="', eventName, '" ',
		          'data-value="', color, '" ',
		          'title="', color, '" ',
		          'data-toggle="button" tabindex="-1"></button>'
		        ].join(''));
		      }
		      contents.push('<div class="note-color-row">' + buttons.join('') + '</div>');
		    }
		    $node.html(contents.join(''));

		    $node.find('.note-color-btn').tooltip({
		      container: 'body',
		      trigger: 'hover',
		      placement: 'bottom'
		    });
		  });

		  var dialog = renderer.create('<div class="modal" aria-hidden="false" tabindex="-1"/>', function ($node, options) {
		    if (options.fade) {
		      $node.addClass('fade');
		    }
		    $node.html([
		      '<div class="modal-dialog">',
		      '  <div class="modal-content">',
		      (options.title ?
		      '    <div class="modal-header">' +
		      '      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>' +
		      '      <h4 class="modal-title">' + options.title + '</h4>' +
		      '    </div>' : ''
		      ),
		      '    <div class="modal-body">' + options.body + '</div>',
		      (options.footer ?
		      '    <div class="modal-footer">' + options.footer + '</div>' : ''
		      ),
		      '  </div>',
		      '</div>'
		    ].join(''));
		  });

		  var popover = renderer.create([
		    '<div class="note-popover popover in">',
		    '  <div class="arrow"/>',
		    '  <div class="popover-content note-children-container"/>',
		    '</div>'
		  ].join(''), function ($node, options) {
		    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';

		    $node.addClass(direction);

		    if (options.hideArrow) {
		      $node.find('.arrow').hide();
		    }
		  });

		  var icon = function (iconClassName, tagName) {
		    tagName = tagName || 'i';
		    return '<' + tagName + ' class="' + iconClassName + '"/>';
		  };

		  var ui = {
		    editor: editor,
		    toolbar: toolbar,
		    editingArea: editingArea,
		    codable: codable,
		    editable: editable,
		    statusbar: statusbar,
		    airEditor: airEditor,
		    airEditable: airEditable,
		    buttonGroup: buttonGroup,
		    button: button,
		    dropdown: dropdown,
		    dropdownCheck: dropdownCheck,
		    palette: palette,
		    dialog: dialog,
		    popover: popover,
		    icon: icon,

		    toggleBtn: function ($btn, isEnable) {
		      $btn.toggleClass('disabled', !isEnable);
		      $btn.attr('disabled', !isEnable);
		    },

		    toggleBtnActive: function ($btn, isActive) {
		      $btn.toggleClass('active', isActive);
		    },

		    onDialogShown: function ($dialog, handler) {
		      $dialog.one('shown.bs.modal', handler);
		    },

		    onDialogHidden: function ($dialog, handler) {
		      $dialog.one('hidden.bs.modal', handler);
		    },

		    showDialog: function ($dialog) {
		      $dialog.modal('show');
		    },

		    hideDialog: function ($dialog) {
		      $dialog.modal('hide');
		    },

		    createLayout: function ($note, options) {
		      var $editor = (options.airMode ? ui.airEditor([
		        ui.editingArea([
		          ui.airEditable()
		        ])
		      ]) : ui.editor([
		        ui.toolbar(),
		        ui.editingArea([
		          ui.codable(),
		          ui.editable()
		        ]),
		        ui.statusbar()
		      ])).render();

		      $editor.insertAfter($note);

		      return {
		        note: $note,
		        editor: $editor,
		        toolbar: $editor.find('.note-toolbar'),
		        editingArea: $editor.find('.note-editing-area'),
		        editable: $editor.find('.note-editable'),
		        codable: $editor.find('.note-codable'),
		        statusbar: $editor.find('.note-statusbar')
		      };
		    },

		    removeLayout: function ($note, layoutInfo) {
		      $note.html(layoutInfo.editable.html());
		      layoutInfo.editor.remove();
		      $note.show();
		    }
		  };

		  $.summernote = $.summernote || {
		    lang: {}
		  };

		  $.extend($.summernote.lang, {
		    'en-US': {
		      font: {
		        bold: 'Bold',
		        italic: 'Italic',
		        underline: 'Underline',
		        clear: 'Remove Font Style',
		        height: 'Line Height',
		        name: 'Font Family',
		        strikethrough: 'Strikethrough',
		        subscript: 'Subscript',
		        superscript: 'Superscript',
		        size: 'Font Size'
		      },
		      image: {
		        image: 'Picture',
		        insert: 'Insert Image',
		        resizeFull: 'Resize Full',
		        resizeHalf: 'Resize Half',
		        resizeQuarter: 'Resize Quarter',
		        floatLeft: 'Float Left',
		        floatRight: 'Float Right',
		        floatNone: 'Float None',
		        shapeRounded: 'Shape: Rounded',
		        shapeCircle: 'Shape: Circle',
		        shapeThumbnail: 'Shape: Thumbnail',
		        shapeNone: 'Shape: None',
		        dragImageHere: 'Drag image or text here',
		        dropImage: 'Drop image or Text',
		        selectFromFiles: 'Select from files',
		        maximumFileSize: 'Maximum file size',
		        maximumFileSizeError: 'Maximum file size exceeded.',
		        url: 'Image URL',
		        remove: 'Remove Image'
		      },
		      video: {
		        video: 'Video',
		        videoLink: 'Video Link',
		        insert: 'Insert Video',
		        url: 'Video URL?',
		        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'
		      },
		      link: {
		        link: 'Link',
		        insert: 'Insert Link',
		        unlink: 'Unlink',
		        edit: 'Edit',
		        textToDisplay: 'Text to display',
		        url: 'To what URL should this link go?',
		        openInNewWindow: 'Open in new window'
		      },
		      table: {
		        table: 'Table'
		      },
		      hr: {
		        insert: 'Insert Horizontal Rule'
		      },
		      style: {
		        style: 'Style',
		        normal: 'Normal',
		        blockquote: 'Quote',
		        pre: 'Code',
		        h1: 'Header 1',
		        h2: 'Header 2',
		        h3: 'Header 3',
		        h4: 'Header 4',
		        h5: 'Header 5',
		        h6: 'Header 6'
		      },
		      lists: {
		        unordered: 'Unordered list',
		        ordered: 'Ordered list'
		      },
		      options: {
		        help: 'Help',
		        fullscreen: 'Full Screen',
		        codeview: 'Code View'
		      },
		      paragraph: {
		        paragraph: 'Paragraph',
		        outdent: 'Outdent',
		        indent: 'Indent',
		        left: 'Align left',
		        center: 'Align center',
		        right: 'Align right',
		        justify: 'Justify full'
		      },
		      color: {
		        recent: 'Recent Color',
		        more: 'More Color',
		        background: 'Background Color',
		        foreground: 'Foreground Color',
		        transparent: 'Transparent',
		        setTransparent: 'Set transparent',
		        reset: 'Reset',
		        resetToDefault: 'Reset to default'
		      },
		      shortcut: {
		        shortcuts: 'Keyboard shortcuts',
		        close: 'Close',
		        textFormatting: 'Text formatting',
		        action: 'Action',
		        paragraphFormatting: 'Paragraph formatting',
		        documentStyle: 'Document Style',
		        extraKeys: 'Extra keys'
		      },
		      help: {
		        'insertParagraph': 'Insert Paragraph',
		        'undo': 'Undoes the last command',
		        'redo': 'Redoes the last command',
		        'tab': 'Tab',
		        'untab': 'Untab',
		        'bold': 'Set a bold style',
		        'italic': 'Set a italic style',
		        'underline': 'Set a underline style',
		        'strikethrough': 'Set a strikethrough style',
		        'removeFormat': 'Clean a style',
		        'justifyLeft': 'Set left align',
		        'justifyCenter': 'Set center align',
		        'justifyRight': 'Set right align',
		        'justifyFull': 'Set full align',
		        'insertUnorderedList': 'Toggle unordered list',
		        'insertOrderedList': 'Toggle ordered list',
		        'outdent': 'Outdent on current paragraph',
		        'indent': 'Indent on current paragraph',
		        'formatPara': 'Change current block\'s format as a paragraph(P tag)',
		        'formatH1': 'Change current block\'s format as H1',
		        'formatH2': 'Change current block\'s format as H2',
		        'formatH3': 'Change current block\'s format as H3',
		        'formatH4': 'Change current block\'s format as H4',
		        'formatH5': 'Change current block\'s format as H5',
		        'formatH6': 'Change current block\'s format as H6',
		        'insertHorizontalRule': 'Insert horizontal rule',
		        'linkDialog.show': 'Show Link Dialog'
		      },
		      history: {
		        undo: 'Undo',
		        redo: 'Redo'
		      },
		      specialChar: {
		        specialChar: 'SPECIAL CHARACTERS',
		        select: 'Select Special characters'
		      }
		    }
		  });


		  /**
		   * @class core.key
		   *
		   * Object for keycodes.
		   *
		   * @singleton
		   * @alternateClassName key
		   */
		  var key = (function () {
		    var keyMap = {
		      'BACKSPACE': 8,
		      'TAB': 9,
		      'ENTER': 13,
		      'SPACE': 32,

		      // Arrow
		      'LEFT': 37,
		      'UP': 38,
		      'RIGHT': 39,
		      'DOWN': 40,

		      // Number: 0-9
		      'NUM0': 48,
		      'NUM1': 49,
		      'NUM2': 50,
		      'NUM3': 51,
		      'NUM4': 52,
		      'NUM5': 53,
		      'NUM6': 54,
		      'NUM7': 55,
		      'NUM8': 56,

		      // Alphabet: a-z
		      'B': 66,
		      'E': 69,
		      'I': 73,
		      'J': 74,
		      'K': 75,
		      'L': 76,
		      'R': 82,
		      'S': 83,
		      'U': 85,
		      'V': 86,
		      'Y': 89,
		      'Z': 90,

		      'SLASH': 191,
		      'LEFTBRACKET': 219,
		      'BACKSLASH': 220,
		      'RIGHTBRACKET': 221
		    };

		    return {
		      /**
		       * @method isEdit
		       *
		       * @param {Number} keyCode
		       * @return {Boolean}
		       */
		      isEdit: function (keyCode) {
		        return list.contains([
		          keyMap.BACKSPACE,
		          keyMap.TAB,
		          keyMap.ENTER,
		          keyMap.SPACE
		        ], keyCode);
		      },
		      /**
		       * @method isMove
		       *
		       * @param {Number} keyCode
		       * @return {Boolean}
		       */
		      isMove: function (keyCode) {
		        return list.contains([
		          keyMap.LEFT,
		          keyMap.UP,
		          keyMap.RIGHT,
		          keyMap.DOWN
		        ], keyCode);
		      },
		      /**
		       * @property {Object} nameFromCode
		       * @property {String} nameFromCode.8 "BACKSPACE"
		       */
		      nameFromCode: func.invertObject(keyMap),
		      code: keyMap
		    };
		  })();

		  var range = (function () {

		    /**
		     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js
		     *
		     * @param {TextRange} textRange
		     * @param {Boolean} isStart
		     * @return {BoundaryPoint}
		     *
		     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx
		     */
		    var textRangeToPoint = function (textRange, isStart) {
		      var container = textRange.parentElement(), offset;
		  
		      var tester = document.body.createTextRange(), prevContainer;
		      var childNodes = list.from(container.childNodes);
		      for (offset = 0; offset < childNodes.length; offset++) {
		        if (dom.isText(childNodes[offset])) {
		          continue;
		        }
		        tester.moveToElementText(childNodes[offset]);
		        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {
		          break;
		        }
		        prevContainer = childNodes[offset];
		      }
		  
		      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {
		        var textRangeStart = document.body.createTextRange(), curTextNode = null;
		        textRangeStart.moveToElementText(prevContainer || container);
		        textRangeStart.collapse(!prevContainer);
		        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;
		  
		        var pointTester = textRange.duplicate();
		        pointTester.setEndPoint('StartToStart', textRangeStart);
		        var textCount = pointTester.text.replace(/[\r\n]/g, '').length;
		  
		        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
		          textCount -= curTextNode.nodeValue.length;
		          curTextNode = curTextNode.nextSibling;
		        }
		  
		        /* jshint ignore:start */
		        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack
		        /* jshint ignore:end */
		  
		        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&
		            textCount === curTextNode.nodeValue.length) {
		          textCount -= curTextNode.nodeValue.length;
		          curTextNode = curTextNode.nextSibling;
		        }
		  
		        container = curTextNode;
		        offset = textCount;
		      }
		  
		      return {
		        cont: container,
		        offset: offset
		      };
		    };
		    
		    /**
		     * return TextRange from boundary point (inspired by google closure-library)
		     * @param {BoundaryPoint} point
		     * @return {TextRange}
		     */
		    var pointToTextRange = function (point) {
		      var textRangeInfo = function (container, offset) {
		        var node, isCollapseToStart;
		  
		        if (dom.isText(container)) {
		          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
		          var prevContainer = list.last(prevTextNodes).previousSibling;
		          node =  prevContainer || container.parentNode;
		          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);
		          isCollapseToStart = !prevContainer;
		        } else {
		          node = container.childNodes[offset] || container;
		          if (dom.isText(node)) {
		            return textRangeInfo(node, 0);
		          }
		  
		          offset = 0;
		          isCollapseToStart = false;
		        }
		  
		        return {
		          node: node,
		          collapseToStart: isCollapseToStart,
		          offset: offset
		        };
		      };
		  
		      var textRange = document.body.createTextRange();
		      var info = textRangeInfo(point.node, point.offset);
		  
		      textRange.moveToElementText(info.node);
		      textRange.collapse(info.collapseToStart);
		      textRange.moveStart('character', info.offset);
		      return textRange;
		    };
		    
		    /**
		     * Wrapped Range
		     *
		     * @constructor
		     * @param {Node} sc - start container
		     * @param {Number} so - start offset
		     * @param {Node} ec - end container
		     * @param {Number} eo - end offset
		     */
		    var WrappedRange = function (sc, so, ec, eo) {
		      this.sc = sc;
		      this.so = so;
		      this.ec = ec;
		      this.eo = eo;
		  
		      // nativeRange: get nativeRange from sc, so, ec, eo
		      var nativeRange = function () {
		        if (agent.isW3CRangeSupport) {
		          var w3cRange = document.createRange();
		          w3cRange.setStart(sc, so);
		          w3cRange.setEnd(ec, eo);

		          return w3cRange;
		        } else {
		          var textRange = pointToTextRange({
		            node: sc,
		            offset: so
		          });

		          textRange.setEndPoint('EndToEnd', pointToTextRange({
		            node: ec,
		            offset: eo
		          }));

		          return textRange;
		        }
		      };

		      this.getPoints = function () {
		        return {
		          sc: sc,
		          so: so,
		          ec: ec,
		          eo: eo
		        };
		      };

		      this.getStartPoint = function () {
		        return {
		          node: sc,
		          offset: so
		        };
		      };

		      this.getEndPoint = function () {
		        return {
		          node: ec,
		          offset: eo
		        };
		      };

		      /**
		       * select update visible range
		       */
		      this.select = function () {
		        var nativeRng = nativeRange();
		        if (agent.isW3CRangeSupport) {
		          var selection = document.getSelection();
		          if (selection.rangeCount > 0) {
		            selection.removeAllRanges();
		          }
		          selection.addRange(nativeRng);
		        } else {
		          nativeRng.select();
		        }
		        
		        return this;
		      };

		      /**
		       * Moves the scrollbar to start container(sc) of current range
		       *
		       * @return {WrappedRange}
		       */
		      this.scrollIntoView = function (container) {
		        var height = $(container).height();
		        if (container.scrollTop + height < this.sc.offsetTop) {
		          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);
		        }

		        return this;
		      };

		      /**
		       * @return {WrappedRange}
		       */
		      this.normalize = function () {

		        /**
		         * @param {BoundaryPoint} point
		         * @param {Boolean} isLeftToRight
		         * @return {BoundaryPoint}
		         */
		        var getVisiblePoint = function (point, isLeftToRight) {
		          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||
		              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||
		              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||
		              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {
		            return point;
		          }

		          // point on block's edge
		          var block = dom.ancestor(point.node, dom.isBlock);
		          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||
		              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {

		            // returns point already on visible point
		            if (dom.isVisiblePoint(point)) {
		              return point;
		            }
		            // reverse direction 
		            isLeftToRight = !isLeftToRight;
		          }

		          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :
		                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
		          return nextPoint || point;
		        };

		        var endPoint = getVisiblePoint(this.getEndPoint(), false);
		        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);

		        return new WrappedRange(
		          startPoint.node,
		          startPoint.offset,
		          endPoint.node,
		          endPoint.offset
		        );
		      };

		      /**
		       * returns matched nodes on range
		       *
		       * @param {Function} [pred] - predicate function
		       * @param {Object} [options]
		       * @param {Boolean} [options.includeAncestor]
		       * @param {Boolean} [options.fullyContains]
		       * @return {Node[]}
		       */
		      this.nodes = function (pred, options) {
		        pred = pred || func.ok;

		        var includeAncestor = options && options.includeAncestor;
		        var fullyContains = options && options.fullyContains;

		        // TODO compare points and sort
		        var startPoint = this.getStartPoint();
		        var endPoint = this.getEndPoint();

		        var nodes = [];
		        var leftEdgeNodes = [];

		        dom.walkPoint(startPoint, endPoint, function (point) {
		          if (dom.isEditable(point.node)) {
		            return;
		          }

		          var node;
		          if (fullyContains) {
		            if (dom.isLeftEdgePoint(point)) {
		              leftEdgeNodes.push(point.node);
		            }
		            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {
		              node = point.node;
		            }
		          } else if (includeAncestor) {
		            node = dom.ancestor(point.node, pred);
		          } else {
		            node = point.node;
		          }

		          if (node && pred(node)) {
		            nodes.push(node);
		          }
		        }, true);

		        return list.unique(nodes);
		      };

		      /**
		       * returns commonAncestor of range
		       * @return {Element} - commonAncestor
		       */
		      this.commonAncestor = function () {
		        return dom.commonAncestor(sc, ec);
		      };

		      /**
		       * returns expanded range by pred
		       *
		       * @param {Function} pred - predicate function
		       * @return {WrappedRange}
		       */
		      this.expand = function (pred) {
		        var startAncestor = dom.ancestor(sc, pred);
		        var endAncestor = dom.ancestor(ec, pred);

		        if (!startAncestor && !endAncestor) {
		          return new WrappedRange(sc, so, ec, eo);
		        }

		        var boundaryPoints = this.getPoints();

		        if (startAncestor) {
		          boundaryPoints.sc = startAncestor;
		          boundaryPoints.so = 0;
		        }

		        if (endAncestor) {
		          boundaryPoints.ec = endAncestor;
		          boundaryPoints.eo = dom.nodeLength(endAncestor);
		        }

		        return new WrappedRange(
		          boundaryPoints.sc,
		          boundaryPoints.so,
		          boundaryPoints.ec,
		          boundaryPoints.eo
		        );
		      };

		      /**
		       * @param {Boolean} isCollapseToStart
		       * @return {WrappedRange}
		       */
		      this.collapse = function (isCollapseToStart) {
		        if (isCollapseToStart) {
		          return new WrappedRange(sc, so, sc, so);
		        } else {
		          return new WrappedRange(ec, eo, ec, eo);
		        }
		      };

		      /**
		       * splitText on range
		       */
		      this.splitText = function () {
		        var isSameContainer = sc === ec;
		        var boundaryPoints = this.getPoints();

		        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {
		          ec.splitText(eo);
		        }

		        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {
		          boundaryPoints.sc = sc.splitText(so);
		          boundaryPoints.so = 0;

		          if (isSameContainer) {
		            boundaryPoints.ec = boundaryPoints.sc;
		            boundaryPoints.eo = eo - so;
		          }
		        }

		        return new WrappedRange(
		          boundaryPoints.sc,
		          boundaryPoints.so,
		          boundaryPoints.ec,
		          boundaryPoints.eo
		        );
		      };

		      /**
		       * delete contents on range
		       * @return {WrappedRange}
		       */
		      this.deleteContents = function () {
		        if (this.isCollapsed()) {
		          return this;
		        }

		        var rng = this.splitText();
		        var nodes = rng.nodes(null, {
		          fullyContains: true
		        });

		        // find new cursor point
		        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {
		          return !list.contains(nodes, point.node);
		        });

		        var emptyParents = [];
		        $.each(nodes, function (idx, node) {
		          // find empty parents
		          var parent = node.parentNode;
		          if (point.node !== parent && dom.nodeLength(parent) === 1) {
		            emptyParents.push(parent);
		          }
		          dom.remove(node, false);
		        });

		        // remove empty parents
		        $.each(emptyParents, function (idx, node) {
		          dom.remove(node, false);
		        });

		        return new WrappedRange(
		          point.node,
		          point.offset,
		          point.node,
		          point.offset
		        ).normalize();
		      };
		      
		      /**
		       * makeIsOn: return isOn(pred) function
		       */
		      var makeIsOn = function (pred) {
		        return function () {
		          var ancestor = dom.ancestor(sc, pred);
		          return !!ancestor && (ancestor === dom.ancestor(ec, pred));
		        };
		      };
		  
		      // isOnEditable: judge whether range is on editable or not
		      this.isOnEditable = makeIsOn(dom.isEditable);
		      // isOnList: judge whether range is on list node or not
		      this.isOnList = makeIsOn(dom.isList);
		      // isOnAnchor: judge whether range is on anchor node or not
		      this.isOnAnchor = makeIsOn(dom.isAnchor);
		      // isOnCell: judge whether range is on cell node or not
		      this.isOnCell = makeIsOn(dom.isCell);
		      // isOnData: judge whether range is on data node or not
		      this.isOnData = makeIsOn(dom.isData);

		      /**
		       * @param {Function} pred
		       * @return {Boolean}
		       */
		      this.isLeftEdgeOf = function (pred) {
		        if (!dom.isLeftEdgePoint(this.getStartPoint())) {
		          return false;
		        }

		        var node = dom.ancestor(this.sc, pred);
		        return node && dom.isLeftEdgeOf(this.sc, node);
		      };

		      /**
		       * returns whether range was collapsed or not
		       */
		      this.isCollapsed = function () {
		        return sc === ec && so === eo;
		      };

		      /**
		       * wrap inline nodes which children of body with paragraph
		       *
		       * @return {WrappedRange}
		       */
		      this.wrapBodyInlineWithPara = function () {
		        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {
		          sc.innerHTML = dom.emptyPara;
		          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);
		        }

		        /**
		         * [workaround] firefox often create range on not visible point. so normalize here.
		         *  - firefox: |<p>text</p>|
		         *  - chrome: <p>|text|</p>
		         */
		        var rng = this.normalize();
		        if (dom.isParaInline(sc) || dom.isPara(sc)) {
		          return rng;
		        }

		        // find inline top ancestor
		        var topAncestor;
		        if (dom.isInline(rng.sc)) {
		          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
		          topAncestor = list.last(ancestors);
		          if (!dom.isInline(topAncestor)) {
		            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
		          }
		        } else {
		          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
		        }

		        // siblings not in paragraph
		        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
		        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));

		        // wrap with paragraph
		        if (inlineSiblings.length) {
		          var para = dom.wrap(list.head(inlineSiblings), 'p');
		          dom.appendChildNodes(para, list.tail(inlineSiblings));
		        }

		        return this.normalize();
		      };

		      /**
		       * insert node at current cursor
		       *
		       * @param {Node} node
		       * @return {Node}
		       */
		      this.insertNode = function (node) {
		        var rng = this.wrapBodyInlineWithPara().deleteContents();
		        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));

		        if (info.rightNode) {
		          info.rightNode.parentNode.insertBefore(node, info.rightNode);
		        } else {
		          info.container.appendChild(node);
		        }

		        return node;
		      };

		      /**
		       * insert html at current cursor
		       */
		      this.pasteHTML = function (markup) {
		        var contentsContainer = $('<div></div>').html(markup)[0];
		        var childNodes = list.from(contentsContainer.childNodes);

		        var rng = this.wrapBodyInlineWithPara().deleteContents();

		        return childNodes.reverse().map(function (childNode) {
		          return rng.insertNode(childNode);
		        }).reverse();
		      };
		  
		      /**
		       * returns text in range
		       *
		       * @return {String}
		       */
		      this.toString = function () {
		        var nativeRng = nativeRange();
		        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
		      };

		      /**
		       * returns range for word before cursor
		       *
		       * @param {Boolean} [findAfter] - find after cursor, default: false
		       * @return {WrappedRange}
		       */
		      this.getWordRange = function (findAfter) {
		        var endPoint = this.getEndPoint();

		        if (!dom.isCharPoint(endPoint)) {
		          return this;
		        }

		        var startPoint = dom.prevPointUntil(endPoint, function (point) {
		          return !dom.isCharPoint(point);
		        });

		        if (findAfter) {
		          endPoint = dom.nextPointUntil(endPoint, function (point) {
		            return !dom.isCharPoint(point);
		          });
		        }

		        return new WrappedRange(
		          startPoint.node,
		          startPoint.offset,
		          endPoint.node,
		          endPoint.offset
		        );
		      };
		  
		      /**
		       * create offsetPath bookmark
		       *
		       * @param {Node} editable
		       */
		      this.bookmark = function (editable) {
		        return {
		          s: {
		            path: dom.makeOffsetPath(editable, sc),
		            offset: so
		          },
		          e: {
		            path: dom.makeOffsetPath(editable, ec),
		            offset: eo
		          }
		        };
		      };

		      /**
		       * create offsetPath bookmark base on paragraph
		       *
		       * @param {Node[]} paras
		       */
		      this.paraBookmark = function (paras) {
		        return {
		          s: {
		            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),
		            offset: so
		          },
		          e: {
		            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),
		            offset: eo
		          }
		        };
		      };

		      /**
		       * getClientRects
		       * @return {Rect[]}
		       */
		      this.getClientRects = function () {
		        var nativeRng = nativeRange();
		        return nativeRng.getClientRects();
		      };
		    };

		  /**
		   * @class core.range
		   *
		   * Data structure
		   *  * BoundaryPoint: a point of dom tree
		   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range
		   *
		   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position
		   *
		   * @singleton
		   * @alternateClassName range
		   */
		    return {
		      /**
		       * create Range Object From arguments or Browser Selection
		       *
		       * @param {Node} sc - start container
		       * @param {Number} so - start offset
		       * @param {Node} ec - end container
		       * @param {Number} eo - end offset
		       * @return {WrappedRange}
		       */
		      create: function (sc, so, ec, eo) {
		        if (arguments.length === 4) {
		          return new WrappedRange(sc, so, ec, eo);
		        } else if (arguments.length === 2) { //collapsed
		          ec = sc;
		          eo = so;
		          return new WrappedRange(sc, so, ec, eo);
		        } else {
		          var wrappedRange = this.createFromSelection();
		          if (!wrappedRange && arguments.length === 1) {
		            wrappedRange = this.createFromNode(arguments[0]);
		            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);
		          }
		          return wrappedRange;
		        }
		      },

		      createFromSelection: function () {
		        var sc, so, ec, eo;
		        if (agent.isW3CRangeSupport) {
		          var selection = document.getSelection();
		          if (!selection || selection.rangeCount === 0) {
		            return null;
		          } else if (dom.isBody(selection.anchorNode)) {
		            // Firefox: returns entire body as range on initialization.
		            // We won't never need it.
		            return null;
		          }

		          var nativeRng = selection.getRangeAt(0);
		          sc = nativeRng.startContainer;
		          so = nativeRng.startOffset;
		          ec = nativeRng.endContainer;
		          eo = nativeRng.endOffset;
		        } else { // IE8: TextRange
		          var textRange = document.selection.createRange();
		          var textRangeEnd = textRange.duplicate();
		          textRangeEnd.collapse(false);
		          var textRangeStart = textRange;
		          textRangeStart.collapse(true);

		          var startPoint = textRangeToPoint(textRangeStart, true),
		          endPoint = textRangeToPoint(textRangeEnd, false);

		          // same visible point case: range was collapsed.
		          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&
		              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&
		              endPoint.node.nextSibling === startPoint.node) {
		            startPoint = endPoint;
		          }

		          sc = startPoint.cont;
		          so = startPoint.offset;
		          ec = endPoint.cont;
		          eo = endPoint.offset;
		        }

		        return new WrappedRange(sc, so, ec, eo);
		      },

		      /**
		       * @method 
		       * 
		       * create WrappedRange from node
		       *
		       * @param {Node} node
		       * @return {WrappedRange}
		       */
		      createFromNode: function (node) {
		        var sc = node;
		        var so = 0;
		        var ec = node;
		        var eo = dom.nodeLength(ec);

		        // browsers can't target a picture or void node
		        if (dom.isVoid(sc)) {
		          so = dom.listPrev(sc).length - 1;
		          sc = sc.parentNode;
		        }
		        if (dom.isBR(ec)) {
		          eo = dom.listPrev(ec).length - 1;
		          ec = ec.parentNode;
		        } else if (dom.isVoid(ec)) {
		          eo = dom.listPrev(ec).length;
		          ec = ec.parentNode;
		        }

		        return this.create(sc, so, ec, eo);
		      },

		      /**
		       * create WrappedRange from node after position
		       *
		       * @param {Node} node
		       * @return {WrappedRange}
		       */
		      createFromNodeBefore: function (node) {
		        return this.createFromNode(node).collapse(true);
		      },

		      /**
		       * create WrappedRange from node after position
		       *
		       * @param {Node} node
		       * @return {WrappedRange}
		       */
		      createFromNodeAfter: function (node) {
		        return this.createFromNode(node).collapse();
		      },

		      /**
		       * @method 
		       * 
		       * create WrappedRange from bookmark
		       *
		       * @param {Node} editable
		       * @param {Object} bookmark
		       * @return {WrappedRange}
		       */
		      createFromBookmark: function (editable, bookmark) {
		        var sc = dom.fromOffsetPath(editable, bookmark.s.path);
		        var so = bookmark.s.offset;
		        var ec = dom.fromOffsetPath(editable, bookmark.e.path);
		        var eo = bookmark.e.offset;
		        return new WrappedRange(sc, so, ec, eo);
		      },

		      /**
		       * @method 
		       *
		       * create WrappedRange from paraBookmark
		       *
		       * @param {Object} bookmark
		       * @param {Node[]} paras
		       * @return {WrappedRange}
		       */
		      createFromParaBookmark: function (bookmark, paras) {
		        var so = bookmark.s.offset;
		        var eo = bookmark.e.offset;
		        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);
		        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);

		        return new WrappedRange(sc, so, ec, eo);
		      }
		    };
		  })();

		  /**
		   * @class core.async
		   *
		   * Async functions which returns `Promise`
		   *
		   * @singleton
		   * @alternateClassName async
		   */
		  var async = (function () {
		    /**
		     * @method readFileAsDataURL
		     *
		     * read contents of file as representing URL
		     *
		     * @param {File} file
		     * @return {Promise} - then: dataUrl
		     */
		    var readFileAsDataURL = function (file) {
		      return $.Deferred(function (deferred) {
		        $.extend(new FileReader(), {
		          onload: function (e) {
		            var dataURL = e.target.result;
		            deferred.resolve(dataURL);
		          },
		          onerror: function () {
		            deferred.reject(this);
		          }
		        }).readAsDataURL(file);
		      }).promise();
		    };
		  
		    /**
		     * @method createImage
		     *
		     * create `<image>` from url string
		     *
		     * @param {String} url
		     * @return {Promise} - then: $image
		     */
		    var createImage = function (url) {
		      return $.Deferred(function (deferred) {
		        var $img = $('<img>');

		        $img.one('load', function () {
		          $img.off('error abort');
		          deferred.resolve($img);
		        }).one('error abort', function () {
		          $img.off('load').detach();
		          deferred.reject($img);
		        }).css({
		          display: 'none'
		        }).appendTo(document.body).attr('src', url);
		      }).promise();
		    };

		    return {
		      readFileAsDataURL: readFileAsDataURL,
		      createImage: createImage
		    };
		  })();

		  /**
		   * @class editing.History
		   *
		   * Editor History
		   *
		   */
		  var History = function ($editable) {
		    var stack = [], stackOffset = -1;
		    var editable = $editable[0];

		    var makeSnapshot = function () {
		      var rng = range.create(editable);
		      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};

		      return {
		        contents: $editable.html(),
		        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)
		      };
		    };

		    var applySnapshot = function (snapshot) {
		      if (snapshot.contents !== null) {
		        $editable.html(snapshot.contents);
		      }
		      if (snapshot.bookmark !== null) {
		        range.createFromBookmark(editable, snapshot.bookmark).select();
		      }
		    };

		    /**
		    * @method rewind
		    * Rewinds the history stack back to the first snapshot taken.
		    * Leaves the stack intact, so that "Redo" can still be used.
		    */
		    this.rewind = function () {
		      // Create snap shot if not yet recorded
		      if ($editable.html() !== stack[stackOffset].contents) {
		        this.recordUndo();
		      }

		      // Return to the first available snapshot.
		      stackOffset = 0;

		      // Apply that snapshot.
		      applySnapshot(stack[stackOffset]);
		    };

		    /**
		    * @method reset
		    * Resets the history stack completely; reverting to an empty editor.
		    */
		    this.reset = function () {
		      // Clear the stack.
		      stack = [];

		      // Restore stackOffset to its original value.
		      stackOffset = -1;

		      // Clear the editable area.
		      $editable.html('');

		      // Record our first snapshot (of nothing).
		      this.recordUndo();
		    };

		    /**
		     * undo
		     */
		    this.undo = function () {
		      // Create snap shot if not yet recorded
		      if ($editable.html() !== stack[stackOffset].contents) {
		        this.recordUndo();
		      }

		      if (0 < stackOffset) {
		        stackOffset--;
		        applySnapshot(stack[stackOffset]);
		      }
		    };

		    /**
		     * redo
		     */
		    this.redo = function () {
		      if (stack.length - 1 > stackOffset) {
		        stackOffset++;
		        applySnapshot(stack[stackOffset]);
		      }
		    };

		    /**
		     * recorded undo
		     */
		    this.recordUndo = function () {
		      stackOffset++;

		      // Wash out stack after stackOffset
		      if (stack.length > stackOffset) {
		        stack = stack.slice(0, stackOffset);
		      }

		      // Create new snapshot and push it to the end
		      stack.push(makeSnapshot());
		    };
		  };

		  /**
		   * @class editing.Style
		   *
		   * Style
		   *
		   */
		  var Style = function () {
		    /**
		     * @method jQueryCSS
		     *
		     * [workaround] for old jQuery
		     * passing an array of style properties to .css()
		     * will result in an object of property-value pairs.
		     * (compability with version < 1.9)
		     *
		     * @private
		     * @param  {jQuery} $obj
		     * @param  {Array} propertyNames - An array of one or more CSS properties.
		     * @return {Object}
		     */
		    var jQueryCSS = function ($obj, propertyNames) {
		      if (agent.jqueryVersion < 1.9) {
		        var result = {};
		        $.each(propertyNames, function (idx, propertyName) {
		          result[propertyName] = $obj.css(propertyName);
		        });
		        return result;
		      }
		      return $obj.css.call($obj, propertyNames);
		    };

		    /**
		     * returns style object from node
		     *
		     * @param {jQuery} $node
		     * @return {Object}
		     */
		    this.fromNode = function ($node) {
		      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];
		      var styleInfo = jQueryCSS($node, properties) || {};
		      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);
		      return styleInfo;
		    };

		    /**
		     * paragraph level style
		     *
		     * @param {WrappedRange} rng
		     * @param {Object} styleInfo
		     */
		    this.stylePara = function (rng, styleInfo) {
		      $.each(rng.nodes(dom.isPara, {
		        includeAncestor: true
		      }), function (idx, para) {
		        $(para).css(styleInfo);
		      });
		    };

		    /**
		     * insert and returns styleNodes on range.
		     *
		     * @param {WrappedRange} rng
		     * @param {Object} [options] - options for styleNodes
		     * @param {String} [options.nodeName] - default: `SPAN`
		     * @param {Boolean} [options.expandClosestSibling] - default: `false`
		     * @param {Boolean} [options.onlyPartialContains] - default: `false`
		     * @return {Node[]}
		     */
		    this.styleNodes = function (rng, options) {
		      rng = rng.splitText();

		      var nodeName = options && options.nodeName || 'SPAN';
		      var expandClosestSibling = !!(options && options.expandClosestSibling);
		      var onlyPartialContains = !!(options && options.onlyPartialContains);

		      if (rng.isCollapsed()) {
		        return [rng.insertNode(dom.create(nodeName))];
		      }

		      var pred = dom.makePredByNodeName(nodeName);
		      var nodes = rng.nodes(dom.isText, {
		        fullyContains: true
		      }).map(function (text) {
		        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);
		      });

		      if (expandClosestSibling) {
		        if (onlyPartialContains) {
		          var nodesInRange = rng.nodes();
		          // compose with partial contains predication
		          pred = func.and(pred, function (node) {
		            return list.contains(nodesInRange, node);
		          });
		        }

		        return nodes.map(function (node) {
		          var siblings = dom.withClosestSiblings(node, pred);
		          var head = list.head(siblings);
		          var tails = list.tail(siblings);
		          $.each(tails, function (idx, elem) {
		            dom.appendChildNodes(head, elem.childNodes);
		            dom.remove(elem);
		          });
		          return list.head(siblings);
		        });
		      } else {
		        return nodes;
		      }
		    };

		    /**
		     * get current style on cursor
		     *
		     * @param {WrappedRange} rng
		     * @return {Object} - object contains style properties.
		     */
		    this.current = function (rng) {
		      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);
		      var styleInfo = this.fromNode($cont);

		      // document.queryCommandState for toggle state
		      // [workaround] prevent Firefox nsresult: "0x80004005 (NS_ERROR_FAILURE)"
		      try {
		        styleInfo = $.extend(styleInfo, {
		          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',
		          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',
		          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',
		          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',
		          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',
		          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'
		        });
		      } catch (e) {}

		      // list-style-type to list-style(unordered, ordered)
		      if (!rng.isOnList()) {
		        styleInfo['list-style'] = 'none';
		      } else {
		        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];
		        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;
		        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';
		      }

		      var para = dom.ancestor(rng.sc, dom.isPara);
		      if (para && para.style['line-height']) {
		        styleInfo['line-height'] = para.style.lineHeight;
		      } else {
		        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);
		        styleInfo['line-height'] = lineHeight.toFixed(1);
		      }

		      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
		      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
		      styleInfo.range = rng;

		      return styleInfo;
		    };
		  };


		  /**
		   * @class editing.Bullet
		   *
		   * @alternateClassName Bullet
		   */
		  var Bullet = function () {
		    var self = this;

		    /**
		     * toggle ordered list
		     */
		    this.insertOrderedList = function (editable) {
		      this.toggleList('OL', editable);
		    };

		    /**
		     * toggle unordered list
		     */
		    this.insertUnorderedList = function (editable) {
		      this.toggleList('UL', editable);
		    };

		    /**
		     * indent
		     */
		    this.indent = function (editable) {
		      var self = this;
		      var rng = range.create(editable).wrapBodyInlineWithPara();

		      var paras = rng.nodes(dom.isPara, { includeAncestor: true });
		      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

		      $.each(clustereds, function (idx, paras) {
		        var head = list.head(paras);
		        if (dom.isLi(head)) {
		          self.wrapList(paras, head.parentNode.nodeName);
		        } else {
		          $.each(paras, function (idx, para) {
		            $(para).css('marginLeft', function (idx, val) {
		              return (parseInt(val, 10) || 0) + 25;
		            });
		          });
		        }
		      });

		      rng.select();
		    };

		    /**
		     * outdent
		     */
		    this.outdent = function (editable) {
		      var self = this;
		      var rng = range.create(editable).wrapBodyInlineWithPara();

		      var paras = rng.nodes(dom.isPara, { includeAncestor: true });
		      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

		      $.each(clustereds, function (idx, paras) {
		        var head = list.head(paras);
		        if (dom.isLi(head)) {
		          self.releaseList([paras]);
		        } else {
		          $.each(paras, function (idx, para) {
		            $(para).css('marginLeft', function (idx, val) {
		              val = (parseInt(val, 10) || 0);
		              return val > 25 ? val - 25 : '';
		            });
		          });
		        }
		      });

		      rng.select();
		    };

		    /**
		     * toggle list
		     *
		     * @param {String} listName - OL or UL
		     */
		    this.toggleList = function (listName, editable) {
		      var rng = range.create(editable).wrapBodyInlineWithPara();

		      var paras = rng.nodes(dom.isPara, { includeAncestor: true });
		      var bookmark = rng.paraBookmark(paras);
		      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

		      // paragraph to list
		      if (list.find(paras, dom.isPurePara)) {
		        var wrappedParas = [];
		        $.each(clustereds, function (idx, paras) {
		          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));
		        });
		        paras = wrappedParas;
		      // list to paragraph or change list style
		      } else {
		        var diffLists = rng.nodes(dom.isList, {
		          includeAncestor: true
		        }).filter(function (listNode) {
		          return !$.nodeName(listNode, listName);
		        });

		        if (diffLists.length) {
		          $.each(diffLists, function (idx, listNode) {
		            dom.replace(listNode, listName);
		          });
		        } else {
		          paras = this.releaseList(clustereds, true);
		        }
		      }

		      range.createFromParaBookmark(bookmark, paras).select();
		    };

		    /**
		     * @param {Node[]} paras
		     * @param {String} listName
		     * @return {Node[]}
		     */
		    this.wrapList = function (paras, listName) {
		      var head = list.head(paras);
		      var last = list.last(paras);

		      var prevList = dom.isList(head.previousSibling) && head.previousSibling;
		      var nextList = dom.isList(last.nextSibling) && last.nextSibling;

		      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);

		      // P to LI
		      paras = paras.map(function (para) {
		        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;
		      });

		      // append to list(<ul>, <ol>)
		      dom.appendChildNodes(listNode, paras);

		      if (nextList) {
		        dom.appendChildNodes(listNode, list.from(nextList.childNodes));
		        dom.remove(nextList);
		      }

		      return paras;
		    };

		    /**
		     * @method releaseList
		     *
		     * @param {Array[]} clustereds
		     * @param {Boolean} isEscapseToBody
		     * @return {Node[]}
		     */
		    this.releaseList = function (clustereds, isEscapseToBody) {
		      var releasedParas = [];

		      $.each(clustereds, function (idx, paras) {
		        var head = list.head(paras);
		        var last = list.last(paras);

		        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :
		                                         head.parentNode;
		        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
		          node: last.parentNode,
		          offset: dom.position(last) + 1
		        }, {
		          isSkipPaddingBlankHTML: true
		        }) : null;

		        var middleList = dom.splitTree(headList, {
		          node: head.parentNode,
		          offset: dom.position(head)
		        }, {
		          isSkipPaddingBlankHTML: true
		        });

		        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :
		                                  list.from(middleList.childNodes).filter(dom.isLi);

		        // LI to P
		        if (isEscapseToBody || !dom.isList(headList.parentNode)) {
		          paras = paras.map(function (para) {
		            return dom.replace(para, 'P');
		          });
		        }

		        $.each(list.from(paras).reverse(), function (idx, para) {
		          dom.insertAfter(para, headList);
		        });

		        // remove empty lists
		        var rootLists = list.compact([headList, middleList, lastList]);
		        $.each(rootLists, function (idx, rootList) {
		          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
		          $.each(listNodes.reverse(), function (idx, listNode) {
		            if (!dom.nodeLength(listNode)) {
		              dom.remove(listNode, true);
		            }
		          });
		        });

		        releasedParas = releasedParas.concat(paras);
		      });

		      return releasedParas;
		    };
		  };


		  /**
		   * @class editing.Typing
		   *
		   * Typing
		   *
		   */
		  var Typing = function () {

		    // a Bullet instance to toggle lists off
		    var bullet = new Bullet();

		    /**
		     * insert tab
		     *
		     * @param {WrappedRange} rng
		     * @param {Number} tabsize
		     */
		    this.insertTab = function (rng, tabsize) {
		      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
		      rng = rng.deleteContents();
		      rng.insertNode(tab, true);

		      rng = range.create(tab, tabsize);
		      rng.select();
		    };

		    /**
		     * insert paragraph
		     */
		    this.insertParagraph = function (editable) {
		      var rng = range.create(editable);

		      // deleteContents on range.
		      rng = rng.deleteContents();

		      // Wrap range if it needs to be wrapped by paragraph
		      rng = rng.wrapBodyInlineWithPara();

		      // finding paragraph
		      var splitRoot = dom.ancestor(rng.sc, dom.isPara);

		      var nextPara;
		      // on paragraph: split paragraph
		      if (splitRoot) {
		        // if it is an empty line with li
		        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {
		          // toogle UL/OL and escape
		          bullet.toggleList(splitRoot.parentNode.nodeName);
		          return;
		        // if it is an empty line with para on blockquote
		        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {
		          // escape blockquote
		          dom.insertAfter(splitRoot, splitRoot.parentNode);
		          nextPara = splitRoot;
		        // if new line has content (not a line break)
		        } else {
		          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());

		          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
		          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));

		          $.each(emptyAnchors, function (idx, anchor) {
		            dom.remove(anchor);
		          });

		          // replace empty heading or pre with P tag
		          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {
		            nextPara = dom.replace(nextPara, 'p');
		          }
		        }
		      // no paragraph: insert empty paragraph
		      } else {
		        var next = rng.sc.childNodes[rng.so];
		        nextPara = $(dom.emptyPara)[0];
		        if (next) {
		          rng.sc.insertBefore(nextPara, next);
		        } else {
		          rng.sc.appendChild(nextPara);
		        }
		      }

		      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);
		    };
		  };

		  /**
		   * @class editing.Table
		   *
		   * Table
		   *
		   */
		  var Table = function () {
		    /**
		     * handle tab key
		     *
		     * @param {WrappedRange} rng
		     * @param {Boolean} isShift
		     */
		    this.tab = function (rng, isShift) {
		      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
		      var table = dom.ancestor(cell, dom.isTable);
		      var cells = dom.listDescendant(table, dom.isCell);

		      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);
		      if (nextCell) {
		        range.create(nextCell, 0).select();
		      }
		    };

		    /**
		     * create empty table element
		     *
		     * @param {Number} rowCount
		     * @param {Number} colCount
		     * @return {Node}
		     */
		    this.createTable = function (colCount, rowCount, options) {
		      var tds = [], tdHTML;
		      for (var idxCol = 0; idxCol < colCount; idxCol++) {
		        tds.push('<td>' + dom.blank + '</td>');
		      }
		      tdHTML = tds.join('');

		      var trs = [], trHTML;
		      for (var idxRow = 0; idxRow < rowCount; idxRow++) {
		        trs.push('<tr>' + tdHTML + '</tr>');
		      }
		      trHTML = trs.join('');
		      var $table = $('<table>' + trHTML + '</table>');
		      if (options && options.tableClassName) {
		        $table.addClass(options.tableClassName);
		      }

		      return $table[0];
		    };
		  };


		  var KEY_BOGUS = 'bogus';

		  /**
		   * @class Editor
		   */
		  var Editor = function (context) {
		    var self = this;

		    var $note = context.layoutInfo.note;
		    var $editor = context.layoutInfo.editor;
		    var $editable = context.layoutInfo.editable;
		    var options = context.options;
		    var lang = options.langInfo;

		    var editable = $editable[0];
		    var lastRange = null;

		    var style = new Style();
		    var table = new Table();
		    var typing = new Typing();
		    var bullet = new Bullet();
		    var history = new History($editable);

		    this.initialize = function () {
		      // bind custom events
		      $editable.on('keydown', function (event) {
		        if (event.keyCode === key.code.ENTER) {
		          context.triggerEvent('enter', event);
		        }
		        context.triggerEvent('keydown', event);

		        if (!event.isDefaultPrevented()) {
		          if (options.shortcuts) {
		            self.handleKeyMap(event);
		          } else {
		            self.preventDefaultEditableShortCuts(event);
		          }
		        }
		      }).on('keyup', function (event) {
		        context.triggerEvent('keyup', event);
		      }).on('focus', function (event) {
		        context.triggerEvent('focus', event);
		      }).on('blur', function (event) {
		        context.triggerEvent('blur', event);
		      }).on('mousedown', function (event) {
		        context.triggerEvent('mousedown', event);
		      }).on('mouseup', function (event) {
		        context.triggerEvent('mouseup', event);
		      }).on('scroll', function (event) {
		        context.triggerEvent('scroll', event);
		      }).on('paste', function (event) {
		        context.triggerEvent('paste', event);
		      });

		      // init content before set event
		      $editable.html(dom.html($note) || dom.emptyPara);

		      // [workaround] IE doesn't have input events for contentEditable
		      // - see: https://goo.gl/4bfIvA
		      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';
		      $editable.on(changeEventName, func.debounce(function () {
		        context.triggerEvent('change', $editable.html());
		      }, 250));

		      $editor.on('focusin', function (event) {
		        context.triggerEvent('focusin', event);
		      }).on('focusout', function (event) {
		        context.triggerEvent('focusout', event);
		      });

		      if (!options.airMode) {
		        if (options.width) {
		          $editor.outerWidth(options.width);
		        }
		        if (options.height) {
		          $editable.outerHeight(options.height);
		        }
		        if (options.maxHeight) {
		          $editable.css('max-height', options.maxHeight);
		        }
		        if (options.minHeight) {
		          $editable.css('min-height', options.minHeight);
		        }
		      }

		      history.recordUndo();
		    };

		    this.destroy = function () {
		      $editable.off();
		    };

		    this.handleKeyMap = function (event) {
		      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];
		      var keys = [];

		      if (event.metaKey) { keys.push('CMD'); }
		      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }
		      if (event.shiftKey) { keys.push('SHIFT'); }

		      var keyName = key.nameFromCode[event.keyCode];
		      if (keyName) {
		        keys.push(keyName);
		      }

		      var eventName = keyMap[keys.join('+')];
		      if (eventName) {
		        event.preventDefault();
		        context.invoke(eventName);
		      } else if (key.isEdit(event.keyCode)) {
		        this.afterCommand();
		      }
		    };

		    this.preventDefaultEditableShortCuts = function (event) {
		      // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)
		      if ((event.ctrlKey || event.metaKey) &&
		        list.contains([66, 73, 85], event.keyCode)) {
		        event.preventDefault();
		      }
		    };

		    /**
		     * create range
		     * @return {WrappedRange}
		     */
		    this.createRange = function () {
		      this.focus();
		      return range.create(editable);
		    };

		    /**
		     * saveRange
		     *
		     * save current range
		     *
		     * @param {Boolean} [thenCollapse=false]
		     */
		    this.saveRange = function (thenCollapse) {
		      lastRange = this.createRange();
		      if (thenCollapse) {
		        lastRange.collapse().select();
		      }
		    };

		    /**
		     * restoreRange
		     *
		     * restore lately range
		     */
		    this.restoreRange = function () {
		      if (lastRange) {
		        lastRange.select();
		        this.focus();
		      }
		    };

		    this.saveTarget = function (node) {
		      $editable.data('target', node);
		    };

		    this.clearTarget = function () {
		      $editable.removeData('target');
		    };

		    this.restoreTarget = function () {
		      return $editable.data('target');
		    };

		    /**
		     * currentStyle
		     *
		     * current style
		     * @return {Object|Boolean} unfocus
		     */
		    this.currentStyle = function () {
		      var rng = range.create();
		      if (rng) {
		        rng = rng.normalize();
		      }
		      return rng ? style.current(rng) : style.fromNode($editable);
		    };

		    /**
		     * style from node
		     *
		     * @param {jQuery} $node
		     * @return {Object}
		     */
		    this.styleFromNode = function ($node) {
		      return style.fromNode($node);
		    };

		    /**
		     * undo
		     */
		    this.undo = function () {
		      context.triggerEvent('before.command', $editable.html());
		      history.undo();
		      context.triggerEvent('change', $editable.html());
		    };
		    context.memo('help.undo', lang.help.undo);

		    /**
		     * redo
		     */
		    this.redo = function () {
		      context.triggerEvent('before.command', $editable.html());
		      history.redo();
		      context.triggerEvent('change', $editable.html());
		    };
		    context.memo('help.redo', lang.help.redo);

		    /**
		     * before command
		     */
		    var beforeCommand = this.beforeCommand = function () {
		      context.triggerEvent('before.command', $editable.html());
		      // keep focus on editable before command execution
		      self.focus();
		    };

		    /**
		     * after command
		     * @param {Boolean} isPreventTrigger
		     */
		    var afterCommand = this.afterCommand = function (isPreventTrigger) {
		      history.recordUndo();
		      if (!isPreventTrigger) {
		        context.triggerEvent('change', $editable.html());
		      }
		    };

		    /* jshint ignore:start */
		    // native commands(with execCommand), generate function for execCommand
		    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',
		                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',
		                    'formatBlock', 'removeFormat',
		                    'backColor', 'foreColor', 'fontName'];

		    for (var idx = 0, len = commands.length; idx < len; idx ++) {
		      this[commands[idx]] = (function (sCmd) {
		        return function (value) {
		          beforeCommand();
		          document.execCommand(sCmd, false, value);
		          afterCommand(true);
		        };
		      })(commands[idx]);
		      context.memo('help.' + commands[idx], lang.help[commands[idx]]);
		    }
		    /* jshint ignore:end */

		    /**
		     * handle tab key
		     */
		    this.tab = function () {
		      var rng = this.createRange();
		      if (rng.isCollapsed() && rng.isOnCell()) {
		        table.tab(rng);
		      } else {
		        beforeCommand();
		        typing.insertTab(rng, options.tabSize);
		        afterCommand();
		      }
		    };
		    context.memo('help.tab', lang.help.tab);

		    /**
		     * handle shift+tab key
		     */
		    this.untab = function () {
		      var rng = this.createRange();
		      if (rng.isCollapsed() && rng.isOnCell()) {
		        table.tab(rng, true);
		      }
		    };
		    context.memo('help.untab', lang.help.untab);

		    /**
		     * run given function between beforeCommand and afterCommand
		     */
		    this.wrapCommand = function (fn) {
		      return function () {
		        beforeCommand();
		        fn.apply(self, arguments);
		        afterCommand();
		      };
		    };

		    /**
		     * insert paragraph
		     */
		    this.insertParagraph = this.wrapCommand(function () {
		      typing.insertParagraph(editable);
		    });
		    context.memo('help.insertParagraph', lang.help.insertParagraph);

		    this.insertOrderedList = this.wrapCommand(function () {
		      bullet.insertOrderedList(editable);
		    });
		    context.memo('help.insertOrderedList', lang.help.insertOrderedList);

		    this.insertUnorderedList = this.wrapCommand(function () {
		      bullet.insertUnorderedList(editable);
		    });
		    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);

		    this.indent = this.wrapCommand(function () {
		      bullet.indent(editable);
		    });
		    context.memo('help.indent', lang.help.indent);

		    this.outdent = this.wrapCommand(function () {
		      bullet.outdent(editable);
		    });
		    context.memo('help.outdent', lang.help.outdent);

		    /**
		     * insert image
		     *
		     * @param {String} src
		     * @param {String|Function} param
		     * @return {Promise}
		     */
		    this.insertImage = function (src, param) {
		      return async.createImage(src, param).then(function ($image) {
		        beforeCommand();

		        if (typeof param === 'function') {
		          param($image);
		        } else {
		          if (typeof param === 'string') {
		            $image.attr('data-filename', param);
		          }
		          $image.css('width', Math.min($editable.width(), $image.width()));
		        }

		        $image.show();
		        range.create(editable).insertNode($image[0]);
		        range.createFromNodeAfter($image[0]).select();
		        afterCommand();
		      }).fail(function (e) {
		        context.triggerEvent('image.upload.error', e);
		      });
		    };

		    /**
		     * insertImages
		     * @param {File[]} files
		     */
		    this.insertImages = function (files) {
		      $.each(files, function (idx, file) {
		        var filename = file.name;
		        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {
		          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);
		        } else {
		          async.readFileAsDataURL(file).then(function (dataURL) {
		            return self.insertImage(dataURL, filename);
		          }).fail(function () {
		            context.triggerEvent('image.upload.error');
		          });
		        }
		      });
		    };

		    /**
		     * insertImagesOrCallback
		     * @param {File[]} files
		     */
		    this.insertImagesOrCallback = function (files) {
		      var callbacks = options.callbacks;

		      // If onImageUpload options setted
		      if (callbacks.onImageUpload) {
		        context.triggerEvent('image.upload', files);
		      // else insert Image as dataURL
		      } else {
		        this.insertImages(files);
		      }
		    };

		    /**
		     * insertNode
		     * insert node
		     * @param {Node} node
		     */
		    this.insertNode = this.wrapCommand(function (node) {
		      var rng = this.createRange();
		      rng.insertNode(node);
		      range.createFromNodeAfter(node).select();
		    });

		    /**
		     * insert text
		     * @param {String} text
		     */
		    this.insertText = this.wrapCommand(function (text) {
		      var rng = this.createRange();
		      var textNode = rng.insertNode(dom.createText(text));
		      range.create(textNode, dom.nodeLength(textNode)).select();
		    });

		    /**
		     * return selected plain text
		     * @return {String} text
		     */
		    this.getSelectedText = function () {
		      var rng = this.createRange();

		      // if range on anchor, expand range with anchor
		      if (rng.isOnAnchor()) {
		        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));
		      }

		      return rng.toString();
		    };

		    /**
		     * paste HTML
		     * @param {String} markup
		     */
		    this.pasteHTML = this.wrapCommand(function (markup) {
		      var contents = this.createRange().pasteHTML(markup);
		      range.createFromNodeAfter(list.last(contents)).select();
		    });

		    /**
		     * formatBlock
		     *
		     * @param {String} tagName
		     */
		    this.formatBlock = this.wrapCommand(function (tagName) {
		      // [workaround] for MSIE, IE need `<`
		      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;
		      document.execCommand('FormatBlock', false, tagName);
		    });

		    this.formatPara = function () {
		      this.formatBlock('P');
		    };
		    context.memo('help.formatPara', lang.help.formatPara);

		    /* jshint ignore:start */
		    for (var idx = 1; idx <= 6; idx ++) {
		      this['formatH' + idx] = function (idx) {
		        return function () {
		          this.formatBlock('H' + idx);
		        };
		      }(idx);
		      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);
		    };
		    /* jshint ignore:end */

		    /**
		     * fontSize
		     *
		     * @param {String} value - px
		     */
		    this.fontSize = function (value) {
		      var rng = this.createRange();

		      if (rng && rng.isCollapsed()) {
		        var spans = style.styleNodes(rng);
		        var firstSpan = list.head(spans);

		        $(spans).css({
		          'font-size': value + 'px'
		        });

		        // [workaround] added styled bogus span for style
		        //  - also bogus character needed for cursor position
		        if (firstSpan && !dom.nodeLength(firstSpan)) {
		          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
		          range.createFromNodeAfter(firstSpan.firstChild).select();
		          $editable.data(KEY_BOGUS, firstSpan);
		        }
		      } else {
		        beforeCommand();
		        $(style.styleNodes(rng)).css({
		          'font-size': value + 'px'
		        });
		        afterCommand();
		      }
		    };

		    /**
		     * insert horizontal rule
		     */
		    this.insertHorizontalRule = this.wrapCommand(function () {
		      var hrNode = this.createRange().insertNode(dom.create('HR'));
		      if (hrNode.nextSibling) {
		        range.create(hrNode.nextSibling, 0).normalize().select();
		      }
		    });
		    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);

		    /**
		     * remove bogus node and character
		     */
		    this.removeBogus = function () {
		      var bogusNode = $editable.data(KEY_BOGUS);
		      if (!bogusNode) {
		        return;
		      }

		      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);

		      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);
		      if (bogusCharIdx !== -1) {
		        textNode.deleteData(bogusCharIdx, 1);
		      }

		      if (dom.isEmpty(bogusNode)) {
		        dom.remove(bogusNode);
		      }

		      $editable.removeData(KEY_BOGUS);
		    };

		    /**
		     * lineHeight
		     * @param {String} value
		     */
		    this.lineHeight = this.wrapCommand(function (value) {
		      style.stylePara(this.createRange(), {
		        lineHeight: value
		      });
		    });

		    /**
		     * unlink
		     *
		     * @type command
		     */
		    this.unlink = function () {
		      var rng = this.createRange();
		      if (rng.isOnAnchor()) {
		        var anchor = dom.ancestor(rng.sc, dom.isAnchor);
		        rng = range.createFromNode(anchor);
		        rng.select();

		        beforeCommand();
		        document.execCommand('unlink');
		        afterCommand();
		      }
		    };

		    /**
		     * create link (command)
		     *
		     * @param {Object} linkInfo
		     */
		    this.createLink = this.wrapCommand(function (linkInfo) {
		      var linkUrl = linkInfo.url;
		      var linkText = linkInfo.text;
		      var isNewWindow = linkInfo.isNewWindow;
		      var rng = linkInfo.range || this.createRange();
		      var isTextChanged = rng.toString() !== linkText;

		      // handle spaced urls from input
		      if (typeof linkUrl === 'string') {
		        linkUrl = linkUrl.trim();
		      }

		      if (options.onCreateLink) {
		        linkUrl = options.onCreateLink(linkUrl);
		      }

		      var anchors = [];
		      if (isTextChanged) {
		        rng = rng.deleteContents();
		        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);
		        anchors.push(anchor);
		      } else {
		        anchors = style.styleNodes(rng, {
		          nodeName: 'A',
		          expandClosestSibling: true,
		          onlyPartialContains: true
		        });
		      }

		      $.each(anchors, function (idx, anchor) {
		        // if url doesn't match an URL schema, set http:// as default
		        linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?/.test(linkUrl) ?
		          linkUrl : 'http://' + linkUrl;

		        $(anchor).attr('href', linkUrl);
		        if (isNewWindow) {
		          $(anchor).attr('target', '_blank');
		        } else {
		          $(anchor).removeAttr('target');
		        }
		      });

		      var startRange = range.createFromNodeBefore(list.head(anchors));
		      var startPoint = startRange.getStartPoint();
		      var endRange = range.createFromNodeAfter(list.last(anchors));
		      var endPoint = endRange.getEndPoint();

		      range.create(
		        startPoint.node,
		        startPoint.offset,
		        endPoint.node,
		        endPoint.offset
		      ).select();
		    });

		    /**
		     * returns link info
		     *
		     * @return {Object}
		     * @return {WrappedRange} return.range
		     * @return {String} return.text
		     * @return {Boolean} [return.isNewWindow=true]
		     * @return {String} [return.url=""]
		     */
		    this.getLinkInfo = function () {
		      var rng = this.createRange().expand(dom.isAnchor);

		      // Get the first anchor on range(for edit).
		      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));

		      return {
		        range: rng,
		        text: rng.toString(),
		        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,
		        url: $anchor.length ? $anchor.attr('href') : ''
		      };
		    };

		    /**
		     * setting color
		     *
		     * @param {Object} sObjColor  color code
		     * @param {String} sObjColor.foreColor foreground color
		     * @param {String} sObjColor.backColor background color
		     */
		    this.color = this.wrapCommand(function (colorInfo) {
		      var foreColor = colorInfo.foreColor;
		      var backColor = colorInfo.backColor;

		      if (foreColor) { document.execCommand('foreColor', false, foreColor); }
		      if (backColor) { document.execCommand('backColor', false, backColor); }
		    });

		    /**
		     * insert Table
		     *
		     * @param {String} dimension of table (ex : "5x5")
		     */
		    this.insertTable = this.wrapCommand(function (dim) {
		      var dimension = dim.split('x');

		      var rng = this.createRange().deleteContents();
		      rng.insertNode(table.createTable(dimension[0], dimension[1], options));
		    });

		    /**
		     * float me
		     *
		     * @param {String} value
		     */
		    this.floatMe = this.wrapCommand(function (value) {
		      var $target = $(this.restoreTarget());
		      $target.css('float', value);
		    });

		    /**
		     * resize overlay element
		     * @param {String} value
		     */
		    this.resize = this.wrapCommand(function (value) {
		      var $target = $(this.restoreTarget());
		      $target.css({
		        width: value * 100 + '%',
		        height: ''
		      });
		    });

		    /**
		     * @param {Position} pos
		     * @param {jQuery} $target - target element
		     * @param {Boolean} [bKeepRatio] - keep ratio
		     */
		    this.resizeTo = function (pos, $target, bKeepRatio) {
		      var imageSize;
		      if (bKeepRatio) {
		        var newRatio = pos.y / pos.x;
		        var ratio = $target.data('ratio');
		        imageSize = {
		          width: ratio > newRatio ? pos.x : pos.y / ratio,
		          height: ratio > newRatio ? pos.x * ratio : pos.y
		        };
		      } else {
		        imageSize = {
		          width: pos.x,
		          height: pos.y
		        };
		      }

		      $target.css(imageSize);
		    };

		    /**
		     * remove media object
		     */
		    this.removeMedia = this.wrapCommand(function () {
		      var $target = $(this.restoreTarget()).detach();
		      context.triggerEvent('media.delete', $target, $editable);
		    });

		    /**
		     * returns whether editable area has focus or not.
		     */
		    this.hasFocus = function () {
		      return $editable.is(':focus');
		    };

		    /**
		     * set focus
		     */
		    this.focus = function () {
		      // [workaround] Screen will move when page is scolled in IE.
		      //  - do focus when not focused
		      if (!this.hasFocus()) {
		        $editable.focus();
		      }
		    };

		    /**
		     * returns whether contents is empty or not.
		     * @return {Boolean}
		     */
		    this.isEmpty = function () {
		      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();
		    };

		    /**
		     * Removes all contents and restores the editable instance to an _emptyPara_.
		     */
		    this.empty = function () {
		      context.invoke('code', dom.emptyPara);
		    };
		  };

		  var Clipboard = function (context) {
		    var self = this;

		    var $editable = context.layoutInfo.editable;

		    this.events = {
		      'summernote.keydown': function (we, e) {
		        if (self.needKeydownHook()) {
		          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {
		            context.invoke('editor.saveRange');
		            self.$paste.focus();

		            setTimeout(function () {
		              self.pasteByHook();
		            }, 0);
		          }
		        }
		      }
		    };

		    this.needKeydownHook = function () {
		      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;
		    };

		    this.initialize = function () {
		      // [workaround] getting image from clipboard
		      //  - IE11 and Firefox: CTRL+v hook
		      //  - Webkit: event.clipboardData
		      if (this.needKeydownHook()) {
		        this.$paste = $('<div tabindex="-1" />').attr('contenteditable', true).css({
		          position: 'absolute',
		          left: -100000,
		          opacity: 0
		        });
		        $editable.before(this.$paste);

		        this.$paste.on('paste', function (event) {
		          context.triggerEvent('paste', event);
		        });
		      } else {
		        $editable.on('paste', this.pasteByEvent);
		      }
		    };

		    this.destroy = function () {
		      if (this.needKeydownHook()) {
		        this.$paste.remove();
		        this.$paste = null;
		      }
		    };

		    this.pasteByHook = function () {
		      var node = this.$paste[0].firstChild;

		      if (dom.isImg(node)) {
		        var dataURI = node.src;
		        var decodedData = atob(dataURI.split(',')[1]);
		        var array = new Uint8Array(decodedData.length);
		        for (var i = 0; i < decodedData.length; i++) {
		          array[i] = decodedData.charCodeAt(i);
		        }

		        var blob = new Blob([array], { type: 'image/png' });
		        blob.name = 'clipboard.png';

		        context.invoke('editor.restoreRange');
		        context.invoke('editor.focus');
		        context.invoke('editor.insertImagesOrCallback', [blob]);
		      } else {
		        var pasteContent = $('<div />').html(this.$paste.html()).html();
		        context.invoke('editor.restoreRange');
		        context.invoke('editor.focus');

		        if (pasteContent) {
		          context.invoke('editor.pasteHTML', pasteContent);
		        }
		      }

		      this.$paste.empty();
		    };

		    /**
		     * paste by clipboard event
		     *
		     * @param {Event} event
		     */
		    this.pasteByEvent = function (event) {
		      var clipboardData = event.originalEvent.clipboardData;
		      if (clipboardData && clipboardData.items && clipboardData.items.length) {
		        var item = list.head(clipboardData.items);
		        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {
		          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);
		        }
		        context.invoke('editor.afterCommand');
		      }
		    };
		  };

		  var Dropzone = function (context) {
		    var $document = $(document);
		    var $editor = context.layoutInfo.editor;
		    var $editable = context.layoutInfo.editable;
		    var options = context.options;
		    var lang = options.langInfo;
		    var documentEventHandlers = {};

		    var $dropzone = $([
		      '<div class="note-dropzone">',
		      '  <div class="note-dropzone-message"/>',
		      '</div>'
		    ].join('')).prependTo($editor);

		    var detachDocumentEvent = function () {
		      Object.keys(documentEventHandlers).forEach(function (key) {
		        $document.off(key.substr(2).toLowerCase(), documentEventHandlers[key]);
		      });
		      documentEventHandlers = {};
		    };

		    /**
		     * attach Drag and Drop Events
		     */
		    this.initialize = function () {
		      if (options.disableDragAndDrop) {
		        // prevent default drop event
		        documentEventHandlers.onDrop = function (e) {
		          e.preventDefault();
		        };
		        $document.on('drop', documentEventHandlers.onDrop);
		      } else {
		        this.attachDragAndDropEvent();
		      }
		    };

		    /**
		     * attach Drag and Drop Events
		     */
		    this.attachDragAndDropEvent = function () {
		      var collection = $(),
		          $dropzoneMessage = $dropzone.find('.note-dropzone-message');

		      documentEventHandlers.onDragenter = function (e) {
		        var isCodeview = context.invoke('codeview.isActivated');
		        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;
		        if (!isCodeview && !collection.length && hasEditorSize) {
		          $editor.addClass('dragover');
		          $dropzone.width($editor.width());
		          $dropzone.height($editor.height());
		          $dropzoneMessage.text(lang.image.dragImageHere);
		        }
		        collection = collection.add(e.target);
		      };

		      documentEventHandlers.onDragleave = function (e) {
		        collection = collection.not(e.target);
		        if (!collection.length) {
		          $editor.removeClass('dragover');
		        }
		      };

		      documentEventHandlers.onDrop = function () {
		        collection = $();
		        $editor.removeClass('dragover');
		      };

		      // show dropzone on dragenter when dragging a object to document
		      // -but only if the editor is visible, i.e. has a positive width and height
		      $document.on('dragenter', documentEventHandlers.onDragenter)
		        .on('dragleave', documentEventHandlers.onDragleave)
		        .on('drop', documentEventHandlers.onDrop);

		      // change dropzone's message on hover.
		      $dropzone.on('dragenter', function () {
		        $dropzone.addClass('hover');
		        $dropzoneMessage.text(lang.image.dropImage);
		      }).on('dragleave', function () {
		        $dropzone.removeClass('hover');
		        $dropzoneMessage.text(lang.image.dragImageHere);
		      });

		      // attach dropImage
		      $dropzone.on('drop', function (event) {
		        var dataTransfer = event.originalEvent.dataTransfer;

		        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
		          event.preventDefault();
		          $editable.focus();
		          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);
		        } else {
		          $.each(dataTransfer.types, function (idx, type) {
		            var content = dataTransfer.getData(type);

		            if (type.toLowerCase().indexOf('text') > -1) {
		              context.invoke('editor.pasteHTML', content);
		            } else {
		              $(content).each(function () {
		                context.invoke('editor.insertNode', this);
		              });
		            }
		          });
		        }
		      }).on('dragover', false); // prevent default dragover event
		    };

		    this.destroy = function () {
		      detachDocumentEvent();
		    };
		  };


		  var CodeMirror;
		  if (agent.hasCodeMirror) {
		    if (agent.isSupportAmd) {
		      !/* require */(/* empty */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(4)]; (function (cm) {
		        CodeMirror = cm;
		      }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}());
		    } else {
		      CodeMirror = window.CodeMirror;
		    }
		  }

		  /**
		   * @class Codeview
		   */
		  var Codeview = function (context) {
		    var $editor = context.layoutInfo.editor;
		    var $editable = context.layoutInfo.editable;
		    var $codable = context.layoutInfo.codable;
		    var options = context.options;

		    this.sync = function () {
		      var isCodeview = this.isActivated();
		      if (isCodeview && agent.hasCodeMirror) {
		        $codable.data('cmEditor').save();
		      }
		    };

		    /**
		     * @return {Boolean}
		     */
		    this.isActivated = function () {
		      return $editor.hasClass('codeview');
		    };

		    /**
		     * toggle codeview
		     */
		    this.toggle = function () {
		      if (this.isActivated()) {
		        this.deactivate();
		      } else {
		        this.activate();
		      }
		      context.triggerEvent('codeview.toggled');
		    };

		    /**
		     * activate code view
		     */
		    this.activate = function () {
		      $codable.val(dom.html($editable, options.prettifyHtml));
		      $codable.height($editable.height());

		      context.invoke('toolbar.updateCodeview', true);
		      $editor.addClass('codeview');
		      $codable.focus();

		      // activate CodeMirror as codable
		      if (agent.hasCodeMirror) {
		        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);

		        // CodeMirror TernServer
		        if (options.codemirror.tern) {
		          var server = new CodeMirror.TernServer(options.codemirror.tern);
		          cmEditor.ternServer = server;
		          cmEditor.on('cursorActivity', function (cm) {
		            server.updateArgHints(cm);
		          });
		        }

		        // CodeMirror hasn't Padding.
		        cmEditor.setSize(null, $editable.outerHeight());
		        $codable.data('cmEditor', cmEditor);
		      }
		    };

		    /**
		     * deactivate code view
		     */
		    this.deactivate = function () {
		      // deactivate CodeMirror as codable
		      if (agent.hasCodeMirror) {
		        var cmEditor = $codable.data('cmEditor');
		        $codable.val(cmEditor.getValue());
		        cmEditor.toTextArea();
		      }

		      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;
		      var isChange = $editable.html() !== value;

		      $editable.html(value);
		      $editable.height(options.height ? $codable.height() : 'auto');
		      $editor.removeClass('codeview');

		      if (isChange) {
		        context.triggerEvent('change', $editable.html(), $editable);
		      }

		      $editable.focus();

		      context.invoke('toolbar.updateCodeview', false);
		    };

		    this.destroy = function () {
		      if (this.isActivated()) {
		        this.deactivate();
		      }
		    };
		  };

		  var EDITABLE_PADDING = 24;

		  var Statusbar = function (context) {
		    var $document = $(document);
		    var $statusbar = context.layoutInfo.statusbar;
		    var $editable = context.layoutInfo.editable;
		    var options = context.options;

		    this.initialize = function () {
		      if (options.airMode || options.disableResizeEditor) {
		        return;
		      }

		      $statusbar.on('mousedown', function (event) {
		        event.preventDefault();
		        event.stopPropagation();

		        var editableTop = $editable.offset().top - $document.scrollTop();

		        $document.on('mousemove', function (event) {
		          var height = event.clientY - (editableTop + EDITABLE_PADDING);

		          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;
		          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;

		          $editable.height(height);
		        }).one('mouseup', function () {
		          $document.off('mousemove');
		        });
		      });
		    };

		    this.destroy = function () {
		      $statusbar.off();
		      $statusbar.remove();
		    };
		  };

		  var Fullscreen = function (context) {
		    var $editor = context.layoutInfo.editor;
		    var $toolbar = context.layoutInfo.toolbar;
		    var $editable = context.layoutInfo.editable;
		    var $codable = context.layoutInfo.codable;

		    var $window = $(window);
		    var $scrollbar = $('html, body');

		    /**
		     * toggle fullscreen
		     */
		    this.toggle = function () {
		      var resize = function (size) {
		        $editable.css('height', size.h);
		        $codable.css('height', size.h);
		        if ($codable.data('cmeditor')) {
		          $codable.data('cmeditor').setsize(null, size.h);
		        }
		      };

		      $editor.toggleClass('fullscreen');
		      if (this.isFullscreen()) {
		        $editable.data('orgHeight', $editable.css('height'));

		        $window.on('resize', function () {
		          resize({
		            h: $window.height() - $toolbar.outerHeight()
		          });
		        }).trigger('resize');

		        $scrollbar.css('overflow', 'hidden');
		      } else {
		        $window.off('resize');
		        resize({
		          h: $editable.data('orgHeight')
		        });
		        $scrollbar.css('overflow', 'visible');
		      }

		      context.invoke('toolbar.updateFullscreen', this.isFullscreen());
		    };

		    this.isFullscreen = function () {
		      return $editor.hasClass('fullscreen');
		    };
		  };

		  var Handle = function (context) {
		    var self = this;

		    var $document = $(document);
		    var $editingArea = context.layoutInfo.editingArea;
		    var options = context.options;

		    this.events = {
		      'summernote.mousedown': function (we, e) {
		        if (self.update(e.target)) {
		          e.preventDefault();
		        }
		      },
		      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {
		        self.update();
		      }
		    };

		    this.initialize = function () {
		      this.$handle = $([
		        '<div class="note-handle">',
		        '<div class="note-control-selection">',
		        '<div class="note-control-selection-bg"></div>',
		        '<div class="note-control-holder note-control-nw"></div>',
		        '<div class="note-control-holder note-control-ne"></div>',
		        '<div class="note-control-holder note-control-sw"></div>',
		        '<div class="',
		        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),
		        ' note-control-se"></div>',
		        (options.disableResizeImage ? '' : '<div class="note-control-selection-info"></div>'),
		        '</div>',
		        '</div>'
		      ].join('')).prependTo($editingArea);

		      this.$handle.on('mousedown', function (event) {
		        if (dom.isControlSizing(event.target)) {
		          event.preventDefault();
		          event.stopPropagation();

		          var $target = self.$handle.find('.note-control-selection').data('target'),
		              posStart = $target.offset(),
		              scrollTop = $document.scrollTop();

		          $document.on('mousemove', function (event) {
		            context.invoke('editor.resizeTo', {
		              x: event.clientX - posStart.left,
		              y: event.clientY - (posStart.top - scrollTop)
		            }, $target, !event.shiftKey);

		            self.update($target[0]);
		          }).one('mouseup', function (e) {
		            e.preventDefault();
		            $document.off('mousemove');
		            context.invoke('editor.afterCommand');
		          });

		          if (!$target.data('ratio')) { // original ratio.
		            $target.data('ratio', $target.height() / $target.width());
		          }
		        }
		      });
		    };

		    this.destroy = function () {
		      this.$handle.remove();
		    };

		    this.update = function (target) {
		      var isImage = dom.isImg(target);
		      var $selection = this.$handle.find('.note-control-selection');

		      context.invoke('imagePopover.update', target);

		      if (isImage) {
		        var $image = $(target);
		        var pos = $image.position();

		        // include margin
		        var imageSize = {
		          w: $image.outerWidth(true),
		          h: $image.outerHeight(true)
		        };

		        $selection.css({
		          display: 'block',
		          left: pos.left,
		          top: pos.top,
		          width: imageSize.w,
		          height: imageSize.h
		        }).data('target', $image); // save current image element.

		        var sizingText = imageSize.w + 'x' + imageSize.h;
		        $selection.find('.note-control-selection-info').text(sizingText);
		        context.invoke('editor.saveTarget', target);
		      } else {
		        this.hide();
		      }

		      return isImage;
		    };

		    /**
		     * hide
		     *
		     * @param {jQuery} $handle
		     */
		    this.hide = function () {
		      context.invoke('editor.clearTarget');
		      this.$handle.children().hide();
		    };
		  };

		  var AutoLink = function (context) {
		    var self = this;
		    var defaultScheme = 'http://';
		    var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;

		    this.events = {
		      'summernote.keyup': function (we, e) {
		        if (!e.isDefaultPrevented()) {
		          self.handleKeyup(e);
		        }
		      },
		      'summernote.keydown': function (we, e) {
		        self.handleKeydown(e);
		      }
		    };

		    this.initialize = function () {
		      this.lastWordRange = null;
		    };

		    this.destroy = function () {
		      this.lastWordRange = null;
		    };

		    this.replace = function () {
		      if (!this.lastWordRange) {
		        return;
		      }

		      var keyword = this.lastWordRange.toString();
		      var match = keyword.match(linkPattern);

		      if (match && (match[1] || match[2])) {
		        var link = match[1] ? keyword : defaultScheme + keyword;
		        var node = $('<a />').html(keyword).attr('href', link)[0];

		        this.lastWordRange.insertNode(node);
		        this.lastWordRange = null;
		        context.invoke('editor.focus');
		      }

		    };

		    this.handleKeydown = function (e) {
		      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
		        var wordRange = context.invoke('editor.createRange').getWordRange();
		        this.lastWordRange = wordRange;
		      }
		    };

		    this.handleKeyup = function (e) {
		      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
		        this.replace();
		      }
		    };
		  };

		  /**
		   * textarea auto sync.
		   */
		  var AutoSync = function (context) {
		    var $note = context.layoutInfo.note;

		    this.events = {
		      'summernote.change': function () {
		        $note.val(context.invoke('code'));
		      }
		    };

		    this.shouldInitialize = function () {
		      return dom.isTextarea($note[0]);
		    };
		  };

		  var Placeholder = function (context) {
		    var self = this;
		    var $editingArea = context.layoutInfo.editingArea;
		    var options = context.options;

		    this.events = {
		      'summernote.init summernote.change': function () {
		        self.update();
		      },
		      'summernote.codeview.toggled': function () {
		        self.update();
		      }
		    };

		    this.shouldInitialize = function () {
		      return !!options.placeholder;
		    };

		    this.initialize = function () {
		      this.$placeholder = $('<div class="note-placeholder">');
		      this.$placeholder.on('click', function () {
		        context.invoke('focus');
		      }).text(options.placeholder).prependTo($editingArea);
		    };

		    this.destroy = function () {
		      this.$placeholder.remove();
		    };

		    this.update = function () {
		      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');
		      this.$placeholder.toggle(isShow);
		    };
		  };

		  var Buttons = function (context) {
		    var self = this;
		    var ui = $.summernote.ui;

		    var $toolbar = context.layoutInfo.toolbar;
		    var options = context.options;
		    var lang = options.langInfo;

		    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);

		    var representShortcut = this.representShortcut = function (editorMethod) {
		      var shortcut = invertedKeyMap[editorMethod];
		      if (!options.shortcuts || !shortcut) {
		        return '';
		      }
		      
		      if (agent.isMac) {
		        shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');
		      }

		      shortcut = shortcut.replace('BACKSLASH', '\\')
		                         .replace('SLASH', '/')
		                         .replace('LEFTBRACKET', '[')
		                         .replace('RIGHTBRACKET', ']');

		      return ' (' + shortcut + ')';
		    };

		    this.initialize = function () {
		      this.addToolbarButtons();
		      this.addImagePopoverButtons();
		      this.addLinkPopoverButtons();
		      this.fontInstalledMap = {};
		    };

		    this.destroy = function () {
		      delete this.fontInstalledMap;
		    };

		    this.isFontInstalled = function (name) {
		      if (!self.fontInstalledMap.hasOwnProperty(name)) {
		        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||
		          list.contains(options.fontNamesIgnoreCheck, name);
		      }

		      return self.fontInstalledMap[name];
		    };

		    this.addToolbarButtons = function () {
		      context.memo('button.style', function () {
		        return ui.buttonGroup([
		          ui.button({
		            className: 'dropdown-toggle',
		            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),
		            tooltip: lang.style.style,
		            data: {
		              toggle: 'dropdown'
		            }
		          }),
		          ui.dropdown({
		            className: 'dropdown-style',
		            items: context.options.styleTags,
		            template: function (item) {

		              if (typeof item === 'string') {
		                item = { tag: item, title: (lang.style.hasOwnProperty(item) ? lang.style[item] : item) };
		              }

		              var tag = item.tag;
		              var title = item.title;
		              var style = item.style ? ' style="' + item.style + '" ' : '';
		              var className = item.className ? ' class="' + item.className + '"' : '';

		              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';
		            },
		            click: context.createInvokeHandler('editor.formatBlock')
		          })
		        ]).render();
		      });

		      context.memo('button.bold', function () {
		        return ui.button({
		          className: 'note-btn-bold',
		          contents: ui.icon(options.icons.bold),
		          tooltip: lang.font.bold + representShortcut('bold'),
		          click: context.createInvokeHandler('editor.bold')
		        }).render();
		      });

		      context.memo('button.italic', function () {
		        return ui.button({
		          className: 'note-btn-italic',
		          contents: ui.icon(options.icons.italic),
		          tooltip: lang.font.italic + representShortcut('italic'),
		          click: context.createInvokeHandler('editor.italic')
		        }).render();
		      });

		      context.memo('button.underline', function () {
		        return ui.button({
		          className: 'note-btn-underline',
		          contents: ui.icon(options.icons.underline),
		          tooltip: lang.font.underline + representShortcut('underline'),
		          click: context.createInvokeHandler('editor.underline')
		        }).render();
		      });

		      context.memo('button.clear', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.eraser),
		          tooltip: lang.font.clear + representShortcut('removeFormat'),
		          click: context.createInvokeHandler('editor.removeFormat')
		        }).render();
		      });

		      context.memo('button.strikethrough', function () {
		        return ui.button({
		          className: 'note-btn-strikethrough',
		          contents: ui.icon(options.icons.strikethrough),
		          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),
		          click: context.createInvokeHandler('editor.strikethrough')
		        }).render();
		      });

		      context.memo('button.superscript', function () {
		        return ui.button({
		          className: 'note-btn-superscript',
		          contents: ui.icon(options.icons.superscript),
		          tooltip: lang.font.superscript,
		          click: context.createInvokeHandler('editor.superscript')
		        }).render();
		      });

		      context.memo('button.subscript', function () {
		        return ui.button({
		          className: 'note-btn-subscript',
		          contents: ui.icon(options.icons.subscript),
		          tooltip: lang.font.subscript,
		          click: context.createInvokeHandler('editor.subscript')
		        }).render();
		      });

		      context.memo('button.fontname', function () {
		        return ui.buttonGroup([
		          ui.button({
		            className: 'dropdown-toggle',
		            contents: '<span class="note-current-fontname"/> ' + ui.icon(options.icons.caret, 'span'),
		            tooltip: lang.font.name,
		            data: {
		              toggle: 'dropdown'
		            }
		          }),
		          ui.dropdownCheck({
		            className: 'dropdown-fontname',
		            checkClassName: options.icons.menuCheck,
		            items: options.fontNames.filter(self.isFontInstalled),
		            template: function (item) {
		              return '<span style="font-family:' + item + '">' + item + '</span>';
		            },
		            click: context.createInvokeHandler('editor.fontName')
		          })
		        ]).render();
		      });

		      context.memo('button.fontsize', function () {
		        return ui.buttonGroup([
		          ui.button({
		            className: 'dropdown-toggle',
		            contents: '<span class="note-current-fontsize"/>' + ui.icon(options.icons.caret, 'span'),
		            tooltip: lang.font.size,
		            data: {
		              toggle: 'dropdown'
		            }
		          }),
		          ui.dropdownCheck({
		            className: 'dropdown-fontsize',
		            checkClassName: options.icons.menuCheck,
		            items: options.fontSizes,
		            click: context.createInvokeHandler('editor.fontSize')
		          })
		        ]).render();
		      });

		      context.memo('button.color', function () {
		        return ui.buttonGroup({
		          className: 'note-color',
		          children: [
		            ui.button({
		              className: 'note-current-color-button',
		              contents: ui.icon(options.icons.font + ' note-recent-color'),
		              tooltip: lang.color.recent,
		              click: function (e) {
		                var $button = $(e.currentTarget);
		                context.invoke('editor.color', {
		                  backColor: $button.attr('data-backColor'),
		                  foreColor: $button.attr('data-foreColor')
		                });
		              },
		              callback: function ($button) {
		                var $recentColor = $button.find('.note-recent-color');
		                $recentColor.css('background-color', '#FFFF00');
		                $button.attr('data-backColor', '#FFFF00');
		              }
		            }),
		            ui.button({
		              className: 'dropdown-toggle',
		              contents: ui.icon(options.icons.caret, 'span'),
		              tooltip: lang.color.more,
		              data: {
		                toggle: 'dropdown'
		              }
		            }),
		            ui.dropdown({
		              items: [
		                '<li>',
		                '<div class="btn-group">',
		                '  <div class="note-palette-title">' + lang.color.background + '</div>',
		                '  <div>',
		                '    <button type="button" class="note-color-reset btn btn-default" data-event="backColor" data-value="inherit">',
		                lang.color.transparent,
		                '    </button>',
		                '  </div>',
		                '  <div class="note-holder" data-event="backColor"/>',
		                '</div>',
		                '<div class="btn-group">',
		                '  <div class="note-palette-title">' + lang.color.foreground + '</div>',
		                '  <div>',
		                '    <button type="button" class="note-color-reset btn btn-default" data-event="removeFormat" data-value="foreColor">',
		                lang.color.resetToDefault,
		                '    </button>',
		                '  </div>',
		                '  <div class="note-holder" data-event="foreColor"/>',
		                '</div>',
		                '</li>'
		              ].join(''),
		              callback: function ($dropdown) {
		                $dropdown.find('.note-holder').each(function () {
		                  var $holder = $(this);
		                  $holder.append(ui.palette({
		                    colors: options.colors,
		                    eventName: $holder.data('event')
		                  }).render());
		                });
		              },
		              click: function (event) {
		                var $button = $(event.target);
		                var eventName = $button.data('event');
		                var value = $button.data('value');

		                if (eventName && value) {
		                  var key = eventName === 'backColor' ? 'background-color' : 'color';
		                  var $color = $button.closest('.note-color').find('.note-recent-color');
		                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');

		                  $color.css(key, value);
		                  $currentButton.attr('data-' + eventName, value);
		                  context.invoke('editor.' + eventName, value);
		                }
		              }
		            })
		          ]
		        }).render();
		      });

		      context.memo('button.ul',  function () {
		        return ui.button({
		          contents: ui.icon(options.icons.unorderedlist),
		          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),
		          click: context.createInvokeHandler('editor.insertUnorderedList')
		        }).render();
		      });

		      context.memo('button.ol', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.orderedlist),
		          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),
		          click:  context.createInvokeHandler('editor.insertOrderedList')
		        }).render();
		      });

		      var justifyLeft = ui.button({
		        contents: ui.icon(options.icons.alignLeft),
		        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),
		        click: context.createInvokeHandler('editor.justifyLeft')
		      });

		      var justifyCenter = ui.button({
		        contents: ui.icon(options.icons.alignCenter),
		        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),
		        click: context.createInvokeHandler('editor.justifyCenter')
		      });

		      var justifyRight = ui.button({
		        contents: ui.icon(options.icons.alignRight),
		        tooltip: lang.paragraph.right + representShortcut('justifyRight'),
		        click: context.createInvokeHandler('editor.justifyRight')
		      });

		      var justifyFull = ui.button({
		        contents: ui.icon(options.icons.alignJustify),
		        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),
		        click: context.createInvokeHandler('editor.justifyFull')
		      });

		      var outdent = ui.button({
		        contents: ui.icon(options.icons.outdent),
		        tooltip: lang.paragraph.outdent + representShortcut('outdent'),
		        click: context.createInvokeHandler('editor.outdent')
		      });

		      var indent = ui.button({
		        contents: ui.icon(options.icons.indent),
		        tooltip: lang.paragraph.indent + representShortcut('indent'),
		        click: context.createInvokeHandler('editor.indent')
		      });

		      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));
		      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));
		      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));
		      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));
		      context.memo('button.outdent', func.invoke(outdent, 'render'));
		      context.memo('button.indent', func.invoke(indent, 'render'));

		      context.memo('button.paragraph', function () {
		        return ui.buttonGroup([
		          ui.button({
		            className: 'dropdown-toggle',
		            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),
		            tooltip: lang.paragraph.paragraph,
		            data: {
		              toggle: 'dropdown'
		            }
		          }),
		          ui.dropdown([
		            ui.buttonGroup({
		              className: 'note-align',
		              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]
		            }),
		            ui.buttonGroup({
		              className: 'note-list',
		              children: [outdent, indent]
		            })
		          ])
		        ]).render();
		      });

		      context.memo('button.height', function () {
		        return ui.buttonGroup([
		          ui.button({
		            className: 'dropdown-toggle',
		            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),
		            tooltip: lang.font.height,
		            data: {
		              toggle: 'dropdown'
		            }
		          }),
		          ui.dropdownCheck({
		            items: options.lineHeights,
		            checkClassName: options.icons.menuCheck,
		            className: 'dropdown-line-height',
		            click: context.createInvokeHandler('editor.lineHeight')
		          })
		        ]).render();
		      });

		      context.memo('button.table', function () {
		        return ui.buttonGroup([
		          ui.button({
		            className: 'dropdown-toggle',
		            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),
		            tooltip: lang.table.table,
		            data: {
		              toggle: 'dropdown'
		            }
		          }),
		          ui.dropdown({
		            className: 'note-table',
		            items: [
		              '<div class="note-dimension-picker">',
		              '  <div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"/>',
		              '  <div class="note-dimension-picker-highlighted"/>',
		              '  <div class="note-dimension-picker-unhighlighted"/>',
		              '</div>',
		              '<div class="note-dimension-display">1 x 1</div>'
		            ].join('')
		          })
		        ], {
		          callback: function ($node) {
		            var $catcher = $node.find('.note-dimension-picker-mousecatcher');
		            $catcher.css({
		              width: options.insertTableMaxSize.col + 'em',
		              height: options.insertTableMaxSize.row + 'em'
		            }).mousedown(context.createInvokeHandler('editor.insertTable'))
		              .on('mousemove', self.tableMoveHandler);
		          }
		        }).render();
		      });

		      context.memo('button.link', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.link),
		          tooltip: lang.link.link + representShortcut('linkDialog.show'),
		          click: context.createInvokeHandler('linkDialog.show')
		        }).render();
		      });

		      context.memo('button.picture', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.picture),
		          tooltip: lang.image.image,
		          click: context.createInvokeHandler('imageDialog.show')
		        }).render();
		      });

		      context.memo('button.video', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.video),
		          tooltip: lang.video.video,
		          click: context.createInvokeHandler('videoDialog.show')
		        }).render();
		      });

		      context.memo('button.hr', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.minus),
		          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),
		          click: context.createInvokeHandler('editor.insertHorizontalRule')
		        }).render();
		      });

		      context.memo('button.fullscreen', function () {
		        return ui.button({
		          className: 'btn-fullscreen',
		          contents: ui.icon(options.icons.arrowsAlt),
		          tooltip: lang.options.fullscreen,
		          click: context.createInvokeHandler('fullscreen.toggle')
		        }).render();
		      });

		      context.memo('button.codeview', function () {
		        return ui.button({
		          className: 'btn-codeview',
		          contents: ui.icon(options.icons.code),
		          tooltip: lang.options.codeview,
		          click: context.createInvokeHandler('codeview.toggle')
		        }).render();
		      });

		      context.memo('button.redo', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.redo),
		          tooltip: lang.history.redo + representShortcut('redo'),
		          click: context.createInvokeHandler('editor.redo')
		        }).render();
		      });

		      context.memo('button.undo', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.undo),
		          tooltip: lang.history.undo + representShortcut('undo'),
		          click: context.createInvokeHandler('editor.undo')
		        }).render();
		      });

		      context.memo('button.help', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.question),
		          tooltip: lang.options.help,
		          click: context.createInvokeHandler('helpDialog.show')
		        }).render();
		      });
		    };

		    /**
		     * image : [
		     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],
		     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],
		     *   ['remove', ['removeMedia']]
		     * ],
		     */
		    this.addImagePopoverButtons = function () {
		      // Image Size Buttons
		      context.memo('button.imageSize100', function () {
		        return ui.button({
		          contents: '<span class="note-fontsize-10">100%</span>',
		          tooltip: lang.image.resizeFull,
		          click: context.createInvokeHandler('editor.resize', '1')
		        }).render();
		      });
		      context.memo('button.imageSize50', function () {
		        return  ui.button({
		          contents: '<span class="note-fontsize-10">50%</span>',
		          tooltip: lang.image.resizeHalf,
		          click: context.createInvokeHandler('editor.resize', '0.5')
		        }).render();
		      });
		      context.memo('button.imageSize25', function () {
		        return ui.button({
		          contents: '<span class="note-fontsize-10">25%</span>',
		          tooltip: lang.image.resizeQuarter,
		          click: context.createInvokeHandler('editor.resize', '0.25')
		        }).render();
		      });

		      // Float Buttons
		      context.memo('button.floatLeft', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.alignLeft),
		          tooltip: lang.image.floatLeft,
		          click: context.createInvokeHandler('editor.floatMe', 'left')
		        }).render();
		      });

		      context.memo('button.floatRight', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.alignRight),
		          tooltip: lang.image.floatRight,
		          click: context.createInvokeHandler('editor.floatMe', 'right')
		        }).render();
		      });

		      context.memo('button.floatNone', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.alignJustify),
		          tooltip: lang.image.floatNone,
		          click: context.createInvokeHandler('editor.floatMe', 'none')
		        }).render();
		      });

		      // Remove Buttons
		      context.memo('button.removeMedia', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.trash),
		          tooltip: lang.image.remove,
		          click: context.createInvokeHandler('editor.removeMedia')
		        }).render();
		      });
		    };

		    this.addLinkPopoverButtons = function () {
		      context.memo('button.linkDialogShow', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.link),
		          tooltip: lang.link.edit,
		          click: context.createInvokeHandler('linkDialog.show')
		        }).render();
		      });

		      context.memo('button.unlink', function () {
		        return ui.button({
		          contents: ui.icon(options.icons.unlink),
		          tooltip: lang.link.unlink,
		          click: context.createInvokeHandler('editor.unlink')
		        }).render();
		      });
		    };

		    this.build = function ($container, groups) {
		      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {
		        var group = groups[groupIdx];
		        var groupName = group[0];
		        var buttons = group[1];

		        var $group = ui.buttonGroup({
		          className: 'note-' + groupName
		        }).render();

		        for (var idx = 0, len = buttons.length; idx < len; idx++) {
		          var button = context.memo('button.' + buttons[idx]);
		          if (button) {
		            $group.append(typeof button === 'function' ? button(context) : button);
		          }
		        }
		        $group.appendTo($container);
		      }
		    };

		    this.updateCurrentStyle = function () {
		      var styleInfo = context.invoke('editor.currentStyle');
		      this.updateBtnStates({
		        '.note-btn-bold': function () {
		          return styleInfo['font-bold'] === 'bold';
		        },
		        '.note-btn-italic': function () {
		          return styleInfo['font-italic'] === 'italic';
		        },
		        '.note-btn-underline': function () {
		          return styleInfo['font-underline'] === 'underline';
		        },
		        '.note-btn-subscript': function () {
		          return styleInfo['font-subscript'] === 'subscript';
		        },
		        '.note-btn-superscript': function () {
		          return styleInfo['font-superscript'] === 'superscript';
		        },
		        '.note-btn-strikethrough': function () {
		          return styleInfo['font-strikethrough'] === 'strikethrough';
		        }
		      });

		      if (styleInfo['font-family']) {
		        var fontNames = styleInfo['font-family'].split(',').map(function (name) {
		          return name.replace(/[\'\"]/g, '')
		            .replace(/\s+$/, '')
		            .replace(/^\s+/, '');
		        });
		        var fontName = list.find(fontNames, self.isFontInstalled);

		        $toolbar.find('.dropdown-fontname li a').each(function () {
		          // always compare string to avoid creating another func.
		          var isChecked = ($(this).data('value') + '') === (fontName + '');
		          this.className = isChecked ? 'checked' : '';
		        });
		        $toolbar.find('.note-current-fontname').text(fontName);
		      }

		      if (styleInfo['font-size']) {
		        var fontSize = styleInfo['font-size'];
		        $toolbar.find('.dropdown-fontsize li a').each(function () {
		          // always compare with string to avoid creating another func.
		          var isChecked = ($(this).data('value') + '') === (fontSize + '');
		          this.className = isChecked ? 'checked' : '';
		        });
		        $toolbar.find('.note-current-fontsize').text(fontSize);
		      }

		      if (styleInfo['line-height']) {
		        var lineHeight = styleInfo['line-height'];
		        $toolbar.find('.dropdown-line-height li a').each(function () {
		          // always compare with string to avoid creating another func.
		          var isChecked = ($(this).data('value') + '') === (lineHeight + '');
		          this.className = isChecked ? 'checked' : '';
		        });
		      }
		    };

		    this.updateBtnStates = function (infos) {
		      $.each(infos, function (selector, pred) {
		        ui.toggleBtnActive($toolbar.find(selector), pred());
		      });
		    };

		    this.tableMoveHandler = function (event) {
		      var PX_PER_EM = 18;
		      var $picker = $(event.target.parentNode); // target is mousecatcher
		      var $dimensionDisplay = $picker.next();
		      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');
		      var $highlighted = $picker.find('.note-dimension-picker-highlighted');
		      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');

		      var posOffset;
		      // HTML5 with jQuery - e.offsetX is undefined in Firefox
		      if (event.offsetX === undefined) {
		        var posCatcher = $(event.target).offset();
		        posOffset = {
		          x: event.pageX - posCatcher.left,
		          y: event.pageY - posCatcher.top
		        };
		      } else {
		        posOffset = {
		          x: event.offsetX,
		          y: event.offsetY
		        };
		      }

		      var dim = {
		        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
		        r: Math.ceil(posOffset.y / PX_PER_EM) || 1
		      };

		      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });
		      $catcher.data('value', dim.c + 'x' + dim.r);

		      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {
		        $unhighlighted.css({ width: dim.c + 1 + 'em'});
		      }

		      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {
		        $unhighlighted.css({ height: dim.r + 1 + 'em'});
		      }

		      $dimensionDisplay.html(dim.c + ' x ' + dim.r);
		    };
		  };

		  var Toolbar = function (context) {
		    var ui = $.summernote.ui;

		    var $note = context.layoutInfo.note;
		    var $toolbar = context.layoutInfo.toolbar;
		    var options = context.options;

		    this.shouldInitialize = function () {
		      return !options.airMode;
		    };

		    this.initialize = function () {
		      options.toolbar = options.toolbar || [];

		      if (!options.toolbar.length) {
		        $toolbar.hide();
		      } else {
		        context.invoke('buttons.build', $toolbar, options.toolbar);
		      }

		      if (options.toolbarContainer) {
		        $toolbar.appendTo(options.toolbarContainer);
		      }

		      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {
		        context.invoke('buttons.updateCurrentStyle');
		      });

		      context.invoke('buttons.updateCurrentStyle');
		    };

		    this.destroy = function () {
		      $toolbar.children().remove();
		    };

		    this.updateFullscreen = function (isFullscreen) {
		      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);
		    };

		    this.updateCodeview = function (isCodeview) {
		      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);
		      if (isCodeview) {
		        this.deactivate();
		      } else {
		        this.activate();
		      }
		    };

		    this.activate = function (isIncludeCodeview) {
		      var $btn = $toolbar.find('button');
		      if (!isIncludeCodeview) {
		        $btn = $btn.not('.btn-codeview');
		      }
		      ui.toggleBtn($btn, true);
		    };

		    this.deactivate = function (isIncludeCodeview) {
		      var $btn = $toolbar.find('button');
		      if (!isIncludeCodeview) {
		        $btn = $btn.not('.btn-codeview');
		      }
		      ui.toggleBtn($btn, false);
		    };
		  };

		  var LinkDialog = function (context) {
		    var self = this;
		    var ui = $.summernote.ui;

		    var $editor = context.layoutInfo.editor;
		    var options = context.options;
		    var lang = options.langInfo;

		    this.initialize = function () {
		      var $container = options.dialogsInBody ? $(document.body) : $editor;

		      var body = '<div class="form-group">' +
		                   '<label>' + lang.link.textToDisplay + '</label>' +
		                   '<input class="note-link-text form-control" type="text" />' +
		                 '</div>' +
		                 '<div class="form-group">' +
		                   '<label>' + lang.link.url + '</label>' +
		                   '<input class="note-link-url form-control" type="text" value="http://" />' +
		                 '</div>' +
		                 (!options.disableLinkTarget ?
		                   '<div class="checkbox">' +
		                     '<label>' + '<input type="checkbox" checked> ' + lang.link.openInNewWindow + '</label>' +
		                   '</div>' : ''
		                 );
		      var footer = '<button href="#" class="btn btn-primary note-link-btn disabled" disabled>' + lang.link.insert + '</button>';

		      this.$dialog = ui.dialog({
		        className: 'link-dialog',
		        title: lang.link.insert,
		        fade: options.dialogsFade,
		        body: body,
		        footer: footer
		      }).render().appendTo($container);
		    };

		    this.destroy = function () {
		      ui.hideDialog(this.$dialog);
		      this.$dialog.remove();
		    };

		    this.bindEnterKey = function ($input, $btn) {
		      $input.on('keypress', function (event) {
		        if (event.keyCode === key.code.ENTER) {
		          $btn.trigger('click');
		        }
		      });
		    };

		    /**
		     * toggle update button
		     */
		    this.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {
		      ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
		    };

		    /**
		     * Show link dialog and set event handlers on dialog controls.
		     *
		     * @param {Object} linkInfo
		     * @return {Promise}
		     */
		    this.showLinkDialog = function (linkInfo) {
		      return $.Deferred(function (deferred) {
		        var $linkText = self.$dialog.find('.note-link-text'),
		        $linkUrl = self.$dialog.find('.note-link-url'),
		        $linkBtn = self.$dialog.find('.note-link-btn'),
		        $openInNewWindow = self.$dialog.find('input[type=checkbox]');

		        ui.onDialogShown(self.$dialog, function () {
		          context.triggerEvent('dialog.shown');

		          // if no url was given, copy text to url
		          if (!linkInfo.url) {
		            linkInfo.url = linkInfo.text;
		          }

		          $linkText.val(linkInfo.text);

		          var handleLinkTextUpdate = function () {
		            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
		            // if linktext was modified by keyup,
		            // stop cloning text from linkUrl
		            linkInfo.text = $linkText.val();
		          };

		          $linkText.on('input', handleLinkTextUpdate).on('paste', function () {
		            setTimeout(handleLinkTextUpdate, 0);
		          });

		          var handleLinkUrlUpdate = function () {
		            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
		            // display same link on `Text to display` input
		            // when create a new link
		            if (!linkInfo.text) {
		              $linkText.val($linkUrl.val());
		            }
		          };

		          $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {
		            setTimeout(handleLinkUrlUpdate, 0);
		          }).val(linkInfo.url).trigger('focus');

		          self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
		          self.bindEnterKey($linkUrl, $linkBtn);
		          self.bindEnterKey($linkText, $linkBtn);

		          $openInNewWindow.prop('checked', linkInfo.isNewWindow);

		          $linkBtn.one('click', function (event) {
		            event.preventDefault();

		            deferred.resolve({
		              range: linkInfo.range,
		              url: $linkUrl.val(),
		              text: $linkText.val(),
		              isNewWindow: $openInNewWindow.is(':checked')
		            });
		            self.$dialog.modal('hide');
		          });
		        });

		        ui.onDialogHidden(self.$dialog, function () {
		          // detach events
		          $linkText.off('input paste keypress');
		          $linkUrl.off('input paste keypress');
		          $linkBtn.off('click');

		          if (deferred.state() === 'pending') {
		            deferred.reject();
		          }
		        });

		        ui.showDialog(self.$dialog);
		      }).promise();
		    };

		    /**
		     * @param {Object} layoutInfo
		     */
		    this.show = function () {
		      var linkInfo = context.invoke('editor.getLinkInfo');

		      context.invoke('editor.saveRange');
		      this.showLinkDialog(linkInfo).then(function (linkInfo) {
		        context.invoke('editor.restoreRange');
		        context.invoke('editor.createLink', linkInfo);
		      }).fail(function () {
		        context.invoke('editor.restoreRange');
		      });
		    };
		    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);
		  };

		  var LinkPopover = function (context) {
		    var self = this;
		    var ui = $.summernote.ui;

		    var options = context.options;

		    this.events = {
		      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {
		        self.update();
		      },
		      'summernote.dialog.shown': function () {
		        self.hide();
		      }
		    };

		    this.shouldInitialize = function () {
		      return !list.isEmpty(options.popover.link);
		    };

		    this.initialize = function () {
		      this.$popover = ui.popover({
		        className: 'note-link-popover',
		        callback: function ($node) {
		          var $content = $node.find('.popover-content');
		          $content.prepend('<span><a target="_blank"></a>&nbsp;</span>');
		        }
		      }).render().appendTo('body');
		      var $content = this.$popover.find('.popover-content');

		      context.invoke('buttons.build', $content, options.popover.link);
		    };

		    this.destroy = function () {
		      this.$popover.remove();
		    };

		    this.update = function () {
		      // Prevent focusing on editable when invoke('code') is executed
		      if (!context.invoke('editor.hasFocus')) {
		        this.hide();
		        return;
		      }

		      var rng = context.invoke('editor.createRange');
		      if (rng.isCollapsed() && rng.isOnAnchor()) {
		        var anchor = dom.ancestor(rng.sc, dom.isAnchor);
		        var href = $(anchor).attr('href');
		        this.$popover.find('a').attr('href', href).html(href);

		        var pos = dom.posFromPlaceholder(anchor);
		        this.$popover.css({
		          display: 'block',
		          left: pos.left,
		          top: pos.top
		        });
		      } else {
		        this.hide();
		      }
		    };

		    this.hide = function () {
		      this.$popover.hide();
		    };
		  };

		  var ImageDialog = function (context) {
		    var self = this;
		    var ui = $.summernote.ui;

		    var $editor = context.layoutInfo.editor;
		    var options = context.options;
		    var lang = options.langInfo;

		    this.initialize = function () {
		      var $container = options.dialogsInBody ? $(document.body) : $editor;

		      var imageLimitation = '';
		      if (options.maximumImageFileSize) {
		        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));
		        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +
		                           ' ' + ' KMGTP'[unit] + 'B';
		        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';
		      }

		      var body = '<div class="form-group note-group-select-from-files">' +
		                   '<label>' + lang.image.selectFromFiles + '</label>' +
		                   '<input class="note-image-input form-control" type="file" name="files" accept="image/*" multiple="multiple" />' +
		                   imageLimitation +
		                 '</div>' +
		                 '<div class="form-group note-group-image-url" style="overflow:auto;">' +
		                   '<label>' + lang.image.url + '</label>' +
		                   '<input class="note-image-url form-control col-md-12" type="text" />' +
		                 '</div>';
		      var footer = '<button href="#" class="btn btn-primary note-image-btn disabled" disabled>' + lang.image.insert + '</button>';

		      this.$dialog = ui.dialog({
		        title: lang.image.insert,
		        fade: options.dialogsFade,
		        body: body,
		        footer: footer
		      }).render().appendTo($container);
		    };

		    this.destroy = function () {
		      ui.hideDialog(this.$dialog);
		      this.$dialog.remove();
		    };

		    this.bindEnterKey = function ($input, $btn) {
		      $input.on('keypress', function (event) {
		        if (event.keyCode === key.code.ENTER) {
		          $btn.trigger('click');
		        }
		      });
		    };

		    this.show = function () {
		      context.invoke('editor.saveRange');
		      this.showImageDialog().then(function (data) {
		        // [workaround] hide dialog before restore range for IE range focus
		        ui.hideDialog(self.$dialog);
		        context.invoke('editor.restoreRange');

		        if (typeof data === 'string') { // image url
		          context.invoke('editor.insertImage', data);
		        } else { // array of files
		          context.invoke('editor.insertImagesOrCallback', data);
		        }
		      }).fail(function () {
		        context.invoke('editor.restoreRange');
		      });
		    };

		    /**
		     * show image dialog
		     *
		     * @param {jQuery} $dialog
		     * @return {Promise}
		     */
		    this.showImageDialog = function () {
		      return $.Deferred(function (deferred) {
		        var $imageInput = self.$dialog.find('.note-image-input'),
		            $imageUrl = self.$dialog.find('.note-image-url'),
		            $imageBtn = self.$dialog.find('.note-image-btn');

		        ui.onDialogShown(self.$dialog, function () {
		          context.triggerEvent('dialog.shown');

		          // Cloning imageInput to clear element.
		          $imageInput.replaceWith($imageInput.clone()
		            .on('change', function () {
		              deferred.resolve(this.files || this.value);
		            })
		            .val('')
		          );

		          $imageBtn.click(function (event) {
		            event.preventDefault();

		            deferred.resolve($imageUrl.val());
		          });

		          $imageUrl.on('keyup paste', function () {
		            var url = $imageUrl.val();
		            ui.toggleBtn($imageBtn, url);
		          }).val('').trigger('focus');
		          self.bindEnterKey($imageUrl, $imageBtn);
		        });

		        ui.onDialogHidden(self.$dialog, function () {
		          $imageInput.off('change');
		          $imageUrl.off('keyup paste keypress');
		          $imageBtn.off('click');

		          if (deferred.state() === 'pending') {
		            deferred.reject();
		          }
		        });

		        ui.showDialog(self.$dialog);
		      });
		    };
		  };

		  var ImagePopover = function (context) {
		    var ui = $.summernote.ui;

		    var options = context.options;

		    this.shouldInitialize = function () {
		      return !list.isEmpty(options.popover.image);
		    };

		    this.initialize = function () {
		      this.$popover = ui.popover({
		        className: 'note-image-popover'
		      }).render().appendTo('body');
		      var $content = this.$popover.find('.popover-content');

		      context.invoke('buttons.build', $content, options.popover.image);
		    };

		    this.destroy = function () {
		      this.$popover.remove();
		    };

		    this.update = function (target) {
		      if (dom.isImg(target)) {
		        var pos = dom.posFromPlaceholder(target);
		        this.$popover.css({
		          display: 'block',
		          left: pos.left,
		          top: pos.top
		        });
		      } else {
		        this.hide();
		      }
		    };

		    this.hide = function () {
		      this.$popover.hide();
		    };
		  };

		  var VideoDialog = function (context) {
		    var self = this;
		    var ui = $.summernote.ui;

		    var $editor = context.layoutInfo.editor;
		    var options = context.options;
		    var lang = options.langInfo;

		    this.initialize = function () {
		      var $container = options.dialogsInBody ? $(document.body) : $editor;

		      var body = '<div class="form-group row-fluid">' +
		          '<label>' + lang.video.url + ' <small class="text-muted">' + lang.video.providers + '</small></label>' +
		          '<input class="note-video-url form-control span12" type="text" />' +
		          '</div>';
		      var footer = '<button href="#" class="btn btn-primary note-video-btn disabled" disabled>' + lang.video.insert + '</button>';

		      this.$dialog = ui.dialog({
		        title: lang.video.insert,
		        fade: options.dialogsFade,
		        body: body,
		        footer: footer
		      }).render().appendTo($container);
		    };

		    this.destroy = function () {
		      ui.hideDialog(this.$dialog);
		      this.$dialog.remove();
		    };

		    this.bindEnterKey = function ($input, $btn) {
		      $input.on('keypress', function (event) {
		        if (event.keyCode === key.code.ENTER) {
		          $btn.trigger('click');
		        }
		      });
		    };

		    this.createVideoNode = function (url) {
		      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)
		      var ytRegExp = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/;
		      var ytMatch = url.match(ytRegExp);

		      var igRegExp = /(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/;
		      var igMatch = url.match(igRegExp);

		      var vRegExp = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/;
		      var vMatch = url.match(vRegExp);

		      var vimRegExp = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*([0-9]{6,11})[?]?.*/;
		      var vimMatch = url.match(vimRegExp);

		      var dmRegExp = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/;
		      var dmMatch = url.match(dmRegExp);

		      var youkuRegExp = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/;
		      var youkuMatch = url.match(youkuRegExp);

		      var mp4RegExp = /^.+.(mp4|m4v)$/;
		      var mp4Match = url.match(mp4RegExp);

		      var oggRegExp = /^.+.(ogg|ogv)$/;
		      var oggMatch = url.match(oggRegExp);

		      var webmRegExp = /^.+.(webm)$/;
		      var webmMatch = url.match(webmRegExp);

		      var $video;
		      if (ytMatch && ytMatch[1].length === 11) {
		        var youtubeId = ytMatch[1];
		        $video = $('<iframe>')
		            .attr('frameborder', 0)
		            .attr('src', '//www.youtube.com/embed/' + youtubeId)
		            .attr('width', '640').attr('height', '360');
		      } else if (igMatch && igMatch[0].length) {
		        $video = $('<iframe>')
		            .attr('frameborder', 0)
		            .attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')
		            .attr('width', '612').attr('height', '710')
		            .attr('scrolling', 'no')
		            .attr('allowtransparency', 'true');
		      } else if (vMatch && vMatch[0].length) {
		        $video = $('<iframe>')
		            .attr('frameborder', 0)
		            .attr('src', vMatch[0] + '/embed/simple')
		            .attr('width', '600').attr('height', '600')
		            .attr('class', 'vine-embed');
		      } else if (vimMatch && vimMatch[3].length) {
		        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')
		            .attr('frameborder', 0)
		            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])
		            .attr('width', '640').attr('height', '360');
		      } else if (dmMatch && dmMatch[2].length) {
		        $video = $('<iframe>')
		            .attr('frameborder', 0)
		            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])
		            .attr('width', '640').attr('height', '360');
		      } else if (youkuMatch && youkuMatch[1].length) {
		        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')
		            .attr('frameborder', 0)
		            .attr('height', '498')
		            .attr('width', '510')
		            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);
		      } else if (mp4Match || oggMatch || webmMatch) {
		        $video = $('<video controls>')
		            .attr('src', url)
		            .attr('width', '640').attr('height', '360');
		      } else {
		        // this is not a known video link. Now what, Cat? Now what?
		        return false;
		      }

		      $video.addClass('note-video-clip');

		      return $video[0];
		    };

		    this.show = function () {
		      var text = context.invoke('editor.getSelectedText');
		      context.invoke('editor.saveRange');
		      this.showVideoDialog(text).then(function (url) {
		        // [workaround] hide dialog before restore range for IE range focus
		        ui.hideDialog(self.$dialog);
		        context.invoke('editor.restoreRange');

		        // build node
		        var $node = self.createVideoNode(url);

		        if ($node) {
		          // insert video node
		          context.invoke('editor.insertNode', $node);
		        }
		      }).fail(function () {
		        context.invoke('editor.restoreRange');
		      });
		    };

		    /**
		     * show image dialog
		     *
		     * @param {jQuery} $dialog
		     * @return {Promise}
		     */
		    this.showVideoDialog = function (text) {
		      return $.Deferred(function (deferred) {
		        var $videoUrl = self.$dialog.find('.note-video-url'),
		            $videoBtn = self.$dialog.find('.note-video-btn');

		        ui.onDialogShown(self.$dialog, function () {
		          context.triggerEvent('dialog.shown');

		          $videoUrl.val(text).on('input', function () {
		            ui.toggleBtn($videoBtn, $videoUrl.val());
		          }).trigger('focus');

		          $videoBtn.click(function (event) {
		            event.preventDefault();

		            deferred.resolve($videoUrl.val());
		          });

		          self.bindEnterKey($videoUrl, $videoBtn);
		        });

		        ui.onDialogHidden(self.$dialog, function () {
		          $videoUrl.off('input');
		          $videoBtn.off('click');

		          if (deferred.state() === 'pending') {
		            deferred.reject();
		          }
		        });

		        ui.showDialog(self.$dialog);
		      });
		    };
		  };

		  var HelpDialog = function (context) {
		    var self = this;
		    var ui = $.summernote.ui;

		    var $editor = context.layoutInfo.editor;
		    var options = context.options;
		    var lang = options.langInfo;

		    this.createShortCutList = function () {
		      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];
		      return Object.keys(keyMap).map(function (key) {
		        var command = keyMap[key];
		        var $row = $('<div><div class="help-list-item"/></div>');
		        $row.append($('<label><kbd>' + key + '</kdb></label>').css({
		          'width': 180,
		          'margin-right': 10
		        })).append($('<span/>').html(context.memo('help.' + command) || command));
		        return $row.html();
		      }).join('');
		    };

		    this.initialize = function () {
		      var $container = options.dialogsInBody ? $(document.body) : $editor;

		      var body = [
		        '<p class="text-center">',
		        '<a href="http://summernote.org/" target="_blank">Summernote 0.8.2</a> · ',
		        '<a href="https://github.com/summernote/summernote" target="_blank">Project</a> · ',
		        '<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>',
		        '</p>'
		      ].join('');

		      this.$dialog = ui.dialog({
		        title: lang.options.help,
		        fade: options.dialogsFade,
		        body: this.createShortCutList(),
		        footer: body,
		        callback: function ($node) {
		          $node.find('.modal-body').css({
		            'max-height': 300,
		            'overflow': 'scroll'
		          });
		        }
		      }).render().appendTo($container);
		    };

		    this.destroy = function () {
		      ui.hideDialog(this.$dialog);
		      this.$dialog.remove();
		    };

		    /**
		     * show help dialog
		     *
		     * @return {Promise}
		     */
		    this.showHelpDialog = function () {
		      return $.Deferred(function (deferred) {
		        ui.onDialogShown(self.$dialog, function () {
		          context.triggerEvent('dialog.shown');
		          deferred.resolve();
		        });
		        ui.showDialog(self.$dialog);
		      }).promise();
		    };

		    this.show = function () {
		      context.invoke('editor.saveRange');
		      this.showHelpDialog().then(function () {
		        context.invoke('editor.restoreRange');
		      });
		    };
		  };

		  var AirPopover = function (context) {
		    var self = this;
		    var ui = $.summernote.ui;

		    var options = context.options;

		    var AIR_MODE_POPOVER_X_OFFSET = 20;

		    this.events = {
		      'summernote.keyup summernote.mouseup summernote.scroll': function () {
		        self.update();
		      },
		      'summernote.change summernote.dialog.shown': function () {
		        self.hide();
		      },
		      'summernote.focusout': function (we, e) {
		        // [workaround] Firefox doesn't support relatedTarget on focusout
		        //  - Ignore hide action on focus out in FF.
		        if (agent.isFF) {
		          return;
		        }

		        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {
		          self.hide();
		        }
		      }
		    };

		    this.shouldInitialize = function () {
		      return options.airMode && !list.isEmpty(options.popover.air);
		    };

		    this.initialize = function () {
		      this.$popover = ui.popover({
		        className: 'note-air-popover'
		      }).render().appendTo('body');
		      var $content = this.$popover.find('.popover-content');

		      context.invoke('buttons.build', $content, options.popover.air);
		    };

		    this.destroy = function () {
		      this.$popover.remove();
		    };

		    this.update = function () {
		      var styleInfo = context.invoke('editor.currentStyle');
		      if (styleInfo.range && !styleInfo.range.isCollapsed()) {
		        var rect = list.last(styleInfo.range.getClientRects());
		        if (rect) {
		          var bnd = func.rect2bnd(rect);
		          this.$popover.css({
		            display: 'block',
		            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,
		            top: bnd.top + bnd.height
		          });
		        }
		      } else {
		        this.hide();
		      }
		    };

		    this.hide = function () {
		      this.$popover.hide();
		    };
		  };

		  var HintPopover = function (context) {
		    var self = this;
		    var ui = $.summernote.ui;

		    var POPOVER_DIST = 5;
		    var hint = context.options.hint || [];
		    var direction = context.options.hintDirection || 'bottom';
		    var hints = $.isArray(hint) ? hint : [hint];

		    this.events = {
		      'summernote.keyup': function (we, e) {
		        if (!e.isDefaultPrevented()) {
		          self.handleKeyup(e);
		        }
		      },
		      'summernote.keydown': function (we, e) {
		        self.handleKeydown(e);
		      },
		      'summernote.dialog.shown': function () {
		        self.hide();
		      }
		    };

		    this.shouldInitialize = function () {
		      return hints.length > 0;
		    };

		    this.initialize = function () {
		      this.lastWordRange = null;
		      this.$popover = ui.popover({
		        className: 'note-hint-popover',
		        hideArrow: true,
		        direction: ''
		      }).render().appendTo('body');

		      this.$popover.hide();

		      this.$content = this.$popover.find('.popover-content');

		      this.$content.on('click', '.note-hint-item', function () {
		        self.$content.find('.active').removeClass('active');
		        $(this).addClass('active');
		        self.replace();
		      });
		    };

		    this.destroy = function () {
		      this.$popover.remove();
		    };

		    this.selectItem = function ($item) {
		      this.$content.find('.active').removeClass('active');
		      $item.addClass('active');

		      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);
		    };

		    this.moveDown = function () {
		      var $current = this.$content.find('.note-hint-item.active');
		      var $next = $current.next();

		      if ($next.length) {
		        this.selectItem($next);
		      } else {
		        var $nextGroup = $current.parent().next();

		        if (!$nextGroup.length) {
		          $nextGroup = this.$content.find('.note-hint-group').first();
		        }

		        this.selectItem($nextGroup.find('.note-hint-item').first());
		      }
		    };

		    this.moveUp = function () {
		      var $current = this.$content.find('.note-hint-item.active');
		      var $prev = $current.prev();

		      if ($prev.length) {
		        this.selectItem($prev);
		      } else {
		        var $prevGroup = $current.parent().prev();

		        if (!$prevGroup.length) {
		          $prevGroup = this.$content.find('.note-hint-group').last();
		        }

		        this.selectItem($prevGroup.find('.note-hint-item').last());
		      }
		    };

		    this.replace = function () {
		      var $item = this.$content.find('.note-hint-item.active');

		      if ($item.length) {
		        var node = this.nodeFromItem($item);
		        this.lastWordRange.insertNode(node);
		        range.createFromNode(node).collapse().select();

		        this.lastWordRange = null;
		        this.hide();
		        context.invoke('editor.focus');
		      }

		    };

		    this.nodeFromItem = function ($item) {
		      var hint = hints[$item.data('index')];
		      var item = $item.data('item');
		      var node = hint.content ? hint.content(item) : item;
		      if (typeof node === 'string') {
		        node = dom.createText(node);
		      }
		      return node;
		    };

		    this.createItemTemplates = function (hintIdx, items) {
		      var hint = hints[hintIdx];
		      return items.map(function (item, idx) {
		        var $item = $('<div class="note-hint-item"/>');
		        $item.append(hint.template ? hint.template(item) : item + '');
		        $item.data({
		          'index': hintIdx,
		          'item': item
		        });

		        if (hintIdx === 0 && idx === 0) {
		          $item.addClass('active');
		        }
		        return $item;
		      });
		    };

		    this.handleKeydown = function (e) {
		      if (!this.$popover.is(':visible')) {
		        return;
		      }

		      if (e.keyCode === key.code.ENTER) {
		        e.preventDefault();
		        this.replace();
		      } else if (e.keyCode === key.code.UP) {
		        e.preventDefault();
		        this.moveUp();
		      } else if (e.keyCode === key.code.DOWN) {
		        e.preventDefault();
		        this.moveDown();
		      }
		    };

		    this.searchKeyword = function (index, keyword, callback) {
		      var hint = hints[index];
		      if (hint && hint.match.test(keyword) && hint.search) {
		        var matches = hint.match.exec(keyword);
		        hint.search(matches[1], callback);
		      } else {
		        callback();
		      }
		    };

		    this.createGroup = function (idx, keyword) {
		      var $group = $('<div class="note-hint-group note-hint-group-' + idx + '"/>');
		      this.searchKeyword(idx, keyword, function (items) {
		        items = items || [];
		        if (items.length) {
		          $group.html(self.createItemTemplates(idx, items));
		          self.show();
		        }
		      });

		      return $group;
		    };

		    this.handleKeyup = function (e) {
		      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {
		        if (e.keyCode === key.code.ENTER) {
		          if (this.$popover.is(':visible')) {
		            return;
		          }
		        }
		      } else {
		        var wordRange = context.invoke('editor.createRange').getWordRange();
		        var keyword = wordRange.toString();
		        if (hints.length && keyword) {
		          this.$content.empty();

		          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));
		          if (bnd) {

		            this.$popover.hide();

		            this.lastWordRange = wordRange;

		            hints.forEach(function (hint, idx) {
		              if (hint.match.test(keyword)) {
		                self.createGroup(idx, keyword).appendTo(self.$content);
		              }
		            });

		            // set position for popover after group is created
		            if (direction === 'top') {
		              this.$popover.css({
		                left: bnd.left,
		                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST
		              });
		            } else {
		              this.$popover.css({
		                left: bnd.left,
		                top: bnd.top + bnd.height + POPOVER_DIST
		              });
		            }

		          }
		        } else {
		          this.hide();
		        }
		      }
		    };

		    this.show = function () {
		      this.$popover.show();
		    };

		    this.hide = function () {
		      this.$popover.hide();
		    };
		  };


		  $.summernote = $.extend($.summernote, {
		    version: '0.8.2',
		    ui: ui,
		    dom: dom,

		    plugins: {},

		    options: {
		      modules: {
		        'editor': Editor,
		        'clipboard': Clipboard,
		        'dropzone': Dropzone,
		        'codeview': Codeview,
		        'statusbar': Statusbar,
		        'fullscreen': Fullscreen,
		        'handle': Handle,
		        // FIXME: HintPopover must be front of autolink
		        //  - Script error about range when Enter key is pressed on hint popover
		        'hintPopover': HintPopover,
		        'autoLink': AutoLink,
		        'autoSync': AutoSync,
		        'placeholder': Placeholder,
		        'buttons': Buttons,
		        'toolbar': Toolbar,
		        'linkDialog': LinkDialog,
		        'linkPopover': LinkPopover,
		        'imageDialog': ImageDialog,
		        'imagePopover': ImagePopover,
		        'videoDialog': VideoDialog,
		        'helpDialog': HelpDialog,
		        'airPopover': AirPopover
		      },

		      buttons: {},
		      
		      lang: 'en-US',

		      // toolbar
		      toolbar: [
		        ['style', ['style']],
		        ['font', ['bold', 'underline', 'clear']],
		        ['fontname', ['fontname']],
		        ['color', ['color']],
		        ['para', ['ul', 'ol', 'paragraph']],
		        ['table', ['table']],
		        ['insert', ['link', 'picture', 'video']],
		        ['view', ['fullscreen', 'codeview', 'help']]
		      ],

		      // popover
		      popover: {
		        image: [
		          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],
		          ['float', ['floatLeft', 'floatRight', 'floatNone']],
		          ['remove', ['removeMedia']]
		        ],
		        link: [
		          ['link', ['linkDialogShow', 'unlink']]
		        ],
		        air: [
		          ['color', ['color']],
		          ['font', ['bold', 'underline', 'clear']],
		          ['para', ['ul', 'paragraph']],
		          ['table', ['table']],
		          ['insert', ['link', 'picture']]
		        ]
		      },

		      // air mode: inline editor
		      airMode: false,

		      width: null,
		      height: null,

		      focus: false,
		      tabSize: 4,
		      styleWithSpan: true,
		      shortcuts: true,
		      textareaAutoSync: true,
		      direction: null,

		      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],

		      fontNames: [
		        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
		        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',
		        'Tahoma', 'Times New Roman', 'Verdana'
		      ],

		      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],

		      // pallete colors(n x n)
		      colors: [
		        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],
		        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],
		        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],
		        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],
		        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],
		        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],
		        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],
		        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']
		      ],

		      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],

		      tableClassName: 'table table-bordered',

		      insertTableMaxSize: {
		        col: 10,
		        row: 10
		      },

		      dialogsInBody: false,
		      dialogsFade: false,

		      maximumImageFileSize: null,

		      callbacks: {
		        onInit: null,
		        onFocus: null,
		        onBlur: null,
		        onEnter: null,
		        onKeyup: null,
		        onKeydown: null,
		        onImageUpload: null,
		        onImageUploadError: null
		      },

		      codemirror: {
		        mode: 'text/html',
		        htmlMode: true,
		        lineNumbers: true
		      },

		      keyMap: {
		        pc: {
		          'ENTER': 'insertParagraph',
		          'CTRL+Z': 'undo',
		          'CTRL+Y': 'redo',
		          'TAB': 'tab',
		          'SHIFT+TAB': 'untab',
		          'CTRL+B': 'bold',
		          'CTRL+I': 'italic',
		          'CTRL+U': 'underline',
		          'CTRL+SHIFT+S': 'strikethrough',
		          'CTRL+BACKSLASH': 'removeFormat',
		          'CTRL+SHIFT+L': 'justifyLeft',
		          'CTRL+SHIFT+E': 'justifyCenter',
		          'CTRL+SHIFT+R': 'justifyRight',
		          'CTRL+SHIFT+J': 'justifyFull',
		          'CTRL+SHIFT+NUM7': 'insertUnorderedList',
		          'CTRL+SHIFT+NUM8': 'insertOrderedList',
		          'CTRL+LEFTBRACKET': 'outdent',
		          'CTRL+RIGHTBRACKET': 'indent',
		          'CTRL+NUM0': 'formatPara',
		          'CTRL+NUM1': 'formatH1',
		          'CTRL+NUM2': 'formatH2',
		          'CTRL+NUM3': 'formatH3',
		          'CTRL+NUM4': 'formatH4',
		          'CTRL+NUM5': 'formatH5',
		          'CTRL+NUM6': 'formatH6',
		          'CTRL+ENTER': 'insertHorizontalRule',
		          'CTRL+K': 'linkDialog.show'
		        },

		        mac: {
		          'ENTER': 'insertParagraph',
		          'CMD+Z': 'undo',
		          'CMD+SHIFT+Z': 'redo',
		          'TAB': 'tab',
		          'SHIFT+TAB': 'untab',
		          'CMD+B': 'bold',
		          'CMD+I': 'italic',
		          'CMD+U': 'underline',
		          'CMD+SHIFT+S': 'strikethrough',
		          'CMD+BACKSLASH': 'removeFormat',
		          'CMD+SHIFT+L': 'justifyLeft',
		          'CMD+SHIFT+E': 'justifyCenter',
		          'CMD+SHIFT+R': 'justifyRight',
		          'CMD+SHIFT+J': 'justifyFull',
		          'CMD+SHIFT+NUM7': 'insertUnorderedList',
		          'CMD+SHIFT+NUM8': 'insertOrderedList',
		          'CMD+LEFTBRACKET': 'outdent',
		          'CMD+RIGHTBRACKET': 'indent',
		          'CMD+NUM0': 'formatPara',
		          'CMD+NUM1': 'formatH1',
		          'CMD+NUM2': 'formatH2',
		          'CMD+NUM3': 'formatH3',
		          'CMD+NUM4': 'formatH4',
		          'CMD+NUM5': 'formatH5',
		          'CMD+NUM6': 'formatH6',
		          'CMD+ENTER': 'insertHorizontalRule',
		          'CMD+K': 'linkDialog.show'
		        }
		      },
		      icons: {
		        'align': 'note-icon-align',
		        'alignCenter': 'note-icon-align-center',
		        'alignJustify': 'note-icon-align-justify',
		        'alignLeft': 'note-icon-align-left',
		        'alignRight': 'note-icon-align-right',
		        'indent': 'note-icon-align-indent',
		        'outdent': 'note-icon-align-outdent',
		        'arrowsAlt': 'note-icon-arrows-alt',
		        'bold': 'note-icon-bold',
		        'caret': 'note-icon-caret',
		        'circle': 'note-icon-circle',
		        'close': 'note-icon-close',
		        'code': 'note-icon-code',
		        'eraser': 'note-icon-eraser',
		        'font': 'note-icon-font',
		        'frame': 'note-icon-frame',
		        'italic': 'note-icon-italic',
		        'link': 'note-icon-link',
		        'unlink': 'note-icon-chain-broken',
		        'magic': 'note-icon-magic',
		        'menuCheck': 'note-icon-check',
		        'minus': 'note-icon-minus',
		        'orderedlist': 'note-icon-orderedlist',
		        'pencil': 'note-icon-pencil',
		        'picture': 'note-icon-picture',
		        'question': 'note-icon-question',
		        'redo': 'note-icon-redo',
		        'square': 'note-icon-square',
		        'strikethrough': 'note-icon-strikethrough',
		        'subscript': 'note-icon-subscript',
		        'superscript': 'note-icon-superscript',
		        'table': 'note-icon-table',
		        'textHeight': 'note-icon-text-height',
		        'trash': 'note-icon-trash',
		        'underline': 'note-icon-underline',
		        'undo': 'note-icon-undo',
		        'unorderedlist': 'note-icon-unorderedlist',
		        'video': 'note-icon-video'
		      }
		    }
		  });

		}));


	/***/ },
	/* 3 */
	/***/ function(module, exports) {

		/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

		/* WEBPACK VAR INJECTION */}.call(exports, {}))

	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE

		// This is CodeMirror (http://codemirror.net), a code editor
		// implemented in JavaScript on top of the browser's DOM.
		//
		// You can find some technical background for some of the code below
		// at http://marijnhaverbeke.nl/blog/#cm-internals .

		(function (global, factory) {
		  true ? module.exports = factory() :
		  typeof define === 'function' && define.amd ? define(factory) :
		  (global.CodeMirror = factory());
		}(this, (function () { 'use strict';

		// Kludges for bugs and behavior differences that can't be feature
		// detected are enabled based on userAgent etc sniffing.
		var userAgent = navigator.userAgent
		var platform = navigator.platform

		var gecko = /gecko\/\d/i.test(userAgent)
		var ie_upto10 = /MSIE \d/.test(userAgent)
		var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent)
		var ie = ie_upto10 || ie_11up
		var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1])
		var webkit = /WebKit\//.test(userAgent)
		var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent)
		var chrome = /Chrome\//.test(userAgent)
		var presto = /Opera\//.test(userAgent)
		var safari = /Apple Computer/.test(navigator.vendor)
		var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent)
		var phantom = /PhantomJS/.test(userAgent)

		var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent)
		// This is woefully incomplete. Suggestions for alternative methods welcome.
		var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent)
		var mac = ios || /Mac/.test(platform)
		var chromeOS = /\bCrOS\b/.test(userAgent)
		var windows = /win/i.test(platform)

		var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/)
		if (presto_version) { presto_version = Number(presto_version[1]) }
		if (presto_version && presto_version >= 15) { presto = false; webkit = true }
		// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
		var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11))
		var captureRightClick = gecko || (ie && ie_version >= 9)

		function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

		var rmClass = function(node, cls) {
		  var current = node.className
		  var match = classTest(cls).exec(current)
		  if (match) {
		    var after = current.slice(match.index + match[0].length)
		    node.className = current.slice(0, match.index) + (after ? match[1] + after : "")
		  }
		}

		function removeChildren(e) {
		  for (var count = e.childNodes.length; count > 0; --count)
		    { e.removeChild(e.firstChild) }
		  return e
		}

		function removeChildrenAndAdd(parent, e) {
		  return removeChildren(parent).appendChild(e)
		}

		function elt(tag, content, className, style) {
		  var e = document.createElement(tag)
		  if (className) { e.className = className }
		  if (style) { e.style.cssText = style }
		  if (typeof content == "string") { e.appendChild(document.createTextNode(content)) }
		  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]) } }
		  return e
		}

		var range
		if (document.createRange) { range = function(node, start, end, endNode) {
		  var r = document.createRange()
		  r.setEnd(endNode || node, end)
		  r.setStart(node, start)
		  return r
		} }
		else { range = function(node, start, end) {
		  var r = document.body.createTextRange()
		  try { r.moveToElementText(node.parentNode) }
		  catch(e) { return r }
		  r.collapse(true)
		  r.moveEnd("character", end)
		  r.moveStart("character", start)
		  return r
		} }

		function contains(parent, child) {
		  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
		    { child = child.parentNode }
		  if (parent.contains)
		    { return parent.contains(child) }
		  do {
		    if (child.nodeType == 11) { child = child.host }
		    if (child == parent) { return true }
		  } while (child = child.parentNode)
		}

		function activeElt() {
		  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
		  // IE < 10 will throw when accessed while the page is loading or in an iframe.
		  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
		  var activeElement
		  try {
		    activeElement = document.activeElement
		  } catch(e) {
		    activeElement = document.body || null
		  }
		  while (activeElement && activeElement.root && activeElement.root.activeElement)
		    { activeElement = activeElement.root.activeElement }
		  return activeElement
		}

		function addClass(node, cls) {
		  var current = node.className
		  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls }
		}
		function joinClasses(a, b) {
		  var as = a.split(" ")
		  for (var i = 0; i < as.length; i++)
		    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i] } }
		  return b
		}

		var selectInput = function(node) { node.select() }
		if (ios) // Mobile Safari apparently has a bug where select() is broken.
		  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length } }
		else if (ie) // Suppress mysterious IE10 errors
		  { selectInput = function(node) { try { node.select() } catch(_e) {} } }

		function bind(f) {
		  var args = Array.prototype.slice.call(arguments, 1)
		  return function(){return f.apply(null, args)}
		}

		function copyObj(obj, target, overwrite) {
		  if (!target) { target = {} }
		  for (var prop in obj)
		    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
		      { target[prop] = obj[prop] } }
		  return target
		}

		// Counts the column offset in a string, taking tabs into account.
		// Used mostly to find indentation.
		function countColumn(string, end, tabSize, startIndex, startValue) {
		  if (end == null) {
		    end = string.search(/[^\s\u00a0]/)
		    if (end == -1) { end = string.length }
		  }
		  for (var i = startIndex || 0, n = startValue || 0;;) {
		    var nextTab = string.indexOf("\t", i)
		    if (nextTab < 0 || nextTab >= end)
		      { return n + (end - i) }
		    n += nextTab - i
		    n += tabSize - (n % tabSize)
		    i = nextTab + 1
		  }
		}

		function Delayed() {this.id = null}
		Delayed.prototype.set = function(ms, f) {
		  clearTimeout(this.id)
		  this.id = setTimeout(f, ms)
		}

		function indexOf(array, elt) {
		  for (var i = 0; i < array.length; ++i)
		    { if (array[i] == elt) { return i } }
		  return -1
		}

		// Number of pixels added to scroller and sizer to hide scrollbar
		var scrollerGap = 30

		// Returned or thrown by various protocols to signal 'I'm not
		// handling this'.
		var Pass = {toString: function(){return "CodeMirror.Pass"}}

		// Reused option objects for setSelection & friends
		var sel_dontScroll = {scroll: false};
		var sel_mouse = {origin: "*mouse"};
		var sel_move = {origin: "+move"};
		// The inverse of countColumn -- find the offset that corresponds to
		// a particular column.
		function findColumn(string, goal, tabSize) {
		  for (var pos = 0, col = 0;;) {
		    var nextTab = string.indexOf("\t", pos)
		    if (nextTab == -1) { nextTab = string.length }
		    var skipped = nextTab - pos
		    if (nextTab == string.length || col + skipped >= goal)
		      { return pos + Math.min(skipped, goal - col) }
		    col += nextTab - pos
		    col += tabSize - (col % tabSize)
		    pos = nextTab + 1
		    if (col >= goal) { return pos }
		  }
		}

		var spaceStrs = [""]
		function spaceStr(n) {
		  while (spaceStrs.length <= n)
		    { spaceStrs.push(lst(spaceStrs) + " ") }
		  return spaceStrs[n]
		}

		function lst(arr) { return arr[arr.length-1] }

		function map(array, f) {
		  var out = []
		  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i) }
		  return out
		}

		function insertSorted(array, value, score) {
		  var pos = 0, priority = score(value)
		  while (pos < array.length && score(array[pos]) <= priority) { pos++ }
		  array.splice(pos, 0, value)
		}

		function nothing() {}

		function createObj(base, props) {
		  var inst
		  if (Object.create) {
		    inst = Object.create(base)
		  } else {
		    nothing.prototype = base
		    inst = new nothing()
		  }
		  if (props) { copyObj(props, inst) }
		  return inst
		}

		var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
		function isWordCharBasic(ch) {
		  return /\w/.test(ch) || ch > "\x80" &&
		    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
		}
		function isWordChar(ch, helper) {
		  if (!helper) { return isWordCharBasic(ch) }
		  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
		  return helper.test(ch)
		}

		function isEmpty(obj) {
		  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
		  return true
		}

		// Extending unicode characters. A series of a non-extending char +
		// any number of extending chars is treated as a single unit as far
		// as editing and measuring is concerned. This is not fully correct,
		// since some scripts/fonts/browsers also treat other configurations
		// of code points as a group.
		var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/
		function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

		// The display handles the DOM integration, both for input reading
		// and content drawing. It holds references to DOM nodes and
		// display-related state.

		function Display(place, doc, input) {
		  var d = this
		  this.input = input

		  // Covers bottom-right square when both scrollbars are present.
		  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler")
		  d.scrollbarFiller.setAttribute("cm-not-content", "true")
		  // Covers bottom of gutter when coverGutterNextToScrollbar is on
		  // and h scrollbar is present.
		  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler")
		  d.gutterFiller.setAttribute("cm-not-content", "true")
		  // Will contain the actual code, positioned to cover the viewport.
		  d.lineDiv = elt("div", null, "CodeMirror-code")
		  // Elements are added to these to represent selection and cursors.
		  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1")
		  d.cursorDiv = elt("div", null, "CodeMirror-cursors")
		  // A visibility: hidden element used to find the size of things.
		  d.measure = elt("div", null, "CodeMirror-measure")
		  // When lines outside of the viewport are measured, they are drawn in this.
		  d.lineMeasure = elt("div", null, "CodeMirror-measure")
		  // Wraps everything that needs to exist inside the vertically-padded coordinate system
		  d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
		                    null, "position: relative; outline: none")
		  // Moved around its parent to cover visible view.
		  d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative")
		  // Set to the height of the document, allowing scrolling.
		  d.sizer = elt("div", [d.mover], "CodeMirror-sizer")
		  d.sizerWidth = null
		  // Behavior of elts with overflow: auto and padding is
		  // inconsistent across browsers. This is used to ensure the
		  // scrollable area is big enough.
		  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;")
		  // Will contain the gutters, if any.
		  d.gutters = elt("div", null, "CodeMirror-gutters")
		  d.lineGutter = null
		  // Actual scrollable element.
		  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll")
		  d.scroller.setAttribute("tabIndex", "-1")
		  // The element in which the editor lives.
		  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror")

		  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
		  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0 }
		  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true }

		  if (place) {
		    if (place.appendChild) { place.appendChild(d.wrapper) }
		    else { place(d.wrapper) }
		  }

		  // Current rendered range (may be bigger than the view window).
		  d.viewFrom = d.viewTo = doc.first
		  d.reportedViewFrom = d.reportedViewTo = doc.first
		  // Information about the rendered lines.
		  d.view = []
		  d.renderedView = null
		  // Holds info about a single rendered line when it was rendered
		  // for measurement, while not in view.
		  d.externalMeasured = null
		  // Empty space (in pixels) above the view
		  d.viewOffset = 0
		  d.lastWrapHeight = d.lastWrapWidth = 0
		  d.updateLineNumbers = null

		  d.nativeBarWidth = d.barHeight = d.barWidth = 0
		  d.scrollbarsClipped = false

		  // Used to only resize the line number gutter when necessary (when
		  // the amount of lines crosses a boundary that makes its width change)
		  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null
		  // Set to true when a non-horizontal-scrolling line widget is
		  // added. As an optimization, line widget aligning is skipped when
		  // this is false.
		  d.alignWidgets = false

		  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null

		  // Tracks the maximum line length so that the horizontal scrollbar
		  // can be kept static when scrolling.
		  d.maxLine = null
		  d.maxLineLength = 0
		  d.maxLineChanged = false

		  // Used for measuring wheel scrolling granularity
		  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null

		  // True when shift is held down.
		  d.shift = false

		  // Used to track whether anything happened since the context menu
		  // was opened.
		  d.selForContextMenu = null

		  d.activeTouch = null

		  input.init(d)
		}

		// Find the line object corresponding to the given line number.
		function getLine(doc, n) {
		  n -= doc.first
		  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
		  var chunk = doc
		  while (!chunk.lines) {
		    for (var i = 0;; ++i) {
		      var child = chunk.children[i], sz = child.chunkSize()
		      if (n < sz) { chunk = child; break }
		      n -= sz
		    }
		  }
		  return chunk.lines[n]
		}

		// Get the part of a document between two positions, as an array of
		// strings.
		function getBetween(doc, start, end) {
		  var out = [], n = start.line
		  doc.iter(start.line, end.line + 1, function (line) {
		    var text = line.text
		    if (n == end.line) { text = text.slice(0, end.ch) }
		    if (n == start.line) { text = text.slice(start.ch) }
		    out.push(text)
		    ++n
		  })
		  return out
		}
		// Get the lines between from and to, as array of strings.
		function getLines(doc, from, to) {
		  var out = []
		  doc.iter(from, to, function (line) { out.push(line.text) }) // iter aborts when callback returns truthy value
		  return out
		}

		// Update the height of a line, propagating the height change
		// upwards to parent nodes.
		function updateLineHeight(line, height) {
		  var diff = height - line.height
		  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff } }
		}

		// Given a line object, find its line number by walking up through
		// its parent links.
		function lineNo(line) {
		  if (line.parent == null) { return null }
		  var cur = line.parent, no = indexOf(cur.lines, line)
		  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
		    for (var i = 0;; ++i) {
		      if (chunk.children[i] == cur) { break }
		      no += chunk.children[i].chunkSize()
		    }
		  }
		  return no + cur.first
		}

		// Find the line at the given vertical position, using the height
		// information in the document tree.
		function lineAtHeight(chunk, h) {
		  var n = chunk.first
		  outer: do {
		    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
		      var child = chunk.children[i$1], ch = child.height
		      if (h < ch) { chunk = child; continue outer }
		      h -= ch
		      n += child.chunkSize()
		    }
		    return n
		  } while (!chunk.lines)
		  var i = 0
		  for (; i < chunk.lines.length; ++i) {
		    var line = chunk.lines[i], lh = line.height
		    if (h < lh) { break }
		    h -= lh
		  }
		  return n + i
		}

		function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

		function lineNumberFor(options, i) {
		  return String(options.lineNumberFormatter(i + options.firstLineNumber))
		}

		// A Pos instance represents a position within the text.
		function Pos (line, ch) {
		  if (!(this instanceof Pos)) { return new Pos(line, ch) }
		  this.line = line; this.ch = ch
		}

		// Compare two positions, return 0 if they are the same, a negative
		// number when a is less, and a positive number otherwise.
		function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

		function copyPos(x) {return Pos(x.line, x.ch)}
		function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
		function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

		// Most of the external API clips given positions to make sure they
		// actually exist within the document.
		function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
		function clipPos(doc, pos) {
		  if (pos.line < doc.first) { return Pos(doc.first, 0) }
		  var last = doc.first + doc.size - 1
		  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
		  return clipToLen(pos, getLine(doc, pos.line).text.length)
		}
		function clipToLen(pos, linelen) {
		  var ch = pos.ch
		  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
		  else if (ch < 0) { return Pos(pos.line, 0) }
		  else { return pos }
		}
		function clipPosArray(doc, array) {
		  var out = []
		  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]) }
		  return out
		}

		// Optimize some code when these features are not used.
		var sawReadOnlySpans = false;
		var sawCollapsedSpans = false;
		function seeReadOnlySpans() {
		  sawReadOnlySpans = true
		}

		function seeCollapsedSpans() {
		  sawCollapsedSpans = true
		}

		// TEXTMARKER SPANS

		function MarkedSpan(marker, from, to) {
		  this.marker = marker
		  this.from = from; this.to = to
		}

		// Search an array of spans for a span matching the given marker.
		function getMarkedSpanFor(spans, marker) {
		  if (spans) { for (var i = 0; i < spans.length; ++i) {
		    var span = spans[i]
		    if (span.marker == marker) { return span }
		  } }
		}
		// Remove a span from an array, returning undefined if no spans are
		// left (we don't store arrays for lines without spans).
		function removeMarkedSpan(spans, span) {
		  var r
		  for (var i = 0; i < spans.length; ++i)
		    { if (spans[i] != span) { (r || (r = [])).push(spans[i]) } }
		  return r
		}
		// Add a span to a line.
		function addMarkedSpan(line, span) {
		  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span]
		  span.marker.attachLine(line)
		}

		// Used for the algorithm that adjusts markers for a change in the
		// document. These functions cut an array of spans at a given
		// character position, returning an array of remaining chunks (or
		// undefined if nothing remains).
		function markedSpansBefore(old, startCh, isInsert) {
		  var nw
		  if (old) { for (var i = 0; i < old.length; ++i) {
		    var span = old[i], marker = span.marker
		    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh)
		    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
		      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
		      ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))
		    }
		  } }
		  return nw
		}
		function markedSpansAfter(old, endCh, isInsert) {
		  var nw
		  if (old) { for (var i = 0; i < old.length; ++i) {
		    var span = old[i], marker = span.marker
		    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)
		    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
		      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
		      ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
		                                            span.to == null ? null : span.to - endCh))
		    }
		  } }
		  return nw
		}

		// Given a change object, compute the new set of marker spans that
		// cover the line in which the change took place. Removes spans
		// entirely within the change, reconnects spans belonging to the
		// same marker that appear on both sides of the change, and cuts off
		// spans partially within the change. Returns an array of span
		// arrays with one element for each line in (after) the change.
		function stretchSpansOverChange(doc, change) {
		  if (change.full) { return null }
		  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans
		  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans
		  if (!oldFirst && !oldLast) { return null }

		  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0
		  // Get the spans that 'stick out' on both sides
		  var first = markedSpansBefore(oldFirst, startCh, isInsert)
		  var last = markedSpansAfter(oldLast, endCh, isInsert)

		  // Next, merge those two ends
		  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0)
		  if (first) {
		    // Fix up .to properties of first
		    for (var i = 0; i < first.length; ++i) {
		      var span = first[i]
		      if (span.to == null) {
		        var found = getMarkedSpanFor(last, span.marker)
		        if (!found) { span.to = startCh }
		        else if (sameLine) { span.to = found.to == null ? null : found.to + offset }
		      }
		    }
		  }
		  if (last) {
		    // Fix up .from in last (or move them into first in case of sameLine)
		    for (var i$1 = 0; i$1 < last.length; ++i$1) {
		      var span$1 = last[i$1]
		      if (span$1.to != null) { span$1.to += offset }
		      if (span$1.from == null) {
		        var found$1 = getMarkedSpanFor(first, span$1.marker)
		        if (!found$1) {
		          span$1.from = offset
		          if (sameLine) { (first || (first = [])).push(span$1) }
		        }
		      } else {
		        span$1.from += offset
		        if (sameLine) { (first || (first = [])).push(span$1) }
		      }
		    }
		  }
		  // Make sure we didn't create any zero-length spans
		  if (first) { first = clearEmptySpans(first) }
		  if (last && last != first) { last = clearEmptySpans(last) }

		  var newMarkers = [first]
		  if (!sameLine) {
		    // Fill gap with whole-line-spans
		    var gap = change.text.length - 2, gapMarkers
		    if (gap > 0 && first)
		      { for (var i$2 = 0; i$2 < first.length; ++i$2)
		        { if (first[i$2].to == null)
		          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)) } } }
		    for (var i$3 = 0; i$3 < gap; ++i$3)
		      { newMarkers.push(gapMarkers) }
		    newMarkers.push(last)
		  }
		  return newMarkers
		}

		// Remove spans that are empty and don't have a clearWhenEmpty
		// option of false.
		function clearEmptySpans(spans) {
		  for (var i = 0; i < spans.length; ++i) {
		    var span = spans[i]
		    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
		      { spans.splice(i--, 1) }
		  }
		  if (!spans.length) { return null }
		  return spans
		}

		// Used to 'clip' out readOnly ranges when making a change.
		function removeReadOnlyRanges(doc, from, to) {
		  var markers = null
		  doc.iter(from.line, to.line + 1, function (line) {
		    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
		      var mark = line.markedSpans[i].marker
		      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
		        { (markers || (markers = [])).push(mark) }
		    } }
		  })
		  if (!markers) { return null }
		  var parts = [{from: from, to: to}]
		  for (var i = 0; i < markers.length; ++i) {
		    var mk = markers[i], m = mk.find(0)
		    for (var j = 0; j < parts.length; ++j) {
		      var p = parts[j]
		      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
		      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to)
		      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
		        { newParts.push({from: p.from, to: m.from}) }
		      if (dto > 0 || !mk.inclusiveRight && !dto)
		        { newParts.push({from: m.to, to: p.to}) }
		      parts.splice.apply(parts, newParts)
		      j += newParts.length - 1
		    }
		  }
		  return parts
		}

		// Connect or disconnect spans from a line.
		function detachMarkedSpans(line) {
		  var spans = line.markedSpans
		  if (!spans) { return }
		  for (var i = 0; i < spans.length; ++i)
		    { spans[i].marker.detachLine(line) }
		  line.markedSpans = null
		}
		function attachMarkedSpans(line, spans) {
		  if (!spans) { return }
		  for (var i = 0; i < spans.length; ++i)
		    { spans[i].marker.attachLine(line) }
		  line.markedSpans = spans
		}

		// Helpers used when computing which overlapping collapsed span
		// counts as the larger one.
		function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
		function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

		// Returns a number indicating which of two overlapping collapsed
		// spans is larger (and thus includes the other). Falls back to
		// comparing ids when the spans cover exactly the same range.
		function compareCollapsedMarkers(a, b) {
		  var lenDiff = a.lines.length - b.lines.length
		  if (lenDiff != 0) { return lenDiff }
		  var aPos = a.find(), bPos = b.find()
		  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)
		  if (fromCmp) { return -fromCmp }
		  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)
		  if (toCmp) { return toCmp }
		  return b.id - a.id
		}

		// Find out whether a line ends or starts in a collapsed span. If
		// so, return the marker for that span.
		function collapsedSpanAtSide(line, start) {
		  var sps = sawCollapsedSpans && line.markedSpans, found
		  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
		    sp = sps[i]
		    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
		        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
		      { found = sp.marker }
		  } }
		  return found
		}
		function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
		function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

		// Test whether there exists a collapsed span that partially
		// overlaps (covers the start or end, but not both) of a new span.
		// Such overlap is not allowed.
		function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
		  var line = getLine(doc, lineNo)
		  var sps = sawCollapsedSpans && line.markedSpans
		  if (sps) { for (var i = 0; i < sps.length; ++i) {
		    var sp = sps[i]
		    if (!sp.marker.collapsed) { continue }
		    var found = sp.marker.find(0)
		    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)
		    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)
		    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
		    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
		        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
		      { return true }
		  } }
		}

		// A visual line is a line as drawn on the screen. Folding, for
		// example, can cause multiple logical lines to appear on the same
		// visual line. This finds the start of the visual line that the
		// given line is part of (usually that is the line itself).
		function visualLine(line) {
		  var merged
		  while (merged = collapsedSpanAtStart(line))
		    { line = merged.find(-1, true).line }
		  return line
		}

		// Returns an array of logical lines that continue the visual line
		// started by the argument, or undefined if there are no such lines.
		function visualLineContinued(line) {
		  var merged, lines
		  while (merged = collapsedSpanAtEnd(line)) {
		    line = merged.find(1, true).line
		    ;(lines || (lines = [])).push(line)
		  }
		  return lines
		}

		// Get the line number of the start of the visual line that the
		// given line number is part of.
		function visualLineNo(doc, lineN) {
		  var line = getLine(doc, lineN), vis = visualLine(line)
		  if (line == vis) { return lineN }
		  return lineNo(vis)
		}

		// Get the line number of the start of the next visual line after
		// the given line.
		function visualLineEndNo(doc, lineN) {
		  if (lineN > doc.lastLine()) { return lineN }
		  var line = getLine(doc, lineN), merged
		  if (!lineIsHidden(doc, line)) { return lineN }
		  while (merged = collapsedSpanAtEnd(line))
		    { line = merged.find(1, true).line }
		  return lineNo(line) + 1
		}

		// Compute whether a line is hidden. Lines count as hidden when they
		// are part of a visual line that starts with another line, or when
		// they are entirely covered by collapsed, non-widget span.
		function lineIsHidden(doc, line) {
		  var sps = sawCollapsedSpans && line.markedSpans
		  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
		    sp = sps[i]
		    if (!sp.marker.collapsed) { continue }
		    if (sp.from == null) { return true }
		    if (sp.marker.widgetNode) { continue }
		    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
		      { return true }
		  } }
		}
		function lineIsHiddenInner(doc, line, span) {
		  if (span.to == null) {
		    var end = span.marker.find(1, true)
		    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
		  }
		  if (span.marker.inclusiveRight && span.to == line.text.length)
		    { return true }
		  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
		    sp = line.markedSpans[i]
		    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
		        (sp.to == null || sp.to != span.from) &&
		        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
		        lineIsHiddenInner(doc, line, sp)) { return true }
		  }
		}

		// Find the height above the given line.
		function heightAtLine(lineObj) {
		  lineObj = visualLine(lineObj)

		  var h = 0, chunk = lineObj.parent
		  for (var i = 0; i < chunk.lines.length; ++i) {
		    var line = chunk.lines[i]
		    if (line == lineObj) { break }
		    else { h += line.height }
		  }
		  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
		    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
		      var cur = p.children[i$1]
		      if (cur == chunk) { break }
		      else { h += cur.height }
		    }
		  }
		  return h
		}

		// Compute the character length of a line, taking into account
		// collapsed ranges (see markText) that might hide parts, and join
		// other lines onto it.
		function lineLength(line) {
		  if (line.height == 0) { return 0 }
		  var len = line.text.length, merged, cur = line
		  while (merged = collapsedSpanAtStart(cur)) {
		    var found = merged.find(0, true)
		    cur = found.from.line
		    len += found.from.ch - found.to.ch
		  }
		  cur = line
		  while (merged = collapsedSpanAtEnd(cur)) {
		    var found$1 = merged.find(0, true)
		    len -= cur.text.length - found$1.from.ch
		    cur = found$1.to.line
		    len += cur.text.length - found$1.to.ch
		  }
		  return len
		}

		// Find the longest line in the document.
		function findMaxLine(cm) {
		  var d = cm.display, doc = cm.doc
		  d.maxLine = getLine(doc, doc.first)
		  d.maxLineLength = lineLength(d.maxLine)
		  d.maxLineChanged = true
		  doc.iter(function (line) {
		    var len = lineLength(line)
		    if (len > d.maxLineLength) {
		      d.maxLineLength = len
		      d.maxLine = line
		    }
		  })
		}

		// BIDI HELPERS

		function iterateBidiSections(order, from, to, f) {
		  if (!order) { return f(from, to, "ltr") }
		  var found = false
		  for (var i = 0; i < order.length; ++i) {
		    var part = order[i]
		    if (part.from < to && part.to > from || from == to && part.to == from) {
		      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr")
		      found = true
		    }
		  }
		  if (!found) { f(from, to, "ltr") }
		}

		function bidiLeft(part) { return part.level % 2 ? part.to : part.from }
		function bidiRight(part) { return part.level % 2 ? part.from : part.to }

		function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0 }
		function lineRight(line) {
		  var order = getOrder(line)
		  if (!order) { return line.text.length }
		  return bidiRight(lst(order))
		}

		function compareBidiLevel(order, a, b) {
		  var linedir = order[0].level
		  if (a == linedir) { return true }
		  if (b == linedir) { return false }
		  return a < b
		}

		var bidiOther = null
		function getBidiPartAt(order, pos) {
		  var found
		  bidiOther = null
		  for (var i = 0; i < order.length; ++i) {
		    var cur = order[i]
		    if (cur.from < pos && cur.to > pos) { return i }
		    if ((cur.from == pos || cur.to == pos)) {
		      if (found == null) {
		        found = i
		      } else if (compareBidiLevel(order, cur.level, order[found].level)) {
		        if (cur.from != cur.to) { bidiOther = found }
		        return i
		      } else {
		        if (cur.from != cur.to) { bidiOther = i }
		        return found
		      }
		    }
		  }
		  return found
		}

		function moveInLine(line, pos, dir, byUnit) {
		  if (!byUnit) { return pos + dir }
		  do { pos += dir }
		  while (pos > 0 && isExtendingChar(line.text.charAt(pos)))
		  return pos
		}

		// This is needed in order to move 'visually' through bi-directional
		// text -- i.e., pressing left should make the cursor go left, even
		// when in RTL text. The tricky part is the 'jumps', where RTL and
		// LTR text touch each other. This often requires the cursor offset
		// to move more than one unit, in order to visually move one unit.
		function moveVisually(line, start, dir, byUnit) {
		  var bidi = getOrder(line)
		  if (!bidi) { return moveLogically(line, start, dir, byUnit) }
		  var pos = getBidiPartAt(bidi, start), part = bidi[pos]
		  var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit)

		  for (;;) {
		    if (target > part.from && target < part.to) { return target }
		    if (target == part.from || target == part.to) {
		      if (getBidiPartAt(bidi, target) == pos) { return target }
		      part = bidi[pos += dir]
		      return (dir > 0) == part.level % 2 ? part.to : part.from
		    } else {
		      part = bidi[pos += dir]
		      if (!part) { return null }
		      if ((dir > 0) == part.level % 2)
		        { target = moveInLine(line, part.to, -1, byUnit) }
		      else
		        { target = moveInLine(line, part.from, 1, byUnit) }
		    }
		  }
		}

		function moveLogically(line, start, dir, byUnit) {
		  var target = start + dir
		  if (byUnit) { while (target > 0 && isExtendingChar(line.text.charAt(target))) { target += dir } }
		  return target < 0 || target > line.text.length ? null : target
		}

		// Bidirectional ordering algorithm
		// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
		// that this (partially) implements.

		// One-char codes used for character types:
		// L (L):   Left-to-Right
		// R (R):   Right-to-Left
		// r (AL):  Right-to-Left Arabic
		// 1 (EN):  European Number
		// + (ES):  European Number Separator
		// % (ET):  European Number Terminator
		// n (AN):  Arabic Number
		// , (CS):  Common Number Separator
		// m (NSM): Non-Spacing Mark
		// b (BN):  Boundary Neutral
		// s (B):   Paragraph Separator
		// t (S):   Segment Separator
		// w (WS):  Whitespace
		// N (ON):  Other Neutrals

		// Returns null if characters are ordered as they appear
		// (left-to-right), or an array of sections ({from, to, level}
		// objects) in the order in which they occur visually.
		var bidiOrdering = (function() {
		  // Character types for codepoints 0 to 0xff
		  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"
		  // Character types for codepoints 0x600 to 0x6f9
		  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111"
		  function charType(code) {
		    if (code <= 0xf7) { return lowTypes.charAt(code) }
		    else if (0x590 <= code && code <= 0x5f4) { return "R" }
		    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
		    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
		    else if (0x2000 <= code && code <= 0x200b) { return "w" }
		    else if (code == 0x200c) { return "b" }
		    else { return "L" }
		  }

		  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
		  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/
		  // Browsers seem to always treat the boundaries of block elements as being L.
		  var outerType = "L"

		  function BidiSpan(level, from, to) {
		    this.level = level
		    this.from = from; this.to = to
		  }

		  return function(str) {
		    if (!bidiRE.test(str)) { return false }
		    var len = str.length, types = []
		    for (var i = 0; i < len; ++i)
		      { types.push(charType(str.charCodeAt(i))) }

		    // W1. Examine each non-spacing mark (NSM) in the level run, and
		    // change the type of the NSM to the type of the previous
		    // character. If the NSM is at the start of the level run, it will
		    // get the type of sor.
		    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
		      var type = types[i$1]
		      if (type == "m") { types[i$1] = prev }
		      else { prev = type }
		    }

		    // W2. Search backwards from each instance of a European number
		    // until the first strong type (R, L, AL, or sor) is found. If an
		    // AL is found, change the type of the European number to Arabic
		    // number.
		    // W3. Change all ALs to R.
		    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
		      var type$1 = types[i$2]
		      if (type$1 == "1" && cur == "r") { types[i$2] = "n" }
		      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R" } }
		    }

		    // W4. A single European separator between two European numbers
		    // changes to a European number. A single common separator between
		    // two numbers of the same type changes to that type.
		    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
		      var type$2 = types[i$3]
		      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1" }
		      else if (type$2 == "," && prev$1 == types[i$3+1] &&
		               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1 }
		      prev$1 = type$2
		    }

		    // W5. A sequence of European terminators adjacent to European
		    // numbers changes to all European numbers.
		    // W6. Otherwise, separators and terminators change to Other
		    // Neutral.
		    for (var i$4 = 0; i$4 < len; ++i$4) {
		      var type$3 = types[i$4]
		      if (type$3 == ",") { types[i$4] = "N" }
		      else if (type$3 == "%") {
		        var end = (void 0)
		        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
		        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N"
		        for (var j = i$4; j < end; ++j) { types[j] = replace }
		        i$4 = end - 1
		      }
		    }

		    // W7. Search backwards from each instance of a European number
		    // until the first strong type (R, L, or sor) is found. If an L is
		    // found, then change the type of the European number to L.
		    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
		      var type$4 = types[i$5]
		      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L" }
		      else if (isStrong.test(type$4)) { cur$1 = type$4 }
		    }

		    // N1. A sequence of neutrals takes the direction of the
		    // surrounding strong text if the text on both sides has the same
		    // direction. European and Arabic numbers act as if they were R in
		    // terms of their influence on neutrals. Start-of-level-run (sor)
		    // and end-of-level-run (eor) are used at level run boundaries.
		    // N2. Any remaining neutrals take the embedding direction.
		    for (var i$6 = 0; i$6 < len; ++i$6) {
		      if (isNeutral.test(types[i$6])) {
		        var end$1 = (void 0)
		        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
		        var before = (i$6 ? types[i$6-1] : outerType) == "L"
		        var after = (end$1 < len ? types[end$1] : outerType) == "L"
		        var replace$1 = before || after ? "L" : "R"
		        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1 }
		        i$6 = end$1 - 1
		      }
		    }

		    // Here we depart from the documented algorithm, in order to avoid
		    // building up an actual levels array. Since there are only three
		    // levels (0, 1, 2) in an implementation that doesn't take
		    // explicit embedding into account, we can build up the order on
		    // the fly, without following the level-based algorithm.
		    var order = [], m
		    for (var i$7 = 0; i$7 < len;) {
		      if (countsAsLeft.test(types[i$7])) {
		        var start = i$7
		        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
		        order.push(new BidiSpan(0, start, i$7))
		      } else {
		        var pos = i$7, at = order.length
		        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
		        for (var j$2 = pos; j$2 < i$7;) {
		          if (countsAsNum.test(types[j$2])) {
		            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)) }
		            var nstart = j$2
		            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
		            order.splice(at, 0, new BidiSpan(2, nstart, j$2))
		            pos = j$2
		          } else { ++j$2 }
		        }
		        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)) }
		      }
		    }
		    if (order[0].level == 1 && (m = str.match(/^\s+/))) {
		      order[0].from = m[0].length
		      order.unshift(new BidiSpan(0, 0, m[0].length))
		    }
		    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
		      lst(order).to -= m[0].length
		      order.push(new BidiSpan(0, len - m[0].length, len))
		    }
		    if (order[0].level == 2)
		      { order.unshift(new BidiSpan(1, order[0].to, order[0].to)) }
		    if (order[0].level != lst(order).level)
		      { order.push(new BidiSpan(order[0].level, len, len)) }

		    return order
		  }
		})()

		// Get the bidi ordering for the given line (and cache it). Returns
		// false for lines that are fully left-to-right, and an array of
		// BidiSpan objects otherwise.
		function getOrder(line) {
		  var order = line.order
		  if (order == null) { order = line.order = bidiOrdering(line.text) }
		  return order
		}

		// EVENT HANDLING

		// Lightweight event framework. on/off also work on DOM nodes,
		// registering native DOM handlers.

		var noHandlers = []

		var on = function(emitter, type, f) {
		  if (emitter.addEventListener) {
		    emitter.addEventListener(type, f, false)
		  } else if (emitter.attachEvent) {
		    emitter.attachEvent("on" + type, f)
		  } else {
		    var map = emitter._handlers || (emitter._handlers = {})
		    map[type] = (map[type] || noHandlers).concat(f)
		  }
		}

		function getHandlers(emitter, type) {
		  return emitter._handlers && emitter._handlers[type] || noHandlers
		}

		function off(emitter, type, f) {
		  if (emitter.removeEventListener) {
		    emitter.removeEventListener(type, f, false)
		  } else if (emitter.detachEvent) {
		    emitter.detachEvent("on" + type, f)
		  } else {
		    var map = emitter._handlers, arr = map && map[type]
		    if (arr) {
		      var index = indexOf(arr, f)
		      if (index > -1)
		        { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)) }
		    }
		  }
		}

		function signal(emitter, type /*, values...*/) {
		  var handlers = getHandlers(emitter, type)
		  if (!handlers.length) { return }
		  var args = Array.prototype.slice.call(arguments, 2)
		  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args) }
		}

		// The DOM events that CodeMirror handles can be overridden by
		// registering a (non-DOM) handler on the editor for the event name,
		// and preventDefault-ing the event in that handler.
		function signalDOMEvent(cm, e, override) {
		  if (typeof e == "string")
		    { e = {type: e, preventDefault: function() { this.defaultPrevented = true }} }
		  signal(cm, override || e.type, cm, e)
		  return e_defaultPrevented(e) || e.codemirrorIgnore
		}

		function signalCursorActivity(cm) {
		  var arr = cm._handlers && cm._handlers.cursorActivity
		  if (!arr) { return }
		  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = [])
		  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
		    { set.push(arr[i]) } }
		}

		function hasHandler(emitter, type) {
		  return getHandlers(emitter, type).length > 0
		}

		// Add on and off methods to a constructor's prototype, to make
		// registering events on such objects more convenient.
		function eventMixin(ctor) {
		  ctor.prototype.on = function(type, f) {on(this, type, f)}
		  ctor.prototype.off = function(type, f) {off(this, type, f)}
		}

		// Due to the fact that we still support jurassic IE versions, some
		// compatibility wrappers are needed.

		function e_preventDefault(e) {
		  if (e.preventDefault) { e.preventDefault() }
		  else { e.returnValue = false }
		}
		function e_stopPropagation(e) {
		  if (e.stopPropagation) { e.stopPropagation() }
		  else { e.cancelBubble = true }
		}
		function e_defaultPrevented(e) {
		  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
		}
		function e_stop(e) {e_preventDefault(e); e_stopPropagation(e)}

		function e_target(e) {return e.target || e.srcElement}
		function e_button(e) {
		  var b = e.which
		  if (b == null) {
		    if (e.button & 1) { b = 1 }
		    else if (e.button & 2) { b = 3 }
		    else if (e.button & 4) { b = 2 }
		  }
		  if (mac && e.ctrlKey && b == 1) { b = 3 }
		  return b
		}

		// Detect drag-and-drop
		var dragAndDrop = function() {
		  // There is *some* kind of drag-and-drop support in IE6-8, but I
		  // couldn't get it to work yet.
		  if (ie && ie_version < 9) { return false }
		  var div = elt('div')
		  return "draggable" in div || "dragDrop" in div
		}()

		var zwspSupported
		function zeroWidthElement(measure) {
		  if (zwspSupported == null) {
		    var test = elt("span", "\u200b")
		    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]))
		    if (measure.firstChild.offsetHeight != 0)
		      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8) }
		  }
		  var node = zwspSupported ? elt("span", "\u200b") :
		    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px")
		  node.setAttribute("cm-text", "")
		  return node
		}

		// Feature-detect IE's crummy client rect reporting for bidi text
		var badBidiRects
		function hasBadBidiRects(measure) {
		  if (badBidiRects != null) { return badBidiRects }
		  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"))
		  var r0 = range(txt, 0, 1).getBoundingClientRect()
		  var r1 = range(txt, 1, 2).getBoundingClientRect()
		  removeChildren(measure)
		  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
		  return badBidiRects = (r1.right - r0.right < 3)
		}

		// See if "".split is the broken IE version, if so, provide an
		// alternative way to split lines.
		var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
		  var pos = 0, result = [], l = string.length
		  while (pos <= l) {
		    var nl = string.indexOf("\n", pos)
		    if (nl == -1) { nl = string.length }
		    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl)
		    var rt = line.indexOf("\r")
		    if (rt != -1) {
		      result.push(line.slice(0, rt))
		      pos += rt + 1
		    } else {
		      result.push(line)
		      pos = nl + 1
		    }
		  }
		  return result
		} : function (string) { return string.split(/\r\n?|\n/); }

		var hasSelection = window.getSelection ? function (te) {
		  try { return te.selectionStart != te.selectionEnd }
		  catch(e) { return false }
		} : function (te) {
		  var range
		  try {range = te.ownerDocument.selection.createRange()}
		  catch(e) {}
		  if (!range || range.parentElement() != te) { return false }
		  return range.compareEndPoints("StartToEnd", range) != 0
		}

		var hasCopyEvent = (function () {
		  var e = elt("div")
		  if ("oncopy" in e) { return true }
		  e.setAttribute("oncopy", "return;")
		  return typeof e.oncopy == "function"
		})()

		var badZoomedRects = null
		function hasBadZoomedRects(measure) {
		  if (badZoomedRects != null) { return badZoomedRects }
		  var node = removeChildrenAndAdd(measure, elt("span", "x"))
		  var normal = node.getBoundingClientRect()
		  var fromRange = range(node, 0, 1).getBoundingClientRect()
		  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
		}

		var modes = {};
		var mimeModes = {};
		// Extra arguments are stored as the mode's dependencies, which is
		// used by (legacy) mechanisms like loadmode.js to automatically
		// load a mode. (Preferred mechanism is the require/define calls.)
		function defineMode(name, mode) {
		  if (arguments.length > 2)
		    { mode.dependencies = Array.prototype.slice.call(arguments, 2) }
		  modes[name] = mode
		}

		function defineMIME(mime, spec) {
		  mimeModes[mime] = spec
		}

		// Given a MIME type, a {name, ...options} config object, or a name
		// string, return a mode config object.
		function resolveMode(spec) {
		  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
		    spec = mimeModes[spec]
		  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
		    var found = mimeModes[spec.name]
		    if (typeof found == "string") { found = {name: found} }
		    spec = createObj(found, spec)
		    spec.name = found.name
		  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
		    return resolveMode("application/xml")
		  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
		    return resolveMode("application/json")
		  }
		  if (typeof spec == "string") { return {name: spec} }
		  else { return spec || {name: "null"} }
		}

		// Given a mode spec (anything that resolveMode accepts), find and
		// initialize an actual mode object.
		function getMode(options, spec) {
		  spec = resolveMode(spec)
		  var mfactory = modes[spec.name]
		  if (!mfactory) { return getMode(options, "text/plain") }
		  var modeObj = mfactory(options, spec)
		  if (modeExtensions.hasOwnProperty(spec.name)) {
		    var exts = modeExtensions[spec.name]
		    for (var prop in exts) {
		      if (!exts.hasOwnProperty(prop)) { continue }
		      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop] }
		      modeObj[prop] = exts[prop]
		    }
		  }
		  modeObj.name = spec.name
		  if (spec.helperType) { modeObj.helperType = spec.helperType }
		  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
		    { modeObj[prop$1] = spec.modeProps[prop$1] } }

		  return modeObj
		}

		// This can be used to attach properties to mode objects from
		// outside the actual mode definition.
		var modeExtensions = {}
		function extendMode(mode, properties) {
		  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {})
		  copyObj(properties, exts)
		}

		function copyState(mode, state) {
		  if (state === true) { return state }
		  if (mode.copyState) { return mode.copyState(state) }
		  var nstate = {}
		  for (var n in state) {
		    var val = state[n]
		    if (val instanceof Array) { val = val.concat([]) }
		    nstate[n] = val
		  }
		  return nstate
		}

		// Given a mode and a state (for that mode), find the inner mode and
		// state at the position that the state refers to.
		function innerMode(mode, state) {
		  var info
		  while (mode.innerMode) {
		    info = mode.innerMode(state)
		    if (!info || info.mode == mode) { break }
		    state = info.state
		    mode = info.mode
		  }
		  return info || {mode: mode, state: state}
		}

		function startState(mode, a1, a2) {
		  return mode.startState ? mode.startState(a1, a2) : true
		}

		// STRING STREAM

		// Fed to the mode parsers, provides helper functions to make
		// parsers more succinct.

		var StringStream = function(string, tabSize) {
		  this.pos = this.start = 0
		  this.string = string
		  this.tabSize = tabSize || 8
		  this.lastColumnPos = this.lastColumnValue = 0
		  this.lineStart = 0
		}

		StringStream.prototype = {
		  eol: function() {return this.pos >= this.string.length},
		  sol: function() {return this.pos == this.lineStart},
		  peek: function() {return this.string.charAt(this.pos) || undefined},
		  next: function() {
		    if (this.pos < this.string.length)
		      { return this.string.charAt(this.pos++) }
		  },
		  eat: function(match) {
		    var ch = this.string.charAt(this.pos)
		    var ok
		    if (typeof match == "string") { ok = ch == match }
		    else { ok = ch && (match.test ? match.test(ch) : match(ch)) }
		    if (ok) {++this.pos; return ch}
		  },
		  eatWhile: function(match) {
		    var start = this.pos
		    while (this.eat(match)){}
		    return this.pos > start
		  },
		  eatSpace: function() {
		    var this$1 = this;

		    var start = this.pos
		    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos }
		    return this.pos > start
		  },
		  skipToEnd: function() {this.pos = this.string.length},
		  skipTo: function(ch) {
		    var found = this.string.indexOf(ch, this.pos)
		    if (found > -1) {this.pos = found; return true}
		  },
		  backUp: function(n) {this.pos -= n},
		  column: function() {
		    if (this.lastColumnPos < this.start) {
		      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)
		      this.lastColumnPos = this.start
		    }
		    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
		  },
		  indentation: function() {
		    return countColumn(this.string, null, this.tabSize) -
		      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
		  },
		  match: function(pattern, consume, caseInsensitive) {
		    if (typeof pattern == "string") {
		      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; }
		      var substr = this.string.substr(this.pos, pattern.length)
		      if (cased(substr) == cased(pattern)) {
		        if (consume !== false) { this.pos += pattern.length }
		        return true
		      }
		    } else {
		      var match = this.string.slice(this.pos).match(pattern)
		      if (match && match.index > 0) { return null }
		      if (match && consume !== false) { this.pos += match[0].length }
		      return match
		    }
		  },
		  current: function(){return this.string.slice(this.start, this.pos)},
		  hideFirstChars: function(n, inner) {
		    this.lineStart += n
		    try { return inner() }
		    finally { this.lineStart -= n }
		  }
		}

		// Compute a style array (an array starting with a mode generation
		// -- for invalidation -- followed by pairs of end positions and
		// style strings), which is used to highlight the tokens on the
		// line.
		function highlightLine(cm, line, state, forceToEnd) {
		  // A styles array always starts with a number identifying the
		  // mode/overlays that it is based on (for easy invalidation).
		  var st = [cm.state.modeGen], lineClasses = {}
		  // Compute the base array of styles
		  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },
		    lineClasses, forceToEnd)

		  // Run overlays, adjust style array.
		  var loop = function ( o ) {
		    var overlay = cm.state.overlays[o], i = 1, at = 0
		    runMode(cm, line.text, overlay.mode, true, function (end, style) {
		      var start = i
		      // Ensure there's a token end at the current position, and that i points at it
		      while (at < end) {
		        var i_end = st[i]
		        if (i_end > end)
		          { st.splice(i, 1, end, st[i+1], i_end) }
		        i += 2
		        at = Math.min(end, i_end)
		      }
		      if (!style) { return }
		      if (overlay.opaque) {
		        st.splice(start, i - start, end, "overlay " + style)
		        i = start + 2
		      } else {
		        for (; start < i; start += 2) {
		          var cur = st[start+1]
		          st[start+1] = (cur ? cur + " " : "") + "overlay " + style
		        }
		      }
		    }, lineClasses)
		  };

		  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

		  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
		}

		function getLineStyles(cm, line, updateFrontier) {
		  if (!line.styles || line.styles[0] != cm.state.modeGen) {
		    var state = getStateBefore(cm, lineNo(line))
		    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state)
		    line.stateAfter = state
		    line.styles = result.styles
		    if (result.classes) { line.styleClasses = result.classes }
		    else if (line.styleClasses) { line.styleClasses = null }
		    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++ }
		  }
		  return line.styles
		}

		function getStateBefore(cm, n, precise) {
		  var doc = cm.doc, display = cm.display
		  if (!doc.mode.startState) { return true }
		  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter
		  if (!state) { state = startState(doc.mode) }
		  else { state = copyState(doc.mode, state) }
		  doc.iter(pos, n, function (line) {
		    processLine(cm, line.text, state)
		    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo
		    line.stateAfter = save ? copyState(doc.mode, state) : null
		    ++pos
		  })
		  if (precise) { doc.frontier = pos }
		  return state
		}

		// Lightweight form of highlight -- proceed over this line and
		// update state, but don't save a style array. Used for lines that
		// aren't currently visible.
		function processLine(cm, text, state, startAt) {
		  var mode = cm.doc.mode
		  var stream = new StringStream(text, cm.options.tabSize)
		  stream.start = stream.pos = startAt || 0
		  if (text == "") { callBlankLine(mode, state) }
		  while (!stream.eol()) {
		    readToken(mode, stream, state)
		    stream.start = stream.pos
		  }
		}

		function callBlankLine(mode, state) {
		  if (mode.blankLine) { return mode.blankLine(state) }
		  if (!mode.innerMode) { return }
		  var inner = innerMode(mode, state)
		  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
		}

		function readToken(mode, stream, state, inner) {
		  for (var i = 0; i < 10; i++) {
		    if (inner) { inner[0] = innerMode(mode, state).mode }
		    var style = mode.token(stream, state)
		    if (stream.pos > stream.start) { return style }
		  }
		  throw new Error("Mode " + mode.name + " failed to advance stream.")
		}

		// Utility for getTokenAt and getLineTokens
		function takeToken(cm, pos, precise, asArray) {
		  var getObj = function (copy) { return ({
		    start: stream.start, end: stream.pos,
		    string: stream.current(),
		    type: style || null,
		    state: copy ? copyState(doc.mode, state) : state
		  }); }

		  var doc = cm.doc, mode = doc.mode, style
		  pos = clipPos(doc, pos)
		  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise)
		  var stream = new StringStream(line.text, cm.options.tabSize), tokens
		  if (asArray) { tokens = [] }
		  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
		    stream.start = stream.pos
		    style = readToken(mode, stream, state)
		    if (asArray) { tokens.push(getObj(true)) }
		  }
		  return asArray ? tokens : getObj()
		}

		function extractLineClasses(type, output) {
		  if (type) { for (;;) {
		    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/)
		    if (!lineClass) { break }
		    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)
		    var prop = lineClass[1] ? "bgClass" : "textClass"
		    if (output[prop] == null)
		      { output[prop] = lineClass[2] }
		    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
		      { output[prop] += " " + lineClass[2] }
		  } }
		  return type
		}

		// Run the given mode's parser over a line, calling f for each token.
		function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
		  var flattenSpans = mode.flattenSpans
		  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans }
		  var curStart = 0, curStyle = null
		  var stream = new StringStream(text, cm.options.tabSize), style
		  var inner = cm.options.addModeClass && [null]
		  if (text == "") { extractLineClasses(callBlankLine(mode, state), lineClasses) }
		  while (!stream.eol()) {
		    if (stream.pos > cm.options.maxHighlightLength) {
		      flattenSpans = false
		      if (forceToEnd) { processLine(cm, text, state, stream.pos) }
		      stream.pos = text.length
		      style = null
		    } else {
		      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses)
		    }
		    if (inner) {
		      var mName = inner[0].name
		      if (mName) { style = "m-" + (style ? mName + " " + style : mName) }
		    }
		    if (!flattenSpans || curStyle != style) {
		      while (curStart < stream.start) {
		        curStart = Math.min(stream.start, curStart + 5000)
		        f(curStart, curStyle)
		      }
		      curStyle = style
		    }
		    stream.start = stream.pos
		  }
		  while (curStart < stream.pos) {
		    // Webkit seems to refuse to render text nodes longer than 57444
		    // characters, and returns inaccurate measurements in nodes
		    // starting around 5000 chars.
		    var pos = Math.min(stream.pos, curStart + 5000)
		    f(pos, curStyle)
		    curStart = pos
		  }
		}

		// Finds the line to start with when starting a parse. Tries to
		// find a line with a stateAfter, so that it can start with a
		// valid state. If that fails, it returns the line with the
		// smallest indentation, which tends to need the least context to
		// parse correctly.
		function findStartLine(cm, n, precise) {
		  var minindent, minline, doc = cm.doc
		  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)
		  for (var search = n; search > lim; --search) {
		    if (search <= doc.first) { return doc.first }
		    var line = getLine(doc, search - 1)
		    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }
		    var indented = countColumn(line.text, null, cm.options.tabSize)
		    if (minline == null || minindent > indented) {
		      minline = search - 1
		      minindent = indented
		    }
		  }
		  return minline
		}

		// LINE DATA STRUCTURE

		// Line objects. These hold state related to a line, including
		// highlighting info (the styles array).
		function Line(text, markedSpans, estimateHeight) {
		  this.text = text
		  attachMarkedSpans(this, markedSpans)
		  this.height = estimateHeight ? estimateHeight(this) : 1
		}
		eventMixin(Line)
		Line.prototype.lineNo = function() { return lineNo(this) }

		// Change the content (text, markers) of a line. Automatically
		// invalidates cached information and tries to re-estimate the
		// line's height.
		function updateLine(line, text, markedSpans, estimateHeight) {
		  line.text = text
		  if (line.stateAfter) { line.stateAfter = null }
		  if (line.styles) { line.styles = null }
		  if (line.order != null) { line.order = null }
		  detachMarkedSpans(line)
		  attachMarkedSpans(line, markedSpans)
		  var estHeight = estimateHeight ? estimateHeight(line) : 1
		  if (estHeight != line.height) { updateLineHeight(line, estHeight) }
		}

		// Detach a line from the document tree and its markers.
		function cleanUpLine(line) {
		  line.parent = null
		  detachMarkedSpans(line)
		}

		// Convert a style as returned by a mode (either null, or a string
		// containing one or more styles) to a CSS style. This is cached,
		// and also looks for line-wide styles.
		var styleToClassCache = {};
		var styleToClassCacheWithMode = {};
		function interpretTokenStyle(style, options) {
		  if (!style || /^\s*$/.test(style)) { return null }
		  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache
		  return cache[style] ||
		    (cache[style] = style.replace(/\S+/g, "cm-$&"))
		}

		// Render the DOM representation of the text of a line. Also builds
		// up a 'line map', which points at the DOM nodes that represent
		// specific stretches of text, and is used by the measuring code.
		// The returned object contains the DOM node, this map, and
		// information about line-wide styles that were set by the mode.
		function buildLineContent(cm, lineView) {
		  // The padding-right forces the element to have a 'border', which
		  // is needed on Webkit to be able to get line-level bounding
		  // rectangles for it (in measureChar).
		  var content = elt("span", null, null, webkit ? "padding-right: .1px" : null)
		  var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
		                 col: 0, pos: 0, cm: cm,
		                 trailingSpace: false,
		                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")}
		  // hide from accessibility tree
		  content.setAttribute("role", "presentation")
		  builder.pre.setAttribute("role", "presentation")
		  lineView.measure = {}

		  // Iterate over the logical lines that make up this visual line.
		  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
		    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0)
		    builder.pos = 0
		    builder.addToken = buildToken
		    // Optionally wire in some hacks into the token-rendering
		    // algorithm, to deal with browser quirks.
		    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
		      { builder.addToken = buildTokenBadBidi(builder.addToken, order) }
		    builder.map = []
		    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line)
		    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))
		    if (line.styleClasses) {
		      if (line.styleClasses.bgClass)
		        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "") }
		      if (line.styleClasses.textClass)
		        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "") }
		    }

		    // Ensure at least a single node is present, for measuring.
		    if (builder.map.length == 0)
		      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }

		    // Store the map and a cache object for the current logical line
		    if (i == 0) {
		      lineView.measure.map = builder.map
		      lineView.measure.cache = {}
		    } else {
		      ;(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
		      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})
		    }
		  }

		  // See issue #2901
		  if (webkit) {
		    var last = builder.content.lastChild
		    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
		      { builder.content.className = "cm-tab-wrap-hack" }
		  }

		  signal(cm, "renderLine", cm, lineView.line, builder.pre)
		  if (builder.pre.className)
		    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || "") }

		  return builder
		}

		function defaultSpecialCharPlaceholder(ch) {
		  var token = elt("span", "\u2022", "cm-invalidchar")
		  token.title = "\\u" + ch.charCodeAt(0).toString(16)
		  token.setAttribute("aria-label", token.title)
		  return token
		}

		// Build up the DOM representation for a single token, and add it to
		// the line map. Takes care to render special characters separately.
		function buildToken(builder, text, style, startStyle, endStyle, title, css) {
		  if (!text) { return }
		  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text
		  var special = builder.cm.state.specialChars, mustWrap = false
		  var content
		  if (!special.test(text)) {
		    builder.col += text.length
		    content = document.createTextNode(displayText)
		    builder.map.push(builder.pos, builder.pos + text.length, content)
		    if (ie && ie_version < 9) { mustWrap = true }
		    builder.pos += text.length
		  } else {
		    content = document.createDocumentFragment()
		    var pos = 0
		    while (true) {
		      special.lastIndex = pos
		      var m = special.exec(text)
		      var skipped = m ? m.index - pos : text.length - pos
		      if (skipped) {
		        var txt = document.createTextNode(displayText.slice(pos, pos + skipped))
		        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])) }
		        else { content.appendChild(txt) }
		        builder.map.push(builder.pos, builder.pos + skipped, txt)
		        builder.col += skipped
		        builder.pos += skipped
		      }
		      if (!m) { break }
		      pos += skipped + 1
		      var txt$1 = (void 0)
		      if (m[0] == "\t") {
		        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize
		        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"))
		        txt$1.setAttribute("role", "presentation")
		        txt$1.setAttribute("cm-text", "\t")
		        builder.col += tabWidth
		      } else if (m[0] == "\r" || m[0] == "\n") {
		        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"))
		        txt$1.setAttribute("cm-text", m[0])
		        builder.col += 1
		      } else {
		        txt$1 = builder.cm.options.specialCharPlaceholder(m[0])
		        txt$1.setAttribute("cm-text", m[0])
		        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])) }
		        else { content.appendChild(txt$1) }
		        builder.col += 1
		      }
		      builder.map.push(builder.pos, builder.pos + 1, txt$1)
		      builder.pos++
		    }
		  }
		  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
		  if (style || startStyle || endStyle || mustWrap || css) {
		    var fullStyle = style || ""
		    if (startStyle) { fullStyle += startStyle }
		    if (endStyle) { fullStyle += endStyle }
		    var token = elt("span", [content], fullStyle, css)
		    if (title) { token.title = title }
		    return builder.content.appendChild(token)
		  }
		  builder.content.appendChild(content)
		}

		function splitSpaces(text, trailingBefore) {
		  if (text.length > 1 && !/  /.test(text)) { return text }
		  var spaceBefore = trailingBefore, result = ""
		  for (var i = 0; i < text.length; i++) {
		    var ch = text.charAt(i)
		    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
		      { ch = "\u00a0" }
		    result += ch
		    spaceBefore = ch == " "
		  }
		  return result
		}

		// Work around nonsense dimensions being reported for stretches of
		// right-to-left text.
		function buildTokenBadBidi(inner, order) {
		  return function (builder, text, style, startStyle, endStyle, title, css) {
		    style = style ? style + " cm-force-border" : "cm-force-border"
		    var start = builder.pos, end = start + text.length
		    for (;;) {
		      // Find the part that overlaps with the start of this text
		      var part = (void 0)
		      for (var i = 0; i < order.length; i++) {
		        part = order[i]
		        if (part.to > start && part.from <= start) { break }
		      }
		      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
		      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)
		      startStyle = null
		      text = text.slice(part.to - start)
		      start = part.to
		    }
		  }
		}

		function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
		  var widget = !ignoreWidget && marker.widgetNode
		  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }
		  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
		    if (!widget)
		      { widget = builder.content.appendChild(document.createElement("span")) }
		    widget.setAttribute("cm-marker", marker.id)
		  }
		  if (widget) {
		    builder.cm.display.input.setUneditable(widget)
		    builder.content.appendChild(widget)
		  }
		  builder.pos += size
		  builder.trailingSpace = false
		}

		// Outputs a number of spans to make up a line, taking highlighting
		// and marked text into account.
		function insertLineContent(line, builder, styles) {
		  var spans = line.markedSpans, allText = line.text, at = 0
		  if (!spans) {
		    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
		      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)) }
		    return
		  }

		  var len = allText.length, pos = 0, i = 1, text = "", style, css
		  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed
		  for (;;) {
		    if (nextChange == pos) { // Update current marker set
		      spanStyle = spanEndStyle = spanStartStyle = title = css = ""
		      collapsed = null; nextChange = Infinity
		      var foundBookmarks = [], endStyles = (void 0)
		      for (var j = 0; j < spans.length; ++j) {
		        var sp = spans[j], m = sp.marker
		        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
		          foundBookmarks.push(m)
		        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
		          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
		            nextChange = sp.to
		            spanEndStyle = ""
		          }
		          if (m.className) { spanStyle += " " + m.className }
		          if (m.css) { css = (css ? css + ";" : "") + m.css }
		          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle }
		          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to) }
		          if (m.title && !title) { title = m.title }
		          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
		            { collapsed = sp }
		        } else if (sp.from > pos && nextChange > sp.from) {
		          nextChange = sp.from
		        }
		      }
		      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
		        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1] } } }

		      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
		        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]) } }
		      if (collapsed && (collapsed.from || 0) == pos) {
		        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
		                           collapsed.marker, collapsed.from == null)
		        if (collapsed.to == null) { return }
		        if (collapsed.to == pos) { collapsed = false }
		      }
		    }
		    if (pos >= len) { break }

		    var upto = Math.min(len, nextChange)
		    while (true) {
		      if (text) {
		        var end = pos + text.length
		        if (!collapsed) {
		          var tokenText = end > upto ? text.slice(0, upto - pos) : text
		          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
		                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css)
		        }
		        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
		        pos = end
		        spanStartStyle = ""
		      }
		      text = allText.slice(at, at = styles[i++])
		      style = interpretTokenStyle(styles[i++], builder.cm.options)
		    }
		  }
		}


		// These objects are used to represent the visible (currently drawn)
		// part of the document. A LineView may correspond to multiple
		// logical lines, if those are connected by collapsed ranges.
		function LineView(doc, line, lineN) {
		  // The starting line
		  this.line = line
		  // Continuing lines, if any
		  this.rest = visualLineContinued(line)
		  // Number of logical lines in this visual line
		  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1
		  this.node = this.text = null
		  this.hidden = lineIsHidden(doc, line)
		}

		// Create a range of LineView objects for the given lines.
		function buildViewArray(cm, from, to) {
		  var array = [], nextPos
		  for (var pos = from; pos < to; pos = nextPos) {
		    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)
		    nextPos = pos + view.size
		    array.push(view)
		  }
		  return array
		}

		var operationGroup = null

		function pushOperation(op) {
		  if (operationGroup) {
		    operationGroup.ops.push(op)
		  } else {
		    op.ownsGroup = operationGroup = {
		      ops: [op],
		      delayedCallbacks: []
		    }
		  }
		}

		function fireCallbacksForOps(group) {
		  // Calls delayed callbacks and cursorActivity handlers until no
		  // new ones appear
		  var callbacks = group.delayedCallbacks, i = 0
		  do {
		    for (; i < callbacks.length; i++)
		      { callbacks[i].call(null) }
		    for (var j = 0; j < group.ops.length; j++) {
		      var op = group.ops[j]
		      if (op.cursorActivityHandlers)
		        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
		          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm) } }
		    }
		  } while (i < callbacks.length)
		}

		function finishOperation(op, endCb) {
		  var group = op.ownsGroup
		  if (!group) { return }

		  try { fireCallbacksForOps(group) }
		  finally {
		    operationGroup = null
		    endCb(group)
		  }
		}

		var orphanDelayedCallbacks = null

		// Often, we want to signal events at a point where we are in the
		// middle of some work, but don't want the handler to start calling
		// other methods on the editor, which might be in an inconsistent
		// state or simply not expect any other events to happen.
		// signalLater looks whether there are any handlers, and schedules
		// them to be executed when the last operation ends, or, if no
		// operation is active, when a timeout fires.
		function signalLater(emitter, type /*, values...*/) {
		  var arr = getHandlers(emitter, type)
		  if (!arr.length) { return }
		  var args = Array.prototype.slice.call(arguments, 2), list
		  if (operationGroup) {
		    list = operationGroup.delayedCallbacks
		  } else if (orphanDelayedCallbacks) {
		    list = orphanDelayedCallbacks
		  } else {
		    list = orphanDelayedCallbacks = []
		    setTimeout(fireOrphanDelayed, 0)
		  }
		  var loop = function ( i ) {
		    list.push(function () { return arr[i].apply(null, args); })
		  };

		  for (var i = 0; i < arr.length; ++i)
		    loop( i );
		}

		function fireOrphanDelayed() {
		  var delayed = orphanDelayedCallbacks
		  orphanDelayedCallbacks = null
		  for (var i = 0; i < delayed.length; ++i) { delayed[i]() }
		}

		// When an aspect of a line changes, a string is added to
		// lineView.changes. This updates the relevant part of the line's
		// DOM structure.
		function updateLineForChanges(cm, lineView, lineN, dims) {
		  for (var j = 0; j < lineView.changes.length; j++) {
		    var type = lineView.changes[j]
		    if (type == "text") { updateLineText(cm, lineView) }
		    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims) }
		    else if (type == "class") { updateLineClasses(lineView) }
		    else if (type == "widget") { updateLineWidgets(cm, lineView, dims) }
		  }
		  lineView.changes = null
		}

		// Lines with gutter elements, widgets or a background class need to
		// be wrapped, and have the extra elements added to the wrapper div
		function ensureLineWrapped(lineView) {
		  if (lineView.node == lineView.text) {
		    lineView.node = elt("div", null, null, "position: relative")
		    if (lineView.text.parentNode)
		      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text) }
		    lineView.node.appendChild(lineView.text)
		    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2 }
		  }
		  return lineView.node
		}

		function updateLineBackground(lineView) {
		  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass
		  if (cls) { cls += " CodeMirror-linebackground" }
		  if (lineView.background) {
		    if (cls) { lineView.background.className = cls }
		    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null }
		  } else if (cls) {
		    var wrap = ensureLineWrapped(lineView)
		    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild)
		  }
		}

		// Wrapper around buildLineContent which will reuse the structure
		// in display.externalMeasured when possible.
		function getLineContent(cm, lineView) {
		  var ext = cm.display.externalMeasured
		  if (ext && ext.line == lineView.line) {
		    cm.display.externalMeasured = null
		    lineView.measure = ext.measure
		    return ext.built
		  }
		  return buildLineContent(cm, lineView)
		}

		// Redraw the line's text. Interacts with the background and text
		// classes because the mode may output tokens that influence these
		// classes.
		function updateLineText(cm, lineView) {
		  var cls = lineView.text.className
		  var built = getLineContent(cm, lineView)
		  if (lineView.text == lineView.node) { lineView.node = built.pre }
		  lineView.text.parentNode.replaceChild(built.pre, lineView.text)
		  lineView.text = built.pre
		  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
		    lineView.bgClass = built.bgClass
		    lineView.textClass = built.textClass
		    updateLineClasses(lineView)
		  } else if (cls) {
		    lineView.text.className = cls
		  }
		}

		function updateLineClasses(lineView) {
		  updateLineBackground(lineView)
		  if (lineView.line.wrapClass)
		    { ensureLineWrapped(lineView).className = lineView.line.wrapClass }
		  else if (lineView.node != lineView.text)
		    { lineView.node.className = "" }
		  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass
		  lineView.text.className = textClass || ""
		}

		function updateLineGutter(cm, lineView, lineN, dims) {
		  if (lineView.gutter) {
		    lineView.node.removeChild(lineView.gutter)
		    lineView.gutter = null
		  }
		  if (lineView.gutterBackground) {
		    lineView.node.removeChild(lineView.gutterBackground)
		    lineView.gutterBackground = null
		  }
		  if (lineView.line.gutterClass) {
		    var wrap = ensureLineWrapped(lineView)
		    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
		                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"))
		    wrap.insertBefore(lineView.gutterBackground, lineView.text)
		  }
		  var markers = lineView.line.gutterMarkers
		  if (cm.options.lineNumbers || markers) {
		    var wrap$1 = ensureLineWrapped(lineView)
		    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"))
		    cm.display.input.setUneditable(gutterWrap)
		    wrap$1.insertBefore(gutterWrap, lineView.text)
		    if (lineView.line.gutterClass)
		      { gutterWrap.className += " " + lineView.line.gutterClass }
		    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
		      { lineView.lineNumber = gutterWrap.appendChild(
		        elt("div", lineNumberFor(cm.options, lineN),
		            "CodeMirror-linenumber CodeMirror-gutter-elt",
		            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))) }
		    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
		      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id]
		      if (found)
		        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
		                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))) }
		    } }
		  }
		}

		function updateLineWidgets(cm, lineView, dims) {
		  if (lineView.alignable) { lineView.alignable = null }
		  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
		    next = node.nextSibling
		    if (node.className == "CodeMirror-linewidget")
		      { lineView.node.removeChild(node) }
		  }
		  insertLineWidgets(cm, lineView, dims)
		}

		// Build a line's DOM representation from scratch
		function buildLineElement(cm, lineView, lineN, dims) {
		  var built = getLineContent(cm, lineView)
		  lineView.text = lineView.node = built.pre
		  if (built.bgClass) { lineView.bgClass = built.bgClass }
		  if (built.textClass) { lineView.textClass = built.textClass }

		  updateLineClasses(lineView)
		  updateLineGutter(cm, lineView, lineN, dims)
		  insertLineWidgets(cm, lineView, dims)
		  return lineView.node
		}

		// A lineView may contain multiple logical lines (when merged by
		// collapsed spans). The widgets for all of them need to be drawn.
		function insertLineWidgets(cm, lineView, dims) {
		  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)
		  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
		    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false) } }
		}

		function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
		  if (!line.widgets) { return }
		  var wrap = ensureLineWrapped(lineView)
		  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
		    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget")
		    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true") }
		    positionLineWidget(widget, node, lineView, dims)
		    cm.display.input.setUneditable(node)
		    if (allowAbove && widget.above)
		      { wrap.insertBefore(node, lineView.gutter || lineView.text) }
		    else
		      { wrap.appendChild(node) }
		    signalLater(widget, "redraw")
		  }
		}

		function positionLineWidget(widget, node, lineView, dims) {
		  if (widget.noHScroll) {
		    ;(lineView.alignable || (lineView.alignable = [])).push(node)
		    var width = dims.wrapperWidth
		    node.style.left = dims.fixedPos + "px"
		    if (!widget.coverGutter) {
		      width -= dims.gutterTotalWidth
		      node.style.paddingLeft = dims.gutterTotalWidth + "px"
		    }
		    node.style.width = width + "px"
		  }
		  if (widget.coverGutter) {
		    node.style.zIndex = 5
		    node.style.position = "relative"
		    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px" }
		  }
		}

		function widgetHeight(widget) {
		  if (widget.height != null) { return widget.height }
		  var cm = widget.doc.cm
		  if (!cm) { return 0 }
		  if (!contains(document.body, widget.node)) {
		    var parentStyle = "position: relative;"
		    if (widget.coverGutter)
		      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;" }
		    if (widget.noHScroll)
		      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;" }
		    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle))
		  }
		  return widget.height = widget.node.parentNode.offsetHeight
		}

		// Return true when the given mouse event happened in a widget
		function eventInWidget(display, e) {
		  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
		    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
		        (n.parentNode == display.sizer && n != display.mover))
		      { return true }
		  }
		}

		// POSITION MEASUREMENT

		function paddingTop(display) {return display.lineSpace.offsetTop}
		function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
		function paddingH(display) {
		  if (display.cachedPaddingH) { return display.cachedPaddingH }
		  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"))
		  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle
		  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)}
		  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data }
		  return data
		}

		function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
		function displayWidth(cm) {
		  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
		}
		function displayHeight(cm) {
		  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
		}

		// Ensure the lineView.wrapping.heights array is populated. This is
		// an array of bottom offsets for the lines that make up a drawn
		// line. When lineWrapping is on, there might be more than one
		// height.
		function ensureLineHeights(cm, lineView, rect) {
		  var wrapping = cm.options.lineWrapping
		  var curWidth = wrapping && displayWidth(cm)
		  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
		    var heights = lineView.measure.heights = []
		    if (wrapping) {
		      lineView.measure.width = curWidth
		      var rects = lineView.text.firstChild.getClientRects()
		      for (var i = 0; i < rects.length - 1; i++) {
		        var cur = rects[i], next = rects[i + 1]
		        if (Math.abs(cur.bottom - next.bottom) > 2)
		          { heights.push((cur.bottom + next.top) / 2 - rect.top) }
		      }
		    }
		    heights.push(rect.bottom - rect.top)
		  }
		}

		// Find a line map (mapping character offsets to text nodes) and a
		// measurement cache for the given line number. (A line view might
		// contain multiple lines when collapsed ranges are present.)
		function mapFromLineView(lineView, line, lineN) {
		  if (lineView.line == line)
		    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
		  for (var i = 0; i < lineView.rest.length; i++)
		    { if (lineView.rest[i] == line)
		      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
		  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
		    { if (lineNo(lineView.rest[i$1]) > lineN)
		      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
		}

		// Render a line into the hidden node display.externalMeasured. Used
		// when measurement is needed for a line that's not in the viewport.
		function updateExternalMeasurement(cm, line) {
		  line = visualLine(line)
		  var lineN = lineNo(line)
		  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)
		  view.lineN = lineN
		  var built = view.built = buildLineContent(cm, view)
		  view.text = built.pre
		  removeChildrenAndAdd(cm.display.lineMeasure, built.pre)
		  return view
		}

		// Get a {top, bottom, left, right} box (in line-local coordinates)
		// for a given character.
		function measureChar(cm, line, ch, bias) {
		  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
		}

		// Find a line view that corresponds to the given line number.
		function findViewForLine(cm, lineN) {
		  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
		    { return cm.display.view[findViewIndex(cm, lineN)] }
		  var ext = cm.display.externalMeasured
		  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
		    { return ext }
		}

		// Measurement can be split in two steps, the set-up work that
		// applies to the whole line, and the measurement of the actual
		// character. Functions like coordsChar, that need to do a lot of
		// measurements in a row, can thus ensure that the set-up work is
		// only done once.
		function prepareMeasureForLine(cm, line) {
		  var lineN = lineNo(line)
		  var view = findViewForLine(cm, lineN)
		  if (view && !view.text) {
		    view = null
		  } else if (view && view.changes) {
		    updateLineForChanges(cm, view, lineN, getDimensions(cm))
		    cm.curOp.forceUpdate = true
		  }
		  if (!view)
		    { view = updateExternalMeasurement(cm, line) }

		  var info = mapFromLineView(view, line, lineN)
		  return {
		    line: line, view: view, rect: null,
		    map: info.map, cache: info.cache, before: info.before,
		    hasHeights: false
		  }
		}

		// Given a prepared measurement object, measures the position of an
		// actual character (or fetches it from the cache).
		function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
		  if (prepared.before) { ch = -1 }
		  var key = ch + (bias || ""), found
		  if (prepared.cache.hasOwnProperty(key)) {
		    found = prepared.cache[key]
		  } else {
		    if (!prepared.rect)
		      { prepared.rect = prepared.view.text.getBoundingClientRect() }
		    if (!prepared.hasHeights) {
		      ensureLineHeights(cm, prepared.view, prepared.rect)
		      prepared.hasHeights = true
		    }
		    found = measureCharInner(cm, prepared, ch, bias)
		    if (!found.bogus) { prepared.cache[key] = found }
		  }
		  return {left: found.left, right: found.right,
		          top: varHeight ? found.rtop : found.top,
		          bottom: varHeight ? found.rbottom : found.bottom}
		}

		var nullRect = {left: 0, right: 0, top: 0, bottom: 0}

		function nodeAndOffsetInLineMap(map, ch, bias) {
		  var node, start, end, collapse, mStart, mEnd
		  // First, search the line map for the text node corresponding to,
		  // or closest to, the target character.
		  for (var i = 0; i < map.length; i += 3) {
		    mStart = map[i]
		    mEnd = map[i + 1]
		    if (ch < mStart) {
		      start = 0; end = 1
		      collapse = "left"
		    } else if (ch < mEnd) {
		      start = ch - mStart
		      end = start + 1
		    } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
		      end = mEnd - mStart
		      start = end - 1
		      if (ch >= mEnd) { collapse = "right" }
		    }
		    if (start != null) {
		      node = map[i + 2]
		      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
		        { collapse = bias }
		      if (bias == "left" && start == 0)
		        { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
		          node = map[(i -= 3) + 2]
		          collapse = "left"
		        } }
		      if (bias == "right" && start == mEnd - mStart)
		        { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
		          node = map[(i += 3) + 2]
		          collapse = "right"
		        } }
		      break
		    }
		  }
		  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
		}

		function getUsefulRect(rects, bias) {
		  var rect = nullRect
		  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
		    if ((rect = rects[i]).left != rect.right) { break }
		  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
		    if ((rect = rects[i$1]).left != rect.right) { break }
		  } }
		  return rect
		}

		function measureCharInner(cm, prepared, ch, bias) {
		  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)
		  var node = place.node, start = place.start, end = place.end, collapse = place.collapse

		  var rect
		  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
		    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
		      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start }
		      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end }
		      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
		        { rect = node.parentNode.getBoundingClientRect() }
		      else
		        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias) }
		      if (rect.left || rect.right || start == 0) { break }
		      end = start
		      start = start - 1
		      collapse = "right"
		    }
		    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect) }
		  } else { // If it is a widget, simply get the box for the whole widget.
		    if (start > 0) { collapse = bias = "right" }
		    var rects
		    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
		      { rect = rects[bias == "right" ? rects.length - 1 : 0] }
		    else
		      { rect = node.getBoundingClientRect() }
		  }
		  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
		    var rSpan = node.parentNode.getClientRects()[0]
		    if (rSpan)
		      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} }
		    else
		      { rect = nullRect }
		  }

		  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top
		  var mid = (rtop + rbot) / 2
		  var heights = prepared.view.measure.heights
		  var i = 0
		  for (; i < heights.length - 1; i++)
		    { if (mid < heights[i]) { break } }
		  var top = i ? heights[i - 1] : 0, bot = heights[i]
		  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
		                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
		                top: top, bottom: bot}
		  if (!rect.left && !rect.right) { result.bogus = true }
		  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot }

		  return result
		}

		// Work around problem with bounding client rects on ranges being
		// returned incorrectly when zoomed on IE10 and below.
		function maybeUpdateRectForZooming(measure, rect) {
		  if (!window.screen || screen.logicalXDPI == null ||
		      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
		    { return rect }
		  var scaleX = screen.logicalXDPI / screen.deviceXDPI
		  var scaleY = screen.logicalYDPI / screen.deviceYDPI
		  return {left: rect.left * scaleX, right: rect.right * scaleX,
		          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
		}

		function clearLineMeasurementCacheFor(lineView) {
		  if (lineView.measure) {
		    lineView.measure.cache = {}
		    lineView.measure.heights = null
		    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
		      { lineView.measure.caches[i] = {} } }
		  }
		}

		function clearLineMeasurementCache(cm) {
		  cm.display.externalMeasure = null
		  removeChildren(cm.display.lineMeasure)
		  for (var i = 0; i < cm.display.view.length; i++)
		    { clearLineMeasurementCacheFor(cm.display.view[i]) }
		}

		function clearCaches(cm) {
		  clearLineMeasurementCache(cm)
		  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null
		  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true }
		  cm.display.lineNumChars = null
		}

		function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }
		function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }

		// Converts a {top, bottom, left, right} box from line-local
		// coordinates into another coordinate system. Context may be one of
		// "line", "div" (display.lineDiv), "local"./null (editor), "window",
		// or "page".
		function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
		  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {
		    var size = widgetHeight(lineObj.widgets[i])
		    rect.top += size; rect.bottom += size
		  } } }
		  if (context == "line") { return rect }
		  if (!context) { context = "local" }
		  var yOff = heightAtLine(lineObj)
		  if (context == "local") { yOff += paddingTop(cm.display) }
		  else { yOff -= cm.display.viewOffset }
		  if (context == "page" || context == "window") {
		    var lOff = cm.display.lineSpace.getBoundingClientRect()
		    yOff += lOff.top + (context == "window" ? 0 : pageScrollY())
		    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX())
		    rect.left += xOff; rect.right += xOff
		  }
		  rect.top += yOff; rect.bottom += yOff
		  return rect
		}

		// Coverts a box from "div" coords to another coordinate system.
		// Context may be "window", "page", "div", or "local"./null.
		function fromCoordSystem(cm, coords, context) {
		  if (context == "div") { return coords }
		  var left = coords.left, top = coords.top
		  // First move into "page" coordinate system
		  if (context == "page") {
		    left -= pageScrollX()
		    top -= pageScrollY()
		  } else if (context == "local" || !context) {
		    var localBox = cm.display.sizer.getBoundingClientRect()
		    left += localBox.left
		    top += localBox.top
		  }

		  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()
		  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
		}

		function charCoords(cm, pos, context, lineObj, bias) {
		  if (!lineObj) { lineObj = getLine(cm.doc, pos.line) }
		  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
		}

		// Returns a box for a given cursor position, which may have an
		// 'other' property containing the position of the secondary cursor
		// on a bidi boundary.
		function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
		  lineObj = lineObj || getLine(cm.doc, pos.line)
		  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }
		  function get(ch, right) {
		    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight)
		    if (right) { m.left = m.right; } else { m.right = m.left }
		    return intoCoordSystem(cm, lineObj, m, context)
		  }
		  function getBidi(ch, partPos) {
		    var part = order[partPos], right = part.level % 2
		    if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
		      part = order[--partPos]
		      ch = bidiRight(part) - (part.level % 2 ? 0 : 1)
		      right = true
		    } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
		      part = order[++partPos]
		      ch = bidiLeft(part) - part.level % 2
		      right = false
		    }
		    if (right && ch == part.to && ch > part.from) { return get(ch - 1) }
		    return get(ch, right)
		  }
		  var order = getOrder(lineObj), ch = pos.ch
		  if (!order) { return get(ch) }
		  var partPos = getBidiPartAt(order, ch)
		  var val = getBidi(ch, partPos)
		  if (bidiOther != null) { val.other = getBidi(ch, bidiOther) }
		  return val
		}

		// Used to cheaply estimate the coordinates for a position. Used for
		// intermediate scroll updates.
		function estimateCoords(cm, pos) {
		  var left = 0
		  pos = clipPos(cm.doc, pos)
		  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch }
		  var lineObj = getLine(cm.doc, pos.line)
		  var top = heightAtLine(lineObj) + paddingTop(cm.display)
		  return {left: left, right: left, top: top, bottom: top + lineObj.height}
		}

		// Positions returned by coordsChar contain some extra information.
		// xRel is the relative x position of the input coordinates compared
		// to the found position (so xRel > 0 means the coordinates are to
		// the right of the character position, for example). When outside
		// is true, that means the coordinates lie outside the line's
		// vertical range.
		function PosWithInfo(line, ch, outside, xRel) {
		  var pos = Pos(line, ch)
		  pos.xRel = xRel
		  if (outside) { pos.outside = true }
		  return pos
		}

		// Compute the character position closest to the given coordinates.
		// Input must be lineSpace-local ("div" coordinate system).
		function coordsChar(cm, x, y) {
		  var doc = cm.doc
		  y += cm.display.viewOffset
		  if (y < 0) { return PosWithInfo(doc.first, 0, true, -1) }
		  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1
		  if (lineN > last)
		    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1) }
		  if (x < 0) { x = 0 }

		  var lineObj = getLine(doc, lineN)
		  for (;;) {
		    var found = coordsCharInner(cm, lineObj, lineN, x, y)
		    var merged = collapsedSpanAtEnd(lineObj)
		    var mergedPos = merged && merged.find(0, true)
		    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
		      { lineN = lineNo(lineObj = mergedPos.to.line) }
		    else
		      { return found }
		  }
		}

		function coordsCharInner(cm, lineObj, lineNo, x, y) {
		  var innerOff = y - heightAtLine(lineObj)
		  var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth
		  var preparedMeasure = prepareMeasureForLine(cm, lineObj)

		  function getX(ch) {
		    var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure)
		    wrongLine = true
		    if (innerOff > sp.bottom) { return sp.left - adjust }
		    else if (innerOff < sp.top) { return sp.left + adjust }
		    else { wrongLine = false }
		    return sp.left
		  }

		  var bidi = getOrder(lineObj), dist = lineObj.text.length
		  var from = lineLeft(lineObj), to = lineRight(lineObj)
		  var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine

		  if (x > toX) { return PosWithInfo(lineNo, to, toOutside, 1) }
		  // Do a binary search between these bounds.
		  for (;;) {
		    if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
		      var ch = x < fromX || x - fromX <= toX - x ? from : to
		      var outside = ch == from ? fromOutside : toOutside
		      var xDiff = x - (ch == from ? fromX : toX)
		      // This is a kludge to handle the case where the coordinates
		      // are after a line-wrapped line. We should replace it with a
		      // more general handling of cursor positions around line
		      // breaks. (Issue #4078)
		      if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&
		          ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
		        var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right")
		        if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {
		          outside = false
		          ch++
		          xDiff = x - charSize.right
		        }
		      }
		      while (isExtendingChar(lineObj.text.charAt(ch))) { ++ch }
		      var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0)
		      return pos
		    }
		    var step = Math.ceil(dist / 2), middle = from + step
		    if (bidi) {
		      middle = from
		      for (var i = 0; i < step; ++i) { middle = moveVisually(lineObj, middle, 1) }
		    }
		    var middleX = getX(middle)
		    if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) { toX += 1000; } dist = step}
		    else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step}
		  }
		}

		var measureText
		// Compute the default text height.
		function textHeight(display) {
		  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
		  if (measureText == null) {
		    measureText = elt("pre")
		    // Measure a bunch of lines, for browsers that compute
		    // fractional heights.
		    for (var i = 0; i < 49; ++i) {
		      measureText.appendChild(document.createTextNode("x"))
		      measureText.appendChild(elt("br"))
		    }
		    measureText.appendChild(document.createTextNode("x"))
		  }
		  removeChildrenAndAdd(display.measure, measureText)
		  var height = measureText.offsetHeight / 50
		  if (height > 3) { display.cachedTextHeight = height }
		  removeChildren(display.measure)
		  return height || 1
		}

		// Compute the default character width.
		function charWidth(display) {
		  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
		  var anchor = elt("span", "xxxxxxxxxx")
		  var pre = elt("pre", [anchor])
		  removeChildrenAndAdd(display.measure, pre)
		  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10
		  if (width > 2) { display.cachedCharWidth = width }
		  return width || 10
		}

		// Do a bulk-read of the DOM positions and sizes needed to draw the
		// view, so that we don't interleave reading and writing to the DOM.
		function getDimensions(cm) {
		  var d = cm.display, left = {}, width = {}
		  var gutterLeft = d.gutters.clientLeft
		  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
		    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft
		    width[cm.options.gutters[i]] = n.clientWidth
		  }
		  return {fixedPos: compensateForHScroll(d),
		          gutterTotalWidth: d.gutters.offsetWidth,
		          gutterLeft: left,
		          gutterWidth: width,
		          wrapperWidth: d.wrapper.clientWidth}
		}

		// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
		// but using getBoundingClientRect to get a sub-pixel-accurate
		// result.
		function compensateForHScroll(display) {
		  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
		}

		// Returns a function that estimates the height of a line, to use as
		// first approximation until the line becomes visible (and is thus
		// properly measurable).
		function estimateHeight(cm) {
		  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping
		  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3)
		  return function (line) {
		    if (lineIsHidden(cm.doc, line)) { return 0 }

		    var widgetsHeight = 0
		    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
		      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height }
		    } }

		    if (wrapping)
		      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
		    else
		      { return widgetsHeight + th }
		  }
		}

		function estimateLineHeights(cm) {
		  var doc = cm.doc, est = estimateHeight(cm)
		  doc.iter(function (line) {
		    var estHeight = est(line)
		    if (estHeight != line.height) { updateLineHeight(line, estHeight) }
		  })
		}

		// Given a mouse event, find the corresponding position. If liberal
		// is false, it checks whether a gutter or scrollbar was clicked,
		// and returns null if it was. forRect is used by rectangular
		// selections, and tries to estimate a character position even for
		// coordinates beyond the right of the text.
		function posFromMouse(cm, e, liberal, forRect) {
		  var display = cm.display
		  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

		  var x, y, space = display.lineSpace.getBoundingClientRect()
		  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
		  try { x = e.clientX - space.left; y = e.clientY - space.top }
		  catch (e) { return null }
		  var coords = coordsChar(cm, x, y), line
		  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
		    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length
		    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))
		  }
		  return coords
		}

		// Find the view element corresponding to a given line. Return null
		// when the line isn't visible.
		function findViewIndex(cm, n) {
		  if (n >= cm.display.viewTo) { return null }
		  n -= cm.display.viewFrom
		  if (n < 0) { return null }
		  var view = cm.display.view
		  for (var i = 0; i < view.length; i++) {
		    n -= view[i].size
		    if (n < 0) { return i }
		  }
		}

		function updateSelection(cm) {
		  cm.display.input.showSelection(cm.display.input.prepareSelection())
		}

		function prepareSelection(cm, primary) {
		  var doc = cm.doc, result = {}
		  var curFragment = result.cursors = document.createDocumentFragment()
		  var selFragment = result.selection = document.createDocumentFragment()

		  for (var i = 0; i < doc.sel.ranges.length; i++) {
		    if (primary === false && i == doc.sel.primIndex) { continue }
		    var range = doc.sel.ranges[i]
		    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
		    var collapsed = range.empty()
		    if (collapsed || cm.options.showCursorWhenSelecting)
		      { drawSelectionCursor(cm, range.head, curFragment) }
		    if (!collapsed)
		      { drawSelectionRange(cm, range, selFragment) }
		  }
		  return result
		}

		// Draws a cursor for the given range
		function drawSelectionCursor(cm, head, output) {
		  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine)

		  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"))
		  cursor.style.left = pos.left + "px"
		  cursor.style.top = pos.top + "px"
		  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px"

		  if (pos.other) {
		    // Secondary cursor, shown when on a 'jump' in bi-directional text
		    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"))
		    otherCursor.style.display = ""
		    otherCursor.style.left = pos.other.left + "px"
		    otherCursor.style.top = pos.other.top + "px"
		    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px"
		  }
		}

		// Draws the given range as a highlighted selection
		function drawSelectionRange(cm, range, output) {
		  var display = cm.display, doc = cm.doc
		  var fragment = document.createDocumentFragment()
		  var padding = paddingH(cm.display), leftSide = padding.left
		  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right

		  function add(left, top, width, bottom) {
		    if (top < 0) { top = 0 }
		    top = Math.round(top)
		    bottom = Math.round(bottom)
		    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")))
		  }

		  function drawForLine(line, fromArg, toArg) {
		    var lineObj = getLine(doc, line)
		    var lineLen = lineObj.text.length
		    var start, end
		    function coords(ch, bias) {
		      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
		    }

		    iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
		      var leftPos = coords(from, "left"), rightPos, left, right
		      if (from == to) {
		        rightPos = leftPos
		        left = right = leftPos.left
		      } else {
		        rightPos = coords(to - 1, "right")
		        if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp }
		        left = leftPos.left
		        right = rightPos.right
		      }
		      if (fromArg == null && from == 0) { left = leftSide }
		      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
		        add(left, leftPos.top, null, leftPos.bottom)
		        left = leftSide
		        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top) }
		      }
		      if (toArg == null && to == lineLen) { right = rightSide }
		      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
		        { start = leftPos }
		      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
		        { end = rightPos }
		      if (left < leftSide + 1) { left = leftSide }
		      add(left, rightPos.top, right - left, rightPos.bottom)
		    })
		    return {start: start, end: end}
		  }

		  var sFrom = range.from(), sTo = range.to()
		  if (sFrom.line == sTo.line) {
		    drawForLine(sFrom.line, sFrom.ch, sTo.ch)
		  } else {
		    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line)
		    var singleVLine = visualLine(fromLine) == visualLine(toLine)
		    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end
		    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start
		    if (singleVLine) {
		      if (leftEnd.top < rightStart.top - 2) {
		        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)
		        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)
		      } else {
		        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)
		      }
		    }
		    if (leftEnd.bottom < rightStart.top)
		      { add(leftSide, leftEnd.bottom, null, rightStart.top) }
		  }

		  output.appendChild(fragment)
		}

		// Cursor-blinking
		function restartBlink(cm) {
		  if (!cm.state.focused) { return }
		  var display = cm.display
		  clearInterval(display.blinker)
		  var on = true
		  display.cursorDiv.style.visibility = ""
		  if (cm.options.cursorBlinkRate > 0)
		    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
		      cm.options.cursorBlinkRate) }
		  else if (cm.options.cursorBlinkRate < 0)
		    { display.cursorDiv.style.visibility = "hidden" }
		}

		function ensureFocus(cm) {
		  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm) }
		}

		function delayBlurEvent(cm) {
		  cm.state.delayingBlurEvent = true
		  setTimeout(function () { if (cm.state.delayingBlurEvent) {
		    cm.state.delayingBlurEvent = false
		    onBlur(cm)
		  } }, 100)
		}

		function onFocus(cm, e) {
		  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false }

		  if (cm.options.readOnly == "nocursor") { return }
		  if (!cm.state.focused) {
		    signal(cm, "focus", cm, e)
		    cm.state.focused = true
		    addClass(cm.display.wrapper, "CodeMirror-focused")
		    // This test prevents this from firing when a context
		    // menu is closed (since the input reset would kill the
		    // select-all detection hack)
		    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
		      cm.display.input.reset()
		      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20) } // Issue #1730
		    }
		    cm.display.input.receivedFocus()
		  }
		  restartBlink(cm)
		}
		function onBlur(cm, e) {
		  if (cm.state.delayingBlurEvent) { return }

		  if (cm.state.focused) {
		    signal(cm, "blur", cm, e)
		    cm.state.focused = false
		    rmClass(cm.display.wrapper, "CodeMirror-focused")
		  }
		  clearInterval(cm.display.blinker)
		  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false } }, 150)
		}

		// Re-align line numbers and gutter marks to compensate for
		// horizontal scrolling.
		function alignHorizontally(cm) {
		  var display = cm.display, view = display.view
		  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
		  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft
		  var gutterW = display.gutters.offsetWidth, left = comp + "px"
		  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
		    if (cm.options.fixedGutter) {
		      if (view[i].gutter)
		        { view[i].gutter.style.left = left }
		      if (view[i].gutterBackground)
		        { view[i].gutterBackground.style.left = left }
		    }
		    var align = view[i].alignable
		    if (align) { for (var j = 0; j < align.length; j++)
		      { align[j].style.left = left } }
		  } }
		  if (cm.options.fixedGutter)
		    { display.gutters.style.left = (comp + gutterW) + "px" }
		}

		// Used to ensure that the line number gutter is still the right
		// size for the current document size. Returns true when an update
		// is needed.
		function maybeUpdateLineNumberWidth(cm) {
		  if (!cm.options.lineNumbers) { return false }
		  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display
		  if (last.length != display.lineNumChars) {
		    var test = display.measure.appendChild(elt("div", [elt("div", last)],
		                                               "CodeMirror-linenumber CodeMirror-gutter-elt"))
		    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW
		    display.lineGutter.style.width = ""
		    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1
		    display.lineNumWidth = display.lineNumInnerWidth + padding
		    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1
		    display.lineGutter.style.width = display.lineNumWidth + "px"
		    updateGutterSpace(cm)
		    return true
		  }
		  return false
		}

		// Read the actual heights of the rendered lines, and update their
		// stored heights to match.
		function updateHeightsInViewport(cm) {
		  var display = cm.display
		  var prevBottom = display.lineDiv.offsetTop
		  for (var i = 0; i < display.view.length; i++) {
		    var cur = display.view[i], height = (void 0)
		    if (cur.hidden) { continue }
		    if (ie && ie_version < 8) {
		      var bot = cur.node.offsetTop + cur.node.offsetHeight
		      height = bot - prevBottom
		      prevBottom = bot
		    } else {
		      var box = cur.node.getBoundingClientRect()
		      height = box.bottom - box.top
		    }
		    var diff = cur.line.height - height
		    if (height < 2) { height = textHeight(display) }
		    if (diff > .001 || diff < -.001) {
		      updateLineHeight(cur.line, height)
		      updateWidgetHeight(cur.line)
		      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
		        { updateWidgetHeight(cur.rest[j]) } }
		    }
		  }
		}

		// Read and store the height of line widgets associated with the
		// given line.
		function updateWidgetHeight(line) {
		  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)
		    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight } }
		}

		// Compute the lines that are visible in a given viewport (defaults
		// the the current scroll position). viewport may contain top,
		// height, and ensure (see op.scrollToPos) properties.
		function visibleLines(display, doc, viewport) {
		  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop
		  top = Math.floor(top - paddingTop(display))
		  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight

		  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom)
		  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
		  // forces those lines into the viewport (if possible).
		  if (viewport && viewport.ensure) {
		    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line
		    if (ensureFrom < from) {
		      from = ensureFrom
		      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)
		    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
		      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight)
		      to = ensureTo
		    }
		  }
		  return {from: from, to: Math.max(to, from + 1)}
		}

		// Sync the scrollable area and scrollbars, ensure the viewport
		// covers the visible area.
		function setScrollTop(cm, val) {
		  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
		  cm.doc.scrollTop = val
		  if (!gecko) { updateDisplaySimple(cm, {top: val}) }
		  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val }
		  cm.display.scrollbars.setScrollTop(val)
		  if (gecko) { updateDisplaySimple(cm) }
		  startWorker(cm, 100)
		}
		// Sync scroller and scrollbar, ensure the gutter elements are
		// aligned.
		function setScrollLeft(cm, val, isScroller) {
		  if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }
		  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)
		  cm.doc.scrollLeft = val
		  alignHorizontally(cm)
		  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val }
		  cm.display.scrollbars.setScrollLeft(val)
		}

		// Since the delta values reported on mouse wheel events are
		// unstandardized between browsers and even browser versions, and
		// generally horribly unpredictable, this code starts by measuring
		// the scroll effect that the first few mouse wheel events have,
		// and, from that, detects the way it can convert deltas to pixel
		// offsets afterwards.
		//
		// The reason we want to know the amount a wheel event will scroll
		// is that it gives us a chance to update the display before the
		// actual scrolling happens, reducing flickering.

		var wheelSamples = 0;
		var wheelPixelsPerUnit = null;
		// Fill in a browser-detected starting value on browsers where we
		// know one. These don't have to be accurate -- the result of them
		// being wrong would just be a slight flicker on the first wheel
		// scroll (if it is large enough).
		if (ie) { wheelPixelsPerUnit = -.53 }
		else if (gecko) { wheelPixelsPerUnit = 15 }
		else if (chrome) { wheelPixelsPerUnit = -.7 }
		else if (safari) { wheelPixelsPerUnit = -1/3 }

		function wheelEventDelta(e) {
		  var dx = e.wheelDeltaX, dy = e.wheelDeltaY
		  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail }
		  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail }
		  else if (dy == null) { dy = e.wheelDelta }
		  return {x: dx, y: dy}
		}
		function wheelEventPixels(e) {
		  var delta = wheelEventDelta(e)
		  delta.x *= wheelPixelsPerUnit
		  delta.y *= wheelPixelsPerUnit
		  return delta
		}

		function onScrollWheel(cm, e) {
		  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y

		  var display = cm.display, scroll = display.scroller
		  // Quit if there's nothing to scroll here
		  var canScrollX = scroll.scrollWidth > scroll.clientWidth
		  var canScrollY = scroll.scrollHeight > scroll.clientHeight
		  if (!(dx && canScrollX || dy && canScrollY)) { return }

		  // Webkit browsers on OS X abort momentum scrolls when the target
		  // of the scroll event is removed from the scrollable element.
		  // This hack (see related code in patchDisplay) makes sure the
		  // element is kept around.
		  if (dy && mac && webkit) {
		    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
		      for (var i = 0; i < view.length; i++) {
		        if (view[i].node == cur) {
		          cm.display.currentWheelTarget = cur
		          break outer
		        }
		      }
		    }
		  }

		  // On some browsers, horizontal scrolling will cause redraws to
		  // happen before the gutter has been realigned, causing it to
		  // wriggle around in a most unseemly way. When we have an
		  // estimated pixels/delta value, we just handle horizontal
		  // scrolling entirely here. It'll be slightly off from native, but
		  // better than glitching out.
		  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
		    if (dy && canScrollY)
		      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))) }
		    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)))
		    // Only prevent default scrolling if vertical scrolling is
		    // actually possible. Otherwise, it causes vertical scroll
		    // jitter on OSX trackpads when deltaX is small and deltaY
		    // is large (issue #3579)
		    if (!dy || (dy && canScrollY))
		      { e_preventDefault(e) }
		    display.wheelStartX = null // Abort measurement, if in progress
		    return
		  }

		  // 'Project' the visible viewport to cover the area that is being
		  // scrolled into view (if we know enough to estimate it).
		  if (dy && wheelPixelsPerUnit != null) {
		    var pixels = dy * wheelPixelsPerUnit
		    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight
		    if (pixels < 0) { top = Math.max(0, top + pixels - 50) }
		    else { bot = Math.min(cm.doc.height, bot + pixels + 50) }
		    updateDisplaySimple(cm, {top: top, bottom: bot})
		  }

		  if (wheelSamples < 20) {
		    if (display.wheelStartX == null) {
		      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop
		      display.wheelDX = dx; display.wheelDY = dy
		      setTimeout(function () {
		        if (display.wheelStartX == null) { return }
		        var movedX = scroll.scrollLeft - display.wheelStartX
		        var movedY = scroll.scrollTop - display.wheelStartY
		        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
		          (movedX && display.wheelDX && movedX / display.wheelDX)
		        display.wheelStartX = display.wheelStartY = null
		        if (!sample) { return }
		        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1)
		        ++wheelSamples
		      }, 200)
		    } else {
		      display.wheelDX += dx; display.wheelDY += dy
		    }
		  }
		}

		// SCROLLBARS

		// Prepare DOM reads needed to update the scrollbars. Done in one
		// shot to minimize update/measure roundtrips.
		function measureForScrollbars(cm) {
		  var d = cm.display, gutterW = d.gutters.offsetWidth
		  var docH = Math.round(cm.doc.height + paddingVert(cm.display))
		  return {
		    clientHeight: d.scroller.clientHeight,
		    viewHeight: d.wrapper.clientHeight,
		    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
		    viewWidth: d.wrapper.clientWidth,
		    barLeft: cm.options.fixedGutter ? gutterW : 0,
		    docHeight: docH,
		    scrollHeight: docH + scrollGap(cm) + d.barHeight,
		    nativeBarWidth: d.nativeBarWidth,
		    gutterWidth: gutterW
		  }
		}

		var NativeScrollbars = function(place, scroll, cm) {
		  this.cm = cm
		  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar")
		  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar")
		  place(vert); place(horiz)

		  on(vert, "scroll", function () {
		    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical") }
		  })
		  on(horiz, "scroll", function () {
		    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal") }
		  })

		  this.checkedZeroWidth = false
		  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
		  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px" }
		};

		NativeScrollbars.prototype.update = function (measure) {
		  var needsH = measure.scrollWidth > measure.clientWidth + 1
		  var needsV = measure.scrollHeight > measure.clientHeight + 1
		  var sWidth = measure.nativeBarWidth

		  if (needsV) {
		    this.vert.style.display = "block"
		    this.vert.style.bottom = needsH ? sWidth + "px" : "0"
		    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)
		    // A bug in IE8 can cause this value to be negative, so guard it.
		    this.vert.firstChild.style.height =
		      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px"
		  } else {
		    this.vert.style.display = ""
		    this.vert.firstChild.style.height = "0"
		  }

		  if (needsH) {
		    this.horiz.style.display = "block"
		    this.horiz.style.right = needsV ? sWidth + "px" : "0"
		    this.horiz.style.left = measure.barLeft + "px"
		    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)
		    this.horiz.firstChild.style.width =
		      (measure.scrollWidth - measure.clientWidth + totalWidth) + "px"
		  } else {
		    this.horiz.style.display = ""
		    this.horiz.firstChild.style.width = "0"
		  }

		  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
		    if (sWidth == 0) { this.zeroWidthHack() }
		    this.checkedZeroWidth = true
		  }

		  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
		};

		NativeScrollbars.prototype.setScrollLeft = function (pos) {
		  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos }
		  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz) }
		};

		NativeScrollbars.prototype.setScrollTop = function (pos) {
		  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos }
		  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert) }
		};

		NativeScrollbars.prototype.zeroWidthHack = function () {
		  var w = mac && !mac_geMountainLion ? "12px" : "18px"
		  this.horiz.style.height = this.vert.style.width = w
		  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none"
		  this.disableHoriz = new Delayed
		  this.disableVert = new Delayed
		};

		NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {
		  bar.style.pointerEvents = "auto"
		  function maybeDisable() {
		    // To find out whether the scrollbar is still visible, we
		    // check whether the element under the pixel in the bottom
		    // left corner of the scrollbar box is the scrollbar box
		    // itself (when the bar is still visible) or its filler child
		    // (when the bar is hidden). If it is still visible, we keep
		    // it enabled, if it's hidden, we disable pointer events.
		    var box = bar.getBoundingClientRect()
		    var elt = document.elementFromPoint(box.left + 1, box.bottom - 1)
		    if (elt != bar) { bar.style.pointerEvents = "none" }
		    else { delay.set(1000, maybeDisable) }
		  }
		  delay.set(1000, maybeDisable)
		};

		NativeScrollbars.prototype.clear = function () {
		  var parent = this.horiz.parentNode
		  parent.removeChild(this.horiz)
		  parent.removeChild(this.vert)
		};

		var NullScrollbars = function () {};

		NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
		NullScrollbars.prototype.setScrollLeft = function () {};
		NullScrollbars.prototype.setScrollTop = function () {};
		NullScrollbars.prototype.clear = function () {};

		function updateScrollbars(cm, measure) {
		  if (!measure) { measure = measureForScrollbars(cm) }
		  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight
		  updateScrollbarsInner(cm, measure)
		  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
		    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
		      { updateHeightsInViewport(cm) }
		    updateScrollbarsInner(cm, measureForScrollbars(cm))
		    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight
		  }
		}

		// Re-synchronize the fake scrollbars with the actual size of the
		// content.
		function updateScrollbarsInner(cm, measure) {
		  var d = cm.display
		  var sizes = d.scrollbars.update(measure)

		  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px"
		  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px"
		  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"

		  if (sizes.right && sizes.bottom) {
		    d.scrollbarFiller.style.display = "block"
		    d.scrollbarFiller.style.height = sizes.bottom + "px"
		    d.scrollbarFiller.style.width = sizes.right + "px"
		  } else { d.scrollbarFiller.style.display = "" }
		  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
		    d.gutterFiller.style.display = "block"
		    d.gutterFiller.style.height = sizes.bottom + "px"
		    d.gutterFiller.style.width = measure.gutterWidth + "px"
		  } else { d.gutterFiller.style.display = "" }
		}

		var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars}

		function initScrollbars(cm) {
		  if (cm.display.scrollbars) {
		    cm.display.scrollbars.clear()
		    if (cm.display.scrollbars.addClass)
		      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
		  }

		  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
		    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)
		    // Prevent clicks in the scrollbars from killing focus
		    on(node, "mousedown", function () {
		      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0) }
		    })
		    node.setAttribute("cm-not-content", "true")
		  }, function (pos, axis) {
		    if (axis == "horizontal") { setScrollLeft(cm, pos) }
		    else { setScrollTop(cm, pos) }
		  }, cm)
		  if (cm.display.scrollbars.addClass)
		    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
		}

		// SCROLLING THINGS INTO VIEW

		// If an editor sits on the top or bottom of the window, partially
		// scrolled out of view, this ensures that the cursor is visible.
		function maybeScrollWindow(cm, coords) {
		  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

		  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null
		  if (coords.top + box.top < 0) { doScroll = true }
		  else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false }
		  if (doScroll != null && !phantom) {
		    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (coords.left) + "px; width: 2px;"))
		    cm.display.lineSpace.appendChild(scrollNode)
		    scrollNode.scrollIntoView(doScroll)
		    cm.display.lineSpace.removeChild(scrollNode)
		  }
		}

		// Scroll a given position into view (immediately), verifying that
		// it actually became visible (as line heights are accurately
		// measured, the position of something may 'drift' during drawing).
		function scrollPosIntoView(cm, pos, end, margin) {
		  if (margin == null) { margin = 0 }
		  var coords
		  for (var limit = 0; limit < 5; limit++) {
		    var changed = false
		    coords = cursorCoords(cm, pos)
		    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)
		    var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
		                                       Math.min(coords.top, endCoords.top) - margin,
		                                       Math.max(coords.left, endCoords.left),
		                                       Math.max(coords.bottom, endCoords.bottom) + margin)
		    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft
		    if (scrollPos.scrollTop != null) {
		      setScrollTop(cm, scrollPos.scrollTop)
		      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true }
		    }
		    if (scrollPos.scrollLeft != null) {
		      setScrollLeft(cm, scrollPos.scrollLeft)
		      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true }
		    }
		    if (!changed) { break }
		  }
		  return coords
		}

		// Scroll a given set of coordinates into view (immediately).
		function scrollIntoView(cm, x1, y1, x2, y2) {
		  var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2)
		  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop) }
		  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft) }
		}

		// Calculate a new scroll position needed to scroll the given
		// rectangle into view. Returns an object with scrollTop and
		// scrollLeft properties. When these are undefined, the
		// vertical/horizontal position does not need to be adjusted.
		function calculateScrollPos(cm, x1, y1, x2, y2) {
		  var display = cm.display, snapMargin = textHeight(cm.display)
		  if (y1 < 0) { y1 = 0 }
		  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop
		  var screen = displayHeight(cm), result = {}
		  if (y2 - y1 > screen) { y2 = y1 + screen }
		  var docBottom = cm.doc.height + paddingVert(display)
		  var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin
		  if (y1 < screentop) {
		    result.scrollTop = atTop ? 0 : y1
		  } else if (y2 > screentop + screen) {
		    var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen)
		    if (newTop != screentop) { result.scrollTop = newTop }
		  }

		  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft
		  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0)
		  var tooWide = x2 - x1 > screenw
		  if (tooWide) { x2 = x1 + screenw }
		  if (x1 < 10)
		    { result.scrollLeft = 0 }
		  else if (x1 < screenleft)
		    { result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) }
		  else if (x2 > screenw + screenleft - 3)
		    { result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw }
		  return result
		}

		// Store a relative adjustment to the scroll position in the current
		// operation (to be applied when the operation finishes).
		function addToScrollPos(cm, left, top) {
		  if (left != null || top != null) { resolveScrollToPos(cm) }
		  if (left != null)
		    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left }
		  if (top != null)
		    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top }
		}

		// Make sure that at the end of the operation the current cursor is
		// shown.
		function ensureCursorVisible(cm) {
		  resolveScrollToPos(cm)
		  var cur = cm.getCursor(), from = cur, to = cur
		  if (!cm.options.lineWrapping) {
		    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur
		    to = Pos(cur.line, cur.ch + 1)
		  }
		  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true}
		}

		// When an operation has its scrollToPos property set, and another
		// scroll action is applied before the end of the operation, this
		// 'simulates' scrolling that position into view in a cheap way, so
		// that the effect of intermediate scroll commands is not ignored.
		function resolveScrollToPos(cm) {
		  var range = cm.curOp.scrollToPos
		  if (range) {
		    cm.curOp.scrollToPos = null
		    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to)
		    var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
		                                  Math.min(from.top, to.top) - range.margin,
		                                  Math.max(from.right, to.right),
		                                  Math.max(from.bottom, to.bottom) + range.margin)
		    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)
		  }
		}

		// Operations are used to wrap a series of changes to the editor
		// state in such a way that each change won't have to update the
		// cursor and display (which would be awkward, slow, and
		// error-prone). Instead, display updates are batched and then all
		// combined and executed at once.

		var nextOpId = 0
		// Start a new operation.
		function startOperation(cm) {
		  cm.curOp = {
		    cm: cm,
		    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
		    startHeight: cm.doc.height, // Used to detect need to update scrollbar
		    forceUpdate: false,      // Used to force a redraw
		    updateInput: null,       // Whether to reset the input textarea
		    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
		    changeObjs: null,        // Accumulated changes, for firing change events
		    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
		    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
		    selectionChanged: false, // Whether the selection needs to be redrawn
		    updateMaxLine: false,    // Set when the widest line needs to be determined anew
		    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
		    scrollToPos: null,       // Used to scroll to a specific position
		    focus: false,
		    id: ++nextOpId           // Unique ID
		  }
		  pushOperation(cm.curOp)
		}

		// Finish an operation, updating the display and signalling delayed events
		function endOperation(cm) {
		  var op = cm.curOp
		  finishOperation(op, function (group) {
		    for (var i = 0; i < group.ops.length; i++)
		      { group.ops[i].cm.curOp = null }
		    endOperations(group)
		  })
		}

		// The DOM updates done when an operation finishes are batched so
		// that the minimum number of relayouts are required.
		function endOperations(group) {
		  var ops = group.ops
		  for (var i = 0; i < ops.length; i++) // Read DOM
		    { endOperation_R1(ops[i]) }
		  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
		    { endOperation_W1(ops[i$1]) }
		  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
		    { endOperation_R2(ops[i$2]) }
		  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
		    { endOperation_W2(ops[i$3]) }
		  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
		    { endOperation_finish(ops[i$4]) }
		}

		function endOperation_R1(op) {
		  var cm = op.cm, display = cm.display
		  maybeClipScrollbars(cm)
		  if (op.updateMaxLine) { findMaxLine(cm) }

		  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
		    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
		                       op.scrollToPos.to.line >= display.viewTo) ||
		    display.maxLineChanged && cm.options.lineWrapping
		  op.update = op.mustUpdate &&
		    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)
		}

		function endOperation_W1(op) {
		  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
		}

		function endOperation_R2(op) {
		  var cm = op.cm, display = cm.display
		  if (op.updatedDisplay) { updateHeightsInViewport(cm) }

		  op.barMeasure = measureForScrollbars(cm)

		  // If the max line changed since it was last measured, measure it,
		  // and ensure the document's width matches it.
		  // updateDisplay_W2 will use these properties to do the actual resizing
		  if (display.maxLineChanged && !cm.options.lineWrapping) {
		    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3
		    cm.display.sizerWidth = op.adjustWidthTo
		    op.barMeasure.scrollWidth =
		      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth)
		    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))
		  }

		  if (op.updatedDisplay || op.selectionChanged)
		    { op.preparedSelection = display.input.prepareSelection(op.focus) }
		}

		function endOperation_W2(op) {
		  var cm = op.cm

		  if (op.adjustWidthTo != null) {
		    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px"
		    if (op.maxScrollLeft < cm.doc.scrollLeft)
		      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true) }
		    cm.display.maxLineChanged = false
		  }

		  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())
		  if (op.preparedSelection)
		    { cm.display.input.showSelection(op.preparedSelection, takeFocus) }
		  if (op.updatedDisplay || op.startHeight != cm.doc.height)
		    { updateScrollbars(cm, op.barMeasure) }
		  if (op.updatedDisplay)
		    { setDocumentHeight(cm, op.barMeasure) }

		  if (op.selectionChanged) { restartBlink(cm) }

		  if (cm.state.focused && op.updateInput)
		    { cm.display.input.reset(op.typing) }
		  if (takeFocus) { ensureFocus(op.cm) }
		}

		function endOperation_finish(op) {
		  var cm = op.cm, display = cm.display, doc = cm.doc

		  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update) }

		  // Abort mouse wheel delta measurement, when scrolling explicitly
		  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
		    { display.wheelStartX = display.wheelStartY = null }

		  // Propagate the scroll position to the actual DOM scroller
		  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
		    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop))
		    display.scrollbars.setScrollTop(doc.scrollTop)
		    display.scroller.scrollTop = doc.scrollTop
		  }
		  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
		    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft))
		    display.scrollbars.setScrollLeft(doc.scrollLeft)
		    display.scroller.scrollLeft = doc.scrollLeft
		    alignHorizontally(cm)
		  }
		  // If we need to scroll a specific position into view, do so.
		  if (op.scrollToPos) {
		    var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
		                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin)
		    if (op.scrollToPos.isCursor && cm.state.focused) { maybeScrollWindow(cm, coords) }
		  }

		  // Fire events for markers that are hidden/unidden by editing or
		  // undoing
		  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers
		  if (hidden) { for (var i = 0; i < hidden.length; ++i)
		    { if (!hidden[i].lines.length) { signal(hidden[i], "hide") } } }
		  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
		    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide") } } }

		  if (display.wrapper.offsetHeight)
		    { doc.scrollTop = cm.display.scroller.scrollTop }

		  // Fire change events, and delayed event handlers
		  if (op.changeObjs)
		    { signal(cm, "changes", cm, op.changeObjs) }
		  if (op.update)
		    { op.update.finish() }
		}

		// Run the given function in an operation
		function runInOp(cm, f) {
		  if (cm.curOp) { return f() }
		  startOperation(cm)
		  try { return f() }
		  finally { endOperation(cm) }
		}
		// Wraps a function in an operation. Returns the wrapped function.
		function operation(cm, f) {
		  return function() {
		    if (cm.curOp) { return f.apply(cm, arguments) }
		    startOperation(cm)
		    try { return f.apply(cm, arguments) }
		    finally { endOperation(cm) }
		  }
		}
		// Used to add methods to editor and doc instances, wrapping them in
		// operations.
		function methodOp(f) {
		  return function() {
		    if (this.curOp) { return f.apply(this, arguments) }
		    startOperation(this)
		    try { return f.apply(this, arguments) }
		    finally { endOperation(this) }
		  }
		}
		function docMethodOp(f) {
		  return function() {
		    var cm = this.cm
		    if (!cm || cm.curOp) { return f.apply(this, arguments) }
		    startOperation(cm)
		    try { return f.apply(this, arguments) }
		    finally { endOperation(cm) }
		  }
		}

		// Updates the display.view data structure for a given change to the
		// document. From and to are in pre-change coordinates. Lendiff is
		// the amount of lines added or subtracted by the change. This is
		// used for changes that span multiple lines, or change the way
		// lines are divided into visual lines. regLineChange (below)
		// registers single-line changes.
		function regChange(cm, from, to, lendiff) {
		  if (from == null) { from = cm.doc.first }
		  if (to == null) { to = cm.doc.first + cm.doc.size }
		  if (!lendiff) { lendiff = 0 }

		  var display = cm.display
		  if (lendiff && to < display.viewTo &&
		      (display.updateLineNumbers == null || display.updateLineNumbers > from))
		    { display.updateLineNumbers = from }

		  cm.curOp.viewChanged = true

		  if (from >= display.viewTo) { // Change after
		    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
		      { resetView(cm) }
		  } else if (to <= display.viewFrom) { // Change before
		    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
		      resetView(cm)
		    } else {
		      display.viewFrom += lendiff
		      display.viewTo += lendiff
		    }
		  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
		    resetView(cm)
		  } else if (from <= display.viewFrom) { // Top overlap
		    var cut = viewCuttingPoint(cm, to, to + lendiff, 1)
		    if (cut) {
		      display.view = display.view.slice(cut.index)
		      display.viewFrom = cut.lineN
		      display.viewTo += lendiff
		    } else {
		      resetView(cm)
		    }
		  } else if (to >= display.viewTo) { // Bottom overlap
		    var cut$1 = viewCuttingPoint(cm, from, from, -1)
		    if (cut$1) {
		      display.view = display.view.slice(0, cut$1.index)
		      display.viewTo = cut$1.lineN
		    } else {
		      resetView(cm)
		    }
		  } else { // Gap in the middle
		    var cutTop = viewCuttingPoint(cm, from, from, -1)
		    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)
		    if (cutTop && cutBot) {
		      display.view = display.view.slice(0, cutTop.index)
		        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
		        .concat(display.view.slice(cutBot.index))
		      display.viewTo += lendiff
		    } else {
		      resetView(cm)
		    }
		  }

		  var ext = display.externalMeasured
		  if (ext) {
		    if (to < ext.lineN)
		      { ext.lineN += lendiff }
		    else if (from < ext.lineN + ext.size)
		      { display.externalMeasured = null }
		  }
		}

		// Register a change to a single line. Type must be one of "text",
		// "gutter", "class", "widget"
		function regLineChange(cm, line, type) {
		  cm.curOp.viewChanged = true
		  var display = cm.display, ext = cm.display.externalMeasured
		  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
		    { display.externalMeasured = null }

		  if (line < display.viewFrom || line >= display.viewTo) { return }
		  var lineView = display.view[findViewIndex(cm, line)]
		  if (lineView.node == null) { return }
		  var arr = lineView.changes || (lineView.changes = [])
		  if (indexOf(arr, type) == -1) { arr.push(type) }
		}

		// Clear the view.
		function resetView(cm) {
		  cm.display.viewFrom = cm.display.viewTo = cm.doc.first
		  cm.display.view = []
		  cm.display.viewOffset = 0
		}

		function viewCuttingPoint(cm, oldN, newN, dir) {
		  var index = findViewIndex(cm, oldN), diff, view = cm.display.view
		  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
		    { return {index: index, lineN: newN} }
		  var n = cm.display.viewFrom
		  for (var i = 0; i < index; i++)
		    { n += view[i].size }
		  if (n != oldN) {
		    if (dir > 0) {
		      if (index == view.length - 1) { return null }
		      diff = (n + view[index].size) - oldN
		      index++
		    } else {
		      diff = n - oldN
		    }
		    oldN += diff; newN += diff
		  }
		  while (visualLineNo(cm.doc, newN) != newN) {
		    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
		    newN += dir * view[index - (dir < 0 ? 1 : 0)].size
		    index += dir
		  }
		  return {index: index, lineN: newN}
		}

		// Force the view to cover a given range, adding empty view element
		// or clipping off existing ones as needed.
		function adjustView(cm, from, to) {
		  var display = cm.display, view = display.view
		  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
		    display.view = buildViewArray(cm, from, to)
		    display.viewFrom = from
		  } else {
		    if (display.viewFrom > from)
		      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) }
		    else if (display.viewFrom < from)
		      { display.view = display.view.slice(findViewIndex(cm, from)) }
		    display.viewFrom = from
		    if (display.viewTo < to)
		      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) }
		    else if (display.viewTo > to)
		      { display.view = display.view.slice(0, findViewIndex(cm, to)) }
		  }
		  display.viewTo = to
		}

		// Count the number of lines in the view whose DOM representation is
		// out of date (or nonexistent).
		function countDirtyView(cm) {
		  var view = cm.display.view, dirty = 0
		  for (var i = 0; i < view.length; i++) {
		    var lineView = view[i]
		    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty }
		  }
		  return dirty
		}

		// HIGHLIGHT WORKER

		function startWorker(cm, time) {
		  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
		    { cm.state.highlight.set(time, bind(highlightWorker, cm)) }
		}

		function highlightWorker(cm) {
		  var doc = cm.doc
		  if (doc.frontier < doc.first) { doc.frontier = doc.first }
		  if (doc.frontier >= cm.display.viewTo) { return }
		  var end = +new Date + cm.options.workTime
		  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier))
		  var changedLines = []

		  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
		    if (doc.frontier >= cm.display.viewFrom) { // Visible
		      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength
		      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true)
		      line.styles = highlighted.styles
		      var oldCls = line.styleClasses, newCls = highlighted.classes
		      if (newCls) { line.styleClasses = newCls }
		      else if (oldCls) { line.styleClasses = null }
		      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
		        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass)
		      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i] }
		      if (ischange) { changedLines.push(doc.frontier) }
		      line.stateAfter = tooLong ? state : copyState(doc.mode, state)
		    } else {
		      if (line.text.length <= cm.options.maxHighlightLength)
		        { processLine(cm, line.text, state) }
		      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null
		    }
		    ++doc.frontier
		    if (+new Date > end) {
		      startWorker(cm, cm.options.workDelay)
		      return true
		    }
		  })
		  if (changedLines.length) { runInOp(cm, function () {
		    for (var i = 0; i < changedLines.length; i++)
		      { regLineChange(cm, changedLines[i], "text") }
		  }) }
		}

		// DISPLAY DRAWING

		var DisplayUpdate = function(cm, viewport, force) {
		  var display = cm.display

		  this.viewport = viewport
		  // Store some values that we'll need later (but don't want to force a relayout for)
		  this.visible = visibleLines(display, cm.doc, viewport)
		  this.editorIsHidden = !display.wrapper.offsetWidth
		  this.wrapperHeight = display.wrapper.clientHeight
		  this.wrapperWidth = display.wrapper.clientWidth
		  this.oldDisplayWidth = displayWidth(cm)
		  this.force = force
		  this.dims = getDimensions(cm)
		  this.events = []
		};

		DisplayUpdate.prototype.signal = function (emitter, type) {
		  if (hasHandler(emitter, type))
		    { this.events.push(arguments) }
		};
		DisplayUpdate.prototype.finish = function () {
		    var this$1 = this;

		  for (var i = 0; i < this.events.length; i++)
		    { signal.apply(null, this$1.events[i]) }
		};

		function maybeClipScrollbars(cm) {
		  var display = cm.display
		  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
		    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth
		    display.heightForcer.style.height = scrollGap(cm) + "px"
		    display.sizer.style.marginBottom = -display.nativeBarWidth + "px"
		    display.sizer.style.borderRightWidth = scrollGap(cm) + "px"
		    display.scrollbarsClipped = true
		  }
		}

		// Does the actual updating of the line display. Bails out
		// (returning false) when there is nothing to be done and forced is
		// false.
		function updateDisplayIfNeeded(cm, update) {
		  var display = cm.display, doc = cm.doc

		  if (update.editorIsHidden) {
		    resetView(cm)
		    return false
		  }

		  // Bail out if the visible area is already rendered and nothing changed.
		  if (!update.force &&
		      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
		      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
		      display.renderedView == display.view && countDirtyView(cm) == 0)
		    { return false }

		  if (maybeUpdateLineNumberWidth(cm)) {
		    resetView(cm)
		    update.dims = getDimensions(cm)
		  }

		  // Compute a suitable new viewport (from & to)
		  var end = doc.first + doc.size
		  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)
		  var to = Math.min(end, update.visible.to + cm.options.viewportMargin)
		  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom) }
		  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo) }
		  if (sawCollapsedSpans) {
		    from = visualLineNo(cm.doc, from)
		    to = visualLineEndNo(cm.doc, to)
		  }

		  var different = from != display.viewFrom || to != display.viewTo ||
		    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth
		  adjustView(cm, from, to)

		  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))
		  // Position the mover div to align with the current scroll position
		  cm.display.mover.style.top = display.viewOffset + "px"

		  var toUpdate = countDirtyView(cm)
		  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
		      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
		    { return false }

		  // For big changes, we hide the enclosing element during the
		  // update, since that speeds up the operations on most browsers.
		  var focused = activeElt()
		  if (toUpdate > 4) { display.lineDiv.style.display = "none" }
		  patchDisplay(cm, display.updateLineNumbers, update.dims)
		  if (toUpdate > 4) { display.lineDiv.style.display = "" }
		  display.renderedView = display.view
		  // There might have been a widget with a focused element that got
		  // hidden or updated, if so re-focus it.
		  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus() }

		  // Prevent selection and cursors from interfering with the scroll
		  // width and height.
		  removeChildren(display.cursorDiv)
		  removeChildren(display.selectionDiv)
		  display.gutters.style.height = display.sizer.style.minHeight = 0

		  if (different) {
		    display.lastWrapHeight = update.wrapperHeight
		    display.lastWrapWidth = update.wrapperWidth
		    startWorker(cm, 400)
		  }

		  display.updateLineNumbers = null

		  return true
		}

		function postUpdateDisplay(cm, update) {
		  var viewport = update.viewport

		  for (var first = true;; first = false) {
		    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
		      // Clip forced viewport to actual scrollable area.
		      if (viewport && viewport.top != null)
		        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)} }
		      // Updated line heights might result in the drawn area not
		      // actually covering the viewport. Keep looping until it does.
		      update.visible = visibleLines(cm.display, cm.doc, viewport)
		      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
		        { break }
		    }
		    if (!updateDisplayIfNeeded(cm, update)) { break }
		    updateHeightsInViewport(cm)
		    var barMeasure = measureForScrollbars(cm)
		    updateSelection(cm)
		    updateScrollbars(cm, barMeasure)
		    setDocumentHeight(cm, barMeasure)
		  }

		  update.signal(cm, "update", cm)
		  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
		    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo)
		    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo
		  }
		}

		function updateDisplaySimple(cm, viewport) {
		  var update = new DisplayUpdate(cm, viewport)
		  if (updateDisplayIfNeeded(cm, update)) {
		    updateHeightsInViewport(cm)
		    postUpdateDisplay(cm, update)
		    var barMeasure = measureForScrollbars(cm)
		    updateSelection(cm)
		    updateScrollbars(cm, barMeasure)
		    setDocumentHeight(cm, barMeasure)
		    update.finish()
		  }
		}

		// Sync the actual display DOM structure with display.view, removing
		// nodes for lines that are no longer in view, and creating the ones
		// that are not there yet, and updating the ones that are out of
		// date.
		function patchDisplay(cm, updateNumbersFrom, dims) {
		  var display = cm.display, lineNumbers = cm.options.lineNumbers
		  var container = display.lineDiv, cur = container.firstChild

		  function rm(node) {
		    var next = node.nextSibling
		    // Works around a throw-scroll bug in OS X Webkit
		    if (webkit && mac && cm.display.currentWheelTarget == node)
		      { node.style.display = "none" }
		    else
		      { node.parentNode.removeChild(node) }
		    return next
		  }

		  var view = display.view, lineN = display.viewFrom
		  // Loop over the elements in the view, syncing cur (the DOM nodes
		  // in display.lineDiv) with the view as we go.
		  for (var i = 0; i < view.length; i++) {
		    var lineView = view[i]
		    if (lineView.hidden) {
		    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
		      var node = buildLineElement(cm, lineView, lineN, dims)
		      container.insertBefore(node, cur)
		    } else { // Already drawn
		      while (cur != lineView.node) { cur = rm(cur) }
		      var updateNumber = lineNumbers && updateNumbersFrom != null &&
		        updateNumbersFrom <= lineN && lineView.lineNumber
		      if (lineView.changes) {
		        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false }
		        updateLineForChanges(cm, lineView, lineN, dims)
		      }
		      if (updateNumber) {
		        removeChildren(lineView.lineNumber)
		        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))
		      }
		      cur = lineView.node.nextSibling
		    }
		    lineN += lineView.size
		  }
		  while (cur) { cur = rm(cur) }
		}

		function updateGutterSpace(cm) {
		  var width = cm.display.gutters.offsetWidth
		  cm.display.sizer.style.marginLeft = width + "px"
		}

		function setDocumentHeight(cm, measure) {
		  cm.display.sizer.style.minHeight = measure.docHeight + "px"
		  cm.display.heightForcer.style.top = measure.docHeight + "px"
		  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px"
		}

		// Rebuild the gutter elements, ensure the margin to the left of the
		// code matches their width.
		function updateGutters(cm) {
		  var gutters = cm.display.gutters, specs = cm.options.gutters
		  removeChildren(gutters)
		  var i = 0
		  for (; i < specs.length; ++i) {
		    var gutterClass = specs[i]
		    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass))
		    if (gutterClass == "CodeMirror-linenumbers") {
		      cm.display.lineGutter = gElt
		      gElt.style.width = (cm.display.lineNumWidth || 1) + "px"
		    }
		  }
		  gutters.style.display = i ? "" : "none"
		  updateGutterSpace(cm)
		}

		// Make sure the gutters options contains the element
		// "CodeMirror-linenumbers" when the lineNumbers option is true.
		function setGuttersForLineNumbers(options) {
		  var found = indexOf(options.gutters, "CodeMirror-linenumbers")
		  if (found == -1 && options.lineNumbers) {
		    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"])
		  } else if (found > -1 && !options.lineNumbers) {
		    options.gutters = options.gutters.slice(0)
		    options.gutters.splice(found, 1)
		  }
		}

		// Selection objects are immutable. A new one is created every time
		// the selection changes. A selection is one or more non-overlapping
		// (and non-touching) ranges, sorted, and an integer that indicates
		// which one is the primary selection (the one that's scrolled into
		// view, that getCursor returns, etc).
		function Selection(ranges, primIndex) {
		  this.ranges = ranges
		  this.primIndex = primIndex
		}

		Selection.prototype = {
		  primary: function() { return this.ranges[this.primIndex] },
		  equals: function(other) {
		    var this$1 = this;

		    if (other == this) { return true }
		    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
		    for (var i = 0; i < this.ranges.length; i++) {
		      var here = this$1.ranges[i], there = other.ranges[i]
		      if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) { return false }
		    }
		    return true
		  },
		  deepCopy: function() {
		    var this$1 = this;

		    var out = []
		    for (var i = 0; i < this.ranges.length; i++)
		      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)) }
		    return new Selection(out, this.primIndex)
		  },
		  somethingSelected: function() {
		    var this$1 = this;

		    for (var i = 0; i < this.ranges.length; i++)
		      { if (!this$1.ranges[i].empty()) { return true } }
		    return false
		  },
		  contains: function(pos, end) {
		    var this$1 = this;

		    if (!end) { end = pos }
		    for (var i = 0; i < this.ranges.length; i++) {
		      var range = this$1.ranges[i]
		      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
		        { return i }
		    }
		    return -1
		  }
		}

		function Range(anchor, head) {
		  this.anchor = anchor; this.head = head
		}

		Range.prototype = {
		  from: function() { return minPos(this.anchor, this.head) },
		  to: function() { return maxPos(this.anchor, this.head) },
		  empty: function() {
		    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
		  }
		}

		// Take an unsorted, potentially overlapping set of ranges, and
		// build a selection out of it. 'Consumes' ranges array (modifying
		// it).
		function normalizeSelection(ranges, primIndex) {
		  var prim = ranges[primIndex]
		  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); })
		  primIndex = indexOf(ranges, prim)
		  for (var i = 1; i < ranges.length; i++) {
		    var cur = ranges[i], prev = ranges[i - 1]
		    if (cmp(prev.to(), cur.from()) >= 0) {
		      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to())
		      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head
		      if (i <= primIndex) { --primIndex }
		      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))
		    }
		  }
		  return new Selection(ranges, primIndex)
		}

		function simpleSelection(anchor, head) {
		  return new Selection([new Range(anchor, head || anchor)], 0)
		}

		// Compute the position of the end of a change (its 'to' property
		// refers to the pre-change end).
		function changeEnd(change) {
		  if (!change.text) { return change.to }
		  return Pos(change.from.line + change.text.length - 1,
		             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
		}

		// Adjust a position to refer to the post-change position of the
		// same text, or the end of the change if the change covers it.
		function adjustForChange(pos, change) {
		  if (cmp(pos, change.from) < 0) { return pos }
		  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

		  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch
		  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch }
		  return Pos(line, ch)
		}

		function computeSelAfterChange(doc, change) {
		  var out = []
		  for (var i = 0; i < doc.sel.ranges.length; i++) {
		    var range = doc.sel.ranges[i]
		    out.push(new Range(adjustForChange(range.anchor, change),
		                       adjustForChange(range.head, change)))
		  }
		  return normalizeSelection(out, doc.sel.primIndex)
		}

		function offsetPos(pos, old, nw) {
		  if (pos.line == old.line)
		    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
		  else
		    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
		}

		// Used by replaceSelections to allow moving the selection to the
		// start or around the replaced test. Hint may be "start" or "around".
		function computeReplacedSel(doc, changes, hint) {
		  var out = []
		  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev
		  for (var i = 0; i < changes.length; i++) {
		    var change = changes[i]
		    var from = offsetPos(change.from, oldPrev, newPrev)
		    var to = offsetPos(changeEnd(change), oldPrev, newPrev)
		    oldPrev = change.to
		    newPrev = to
		    if (hint == "around") {
		      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0
		      out[i] = new Range(inv ? to : from, inv ? from : to)
		    } else {
		      out[i] = new Range(from, from)
		    }
		  }
		  return new Selection(out, doc.sel.primIndex)
		}

		// Used to get the editor into a consistent state again when options change.

		function loadMode(cm) {
		  cm.doc.mode = getMode(cm.options, cm.doc.modeOption)
		  resetModeState(cm)
		}

		function resetModeState(cm) {
		  cm.doc.iter(function (line) {
		    if (line.stateAfter) { line.stateAfter = null }
		    if (line.styles) { line.styles = null }
		  })
		  cm.doc.frontier = cm.doc.first
		  startWorker(cm, 100)
		  cm.state.modeGen++
		  if (cm.curOp) { regChange(cm) }
		}

		// DOCUMENT DATA STRUCTURE

		// By default, updates that start and end at the beginning of a line
		// are treated specially, in order to make the association of line
		// widgets and marker elements with the text behave more intuitive.
		function isWholeLineUpdate(doc, change) {
		  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
		    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
		}

		// Perform a change on the document data structure.
		function updateDoc(doc, change, markedSpans, estimateHeight) {
		  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
		  function update(line, text, spans) {
		    updateLine(line, text, spans, estimateHeight)
		    signalLater(line, "change", line, change)
		  }
		  function linesFor(start, end) {
		    var result = []
		    for (var i = start; i < end; ++i)
		      { result.push(new Line(text[i], spansFor(i), estimateHeight)) }
		    return result
		  }

		  var from = change.from, to = change.to, text = change.text
		  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line)
		  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line

		  // Adjust the line structure
		  if (change.full) {
		    doc.insert(0, linesFor(0, text.length))
		    doc.remove(text.length, doc.size - text.length)
		  } else if (isWholeLineUpdate(doc, change)) {
		    // This is a whole-line replace. Treated specially to make
		    // sure line objects move the way they are supposed to.
		    var added = linesFor(0, text.length - 1)
		    update(lastLine, lastLine.text, lastSpans)
		    if (nlines) { doc.remove(from.line, nlines) }
		    if (added.length) { doc.insert(from.line, added) }
		  } else if (firstLine == lastLine) {
		    if (text.length == 1) {
		      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans)
		    } else {
		      var added$1 = linesFor(1, text.length - 1)
		      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight))
		      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))
		      doc.insert(from.line + 1, added$1)
		    }
		  } else if (text.length == 1) {
		    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0))
		    doc.remove(from.line + 1, nlines)
		  } else {
		    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))
		    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)
		    var added$2 = linesFor(1, text.length - 1)
		    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1) }
		    doc.insert(from.line + 1, added$2)
		  }

		  signalLater(doc, "change", doc, change)
		}

		// Call f for all linked documents.
		function linkedDocs(doc, f, sharedHistOnly) {
		  function propagate(doc, skip, sharedHist) {
		    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
		      var rel = doc.linked[i]
		      if (rel.doc == skip) { continue }
		      var shared = sharedHist && rel.sharedHist
		      if (sharedHistOnly && !shared) { continue }
		      f(rel.doc, shared)
		      propagate(rel.doc, doc, shared)
		    } }
		  }
		  propagate(doc, null, true)
		}

		// Attach a document to an editor.
		function attachDoc(cm, doc) {
		  if (doc.cm) { throw new Error("This document is already in use.") }
		  cm.doc = doc
		  doc.cm = cm
		  estimateLineHeights(cm)
		  loadMode(cm)
		  if (!cm.options.lineWrapping) { findMaxLine(cm) }
		  cm.options.mode = doc.modeOption
		  regChange(cm)
		}

		function History(startGen) {
		  // Arrays of change events and selections. Doing something adds an
		  // event to done and clears undo. Undoing moves events from done
		  // to undone, redoing moves them in the other direction.
		  this.done = []; this.undone = []
		  this.undoDepth = Infinity
		  // Used to track when changes can be merged into a single undo
		  // event
		  this.lastModTime = this.lastSelTime = 0
		  this.lastOp = this.lastSelOp = null
		  this.lastOrigin = this.lastSelOrigin = null
		  // Used by the isClean() method
		  this.generation = this.maxGeneration = startGen || 1
		}

		// Create a history change event from an updateDoc-style change
		// object.
		function historyChangeFromChange(doc, change) {
		  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)}
		  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
		  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true)
		  return histChange
		}

		// Pop all selection events off the end of a history array. Stop at
		// a change event.
		function clearSelectionEvents(array) {
		  while (array.length) {
		    var last = lst(array)
		    if (last.ranges) { array.pop() }
		    else { break }
		  }
		}

		// Find the top change event in the history. Pop off selection
		// events that are in the way.
		function lastChangeEvent(hist, force) {
		  if (force) {
		    clearSelectionEvents(hist.done)
		    return lst(hist.done)
		  } else if (hist.done.length && !lst(hist.done).ranges) {
		    return lst(hist.done)
		  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
		    hist.done.pop()
		    return lst(hist.done)
		  }
		}

		// Register a change in the history. Merges changes that are within
		// a single operation, or are close together with an origin that
		// allows merging (starting with "+") into a single event.
		function addChangeToHistory(doc, change, selAfter, opId) {
		  var hist = doc.history
		  hist.undone.length = 0
		  var time = +new Date, cur
		  var last

		  if ((hist.lastOp == opId ||
		       hist.lastOrigin == change.origin && change.origin &&
		       ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
		        change.origin.charAt(0) == "*")) &&
		      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
		    // Merge this change into the last event
		    last = lst(cur.changes)
		    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
		      // Optimized case for simple insertion -- don't want to add
		      // new changesets for every character typed
		      last.to = changeEnd(change)
		    } else {
		      // Add new sub-event
		      cur.changes.push(historyChangeFromChange(doc, change))
		    }
		  } else {
		    // Can not be merged, start a new event.
		    var before = lst(hist.done)
		    if (!before || !before.ranges)
		      { pushSelectionToHistory(doc.sel, hist.done) }
		    cur = {changes: [historyChangeFromChange(doc, change)],
		           generation: hist.generation}
		    hist.done.push(cur)
		    while (hist.done.length > hist.undoDepth) {
		      hist.done.shift()
		      if (!hist.done[0].ranges) { hist.done.shift() }
		    }
		  }
		  hist.done.push(selAfter)
		  hist.generation = ++hist.maxGeneration
		  hist.lastModTime = hist.lastSelTime = time
		  hist.lastOp = hist.lastSelOp = opId
		  hist.lastOrigin = hist.lastSelOrigin = change.origin

		  if (!last) { signal(doc, "historyAdded") }
		}

		function selectionEventCanBeMerged(doc, origin, prev, sel) {
		  var ch = origin.charAt(0)
		  return ch == "*" ||
		    ch == "+" &&
		    prev.ranges.length == sel.ranges.length &&
		    prev.somethingSelected() == sel.somethingSelected() &&
		    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
		}

		// Called whenever the selection changes, sets the new selection as
		// the pending selection in the history, and pushes the old pending
		// selection into the 'done' array when it was significantly
		// different (in number of selected ranges, emptiness, or time).
		function addSelectionToHistory(doc, sel, opId, options) {
		  var hist = doc.history, origin = options && options.origin

		  // A new event is started when the previous origin does not match
		  // the current, or the origins don't allow matching. Origins
		  // starting with * are always merged, those starting with + are
		  // merged when similar and close together in time.
		  if (opId == hist.lastSelOp ||
		      (origin && hist.lastSelOrigin == origin &&
		       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
		        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
		    { hist.done[hist.done.length - 1] = sel }
		  else
		    { pushSelectionToHistory(sel, hist.done) }

		  hist.lastSelTime = +new Date
		  hist.lastSelOrigin = origin
		  hist.lastSelOp = opId
		  if (options && options.clearRedo !== false)
		    { clearSelectionEvents(hist.undone) }
		}

		function pushSelectionToHistory(sel, dest) {
		  var top = lst(dest)
		  if (!(top && top.ranges && top.equals(sel)))
		    { dest.push(sel) }
		}

		// Used to store marked span information in the history.
		function attachLocalSpans(doc, change, from, to) {
		  var existing = change["spans_" + doc.id], n = 0
		  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
		    if (line.markedSpans)
		      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans }
		    ++n
		  })
		}

		// When un/re-doing restores text containing marked spans, those
		// that have been explicitly cleared should not be restored.
		function removeClearedSpans(spans) {
		  if (!spans) { return null }
		  var out
		  for (var i = 0; i < spans.length; ++i) {
		    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i) } }
		    else if (out) { out.push(spans[i]) }
		  }
		  return !out ? spans : out.length ? out : null
		}

		// Retrieve and filter the old marked spans stored in a change event.
		function getOldSpans(doc, change) {
		  var found = change["spans_" + doc.id]
		  if (!found) { return null }
		  var nw = []
		  for (var i = 0; i < change.text.length; ++i)
		    { nw.push(removeClearedSpans(found[i])) }
		  return nw
		}

		// Used for un/re-doing changes from the history. Combines the
		// result of computing the existing spans with the set of spans that
		// existed in the history (so that deleting around a span and then
		// undoing brings back the span).
		function mergeOldSpans(doc, change) {
		  var old = getOldSpans(doc, change)
		  var stretched = stretchSpansOverChange(doc, change)
		  if (!old) { return stretched }
		  if (!stretched) { return old }

		  for (var i = 0; i < old.length; ++i) {
		    var oldCur = old[i], stretchCur = stretched[i]
		    if (oldCur && stretchCur) {
		      spans: for (var j = 0; j < stretchCur.length; ++j) {
		        var span = stretchCur[j]
		        for (var k = 0; k < oldCur.length; ++k)
		          { if (oldCur[k].marker == span.marker) { continue spans } }
		        oldCur.push(span)
		      }
		    } else if (stretchCur) {
		      old[i] = stretchCur
		    }
		  }
		  return old
		}

		// Used both to provide a JSON-safe object in .getHistory, and, when
		// detaching a document, to split the history in two
		function copyHistoryArray(events, newGroup, instantiateSel) {
		  var copy = []
		  for (var i = 0; i < events.length; ++i) {
		    var event = events[i]
		    if (event.ranges) {
		      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event)
		      continue
		    }
		    var changes = event.changes, newChanges = []
		    copy.push({changes: newChanges})
		    for (var j = 0; j < changes.length; ++j) {
		      var change = changes[j], m = (void 0)
		      newChanges.push({from: change.from, to: change.to, text: change.text})
		      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
		        if (indexOf(newGroup, Number(m[1])) > -1) {
		          lst(newChanges)[prop] = change[prop]
		          delete change[prop]
		        }
		      } } }
		    }
		  }
		  return copy
		}

		// The 'scroll' parameter given to many of these indicated whether
		// the new cursor position should be scrolled into view after
		// modifying the selection.

		// If shift is held or the extend flag is set, extends a range to
		// include a given position (and optionally a second position).
		// Otherwise, simply returns the range between the given positions.
		// Used for cursor motion and such.
		function extendRange(doc, range, head, other) {
		  if (doc.cm && doc.cm.display.shift || doc.extend) {
		    var anchor = range.anchor
		    if (other) {
		      var posBefore = cmp(head, anchor) < 0
		      if (posBefore != (cmp(other, anchor) < 0)) {
		        anchor = head
		        head = other
		      } else if (posBefore != (cmp(head, other) < 0)) {
		        head = other
		      }
		    }
		    return new Range(anchor, head)
		  } else {
		    return new Range(other || head, head)
		  }
		}

		// Extend the primary selection range, discard the rest.
		function extendSelection(doc, head, other, options) {
		  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options)
		}

		// Extend all selections (pos is an array of selections with length
		// equal the number of selections)
		function extendSelections(doc, heads, options) {
		  var out = []
		  for (var i = 0; i < doc.sel.ranges.length; i++)
		    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null) }
		  var newSel = normalizeSelection(out, doc.sel.primIndex)
		  setSelection(doc, newSel, options)
		}

		// Updates a single range in the selection.
		function replaceOneSelection(doc, i, range, options) {
		  var ranges = doc.sel.ranges.slice(0)
		  ranges[i] = range
		  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
		}

		// Reset the selection to a single range.
		function setSimpleSelection(doc, anchor, head, options) {
		  setSelection(doc, simpleSelection(anchor, head), options)
		}

		// Give beforeSelectionChange handlers a change to influence a
		// selection update.
		function filterSelectionChange(doc, sel, options) {
		  var obj = {
		    ranges: sel.ranges,
		    update: function(ranges) {
		      var this$1 = this;

		      this.ranges = []
		      for (var i = 0; i < ranges.length; i++)
		        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
		                                   clipPos(doc, ranges[i].head)) }
		    },
		    origin: options && options.origin
		  }
		  signal(doc, "beforeSelectionChange", doc, obj)
		  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj) }
		  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
		  else { return sel }
		}

		function setSelectionReplaceHistory(doc, sel, options) {
		  var done = doc.history.done, last = lst(done)
		  if (last && last.ranges) {
		    done[done.length - 1] = sel
		    setSelectionNoUndo(doc, sel, options)
		  } else {
		    setSelection(doc, sel, options)
		  }
		}

		// Set a new selection.
		function setSelection(doc, sel, options) {
		  setSelectionNoUndo(doc, sel, options)
		  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
		}

		function setSelectionNoUndo(doc, sel, options) {
		  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
		    { sel = filterSelectionChange(doc, sel, options) }

		  var bias = options && options.bias ||
		    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1)
		  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))

		  if (!(options && options.scroll === false) && doc.cm)
		    { ensureCursorVisible(doc.cm) }
		}

		function setSelectionInner(doc, sel) {
		  if (sel.equals(doc.sel)) { return }

		  doc.sel = sel

		  if (doc.cm) {
		    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true
		    signalCursorActivity(doc.cm)
		  }
		  signalLater(doc, "cursorActivity", doc)
		}

		// Verify that the selection does not partially select any atomic
		// marked ranges.
		function reCheckSelection(doc) {
		  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll)
		}

		// Return a selection that does not partially select any atomic
		// ranges.
		function skipAtomicInSelection(doc, sel, bias, mayClear) {
		  var out
		  for (var i = 0; i < sel.ranges.length; i++) {
		    var range = sel.ranges[i]
		    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i]
		    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear)
		    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear)
		    if (out || newAnchor != range.anchor || newHead != range.head) {
		      if (!out) { out = sel.ranges.slice(0, i) }
		      out[i] = new Range(newAnchor, newHead)
		    }
		  }
		  return out ? normalizeSelection(out, sel.primIndex) : sel
		}

		function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
		  var line = getLine(doc, pos.line)
		  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
		    var sp = line.markedSpans[i], m = sp.marker
		    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
		        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
		      if (mayClear) {
		        signal(m, "beforeCursorEnter")
		        if (m.explicitlyCleared) {
		          if (!line.markedSpans) { break }
		          else {--i; continue}
		        }
		      }
		      if (!m.atomic) { continue }

		      if (oldPos) {
		        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0)
		        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
		          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null) }
		        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
		          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
		      }

		      var far = m.find(dir < 0 ? -1 : 1)
		      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
		        { far = movePos(doc, far, dir, far.line == pos.line ? line : null) }
		      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
		    }
		  } }
		  return pos
		}

		// Ensure a given position is not inside an atomic range.
		function skipAtomic(doc, pos, oldPos, bias, mayClear) {
		  var dir = bias || 1
		  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
		      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
		      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
		      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true))
		  if (!found) {
		    doc.cantEdit = true
		    return Pos(doc.first, 0)
		  }
		  return found
		}

		function movePos(doc, pos, dir, line) {
		  if (dir < 0 && pos.ch == 0) {
		    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
		    else { return null }
		  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
		    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
		    else { return null }
		  } else {
		    return new Pos(pos.line, pos.ch + dir)
		  }
		}

		function selectAll(cm) {
		  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
		}

		// UPDATING

		// Allow "beforeChange" event handlers to influence a change
		function filterChange(doc, change, update) {
		  var obj = {
		    canceled: false,
		    from: change.from,
		    to: change.to,
		    text: change.text,
		    origin: change.origin,
		    cancel: function () { return obj.canceled = true; }
		  }
		  if (update) { obj.update = function (from, to, text, origin) {
		    if (from) { obj.from = clipPos(doc, from) }
		    if (to) { obj.to = clipPos(doc, to) }
		    if (text) { obj.text = text }
		    if (origin !== undefined) { obj.origin = origin }
		  } }
		  signal(doc, "beforeChange", doc, obj)
		  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj) }

		  if (obj.canceled) { return null }
		  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
		}

		// Apply a change to a document, and add it to the document's
		// history, and propagating it to all linked documents.
		function makeChange(doc, change, ignoreReadOnly) {
		  if (doc.cm) {
		    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
		    if (doc.cm.state.suppressEdits) { return }
		  }

		  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
		    change = filterChange(doc, change, true)
		    if (!change) { return }
		  }

		  // Possibly split or suppress the update based on the presence
		  // of read-only spans in its range.
		  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to)
		  if (split) {
		    for (var i = split.length - 1; i >= 0; --i)
		      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text}) }
		  } else {
		    makeChangeInner(doc, change)
		  }
		}

		function makeChangeInner(doc, change) {
		  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
		  var selAfter = computeSelAfterChange(doc, change)
		  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN)

		  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change))
		  var rebased = []

		  linkedDocs(doc, function (doc, sharedHist) {
		    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
		      rebaseHist(doc.history, change)
		      rebased.push(doc.history)
		    }
		    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
		  })
		}

		// Revert a change stored in a document's history.
		function makeChangeFromHistory(doc, type, allowSelectionOnly) {
		  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }

		  var hist = doc.history, event, selAfter = doc.sel
		  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done

		  // Verify that there is a useable event (so that ctrl-z won't
		  // needlessly clear selection events)
		  var i = 0
		  for (; i < source.length; i++) {
		    event = source[i]
		    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
		      { break }
		  }
		  if (i == source.length) { return }
		  hist.lastOrigin = hist.lastSelOrigin = null

		  for (;;) {
		    event = source.pop()
		    if (event.ranges) {
		      pushSelectionToHistory(event, dest)
		      if (allowSelectionOnly && !event.equals(doc.sel)) {
		        setSelection(doc, event, {clearRedo: false})
		        return
		      }
		      selAfter = event
		    }
		    else { break }
		  }

		  // Build up a reverse change object to add to the opposite history
		  // stack (redo when undoing, and vice versa).
		  var antiChanges = []
		  pushSelectionToHistory(selAfter, dest)
		  dest.push({changes: antiChanges, generation: hist.generation})
		  hist.generation = event.generation || ++hist.maxGeneration

		  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")

		  var loop = function ( i ) {
		    var change = event.changes[i]
		    change.origin = type
		    if (filter && !filterChange(doc, change, false)) {
		      source.length = 0
		      return {}
		    }

		    antiChanges.push(historyChangeFromChange(doc, change))

		    var after = i ? computeSelAfterChange(doc, change) : lst(source)
		    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))
		    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}) }
		    var rebased = []

		    // Propagate to the linked documents
		    linkedDocs(doc, function (doc, sharedHist) {
		      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
		        rebaseHist(doc.history, change)
		        rebased.push(doc.history)
		      }
		      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
		    })
		  };

		  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
		    var returned = loop( i$1 );

		    if ( returned ) return returned.v;
		  }
		}

		// Sub-views need their line numbers shifted when text is added
		// above or below them in the parent document.
		function shiftDoc(doc, distance) {
		  if (distance == 0) { return }
		  doc.first += distance
		  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
		    Pos(range.anchor.line + distance, range.anchor.ch),
		    Pos(range.head.line + distance, range.head.ch)
		  ); }), doc.sel.primIndex)
		  if (doc.cm) {
		    regChange(doc.cm, doc.first, doc.first - distance, distance)
		    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
		      { regLineChange(doc.cm, l, "gutter") }
		  }
		}

		// More lower-level change function, handling only a single document
		// (not linked ones).
		function makeChangeSingleDoc(doc, change, selAfter, spans) {
		  if (doc.cm && !doc.cm.curOp)
		    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

		  if (change.to.line < doc.first) {
		    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line))
		    return
		  }
		  if (change.from.line > doc.lastLine()) { return }

		  // Clip the change to the size of this doc
		  if (change.from.line < doc.first) {
		    var shift = change.text.length - 1 - (doc.first - change.from.line)
		    shiftDoc(doc, shift)
		    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
		              text: [lst(change.text)], origin: change.origin}
		  }
		  var last = doc.lastLine()
		  if (change.to.line > last) {
		    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
		              text: [change.text[0]], origin: change.origin}
		  }

		  change.removed = getBetween(doc, change.from, change.to)

		  if (!selAfter) { selAfter = computeSelAfterChange(doc, change) }
		  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans) }
		  else { updateDoc(doc, change, spans) }
		  setSelectionNoUndo(doc, selAfter, sel_dontScroll)
		}

		// Handle the interaction of a change to a document with the editor
		// that this document is part of.
		function makeChangeSingleDocInEditor(cm, change, spans) {
		  var doc = cm.doc, display = cm.display, from = change.from, to = change.to

		  var recomputeMaxLength = false, checkWidthStart = from.line
		  if (!cm.options.lineWrapping) {
		    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))
		    doc.iter(checkWidthStart, to.line + 1, function (line) {
		      if (line == display.maxLine) {
		        recomputeMaxLength = true
		        return true
		      }
		    })
		  }

		  if (doc.sel.contains(change.from, change.to) > -1)
		    { signalCursorActivity(cm) }

		  updateDoc(doc, change, spans, estimateHeight(cm))

		  if (!cm.options.lineWrapping) {
		    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
		      var len = lineLength(line)
		      if (len > display.maxLineLength) {
		        display.maxLine = line
		        display.maxLineLength = len
		        display.maxLineChanged = true
		        recomputeMaxLength = false
		      }
		    })
		    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true }
		  }

		  // Adjust frontier, schedule worker
		  doc.frontier = Math.min(doc.frontier, from.line)
		  startWorker(cm, 400)

		  var lendiff = change.text.length - (to.line - from.line) - 1
		  // Remember that these lines changed, for updating the display
		  if (change.full)
		    { regChange(cm) }
		  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
		    { regLineChange(cm, from.line, "text") }
		  else
		    { regChange(cm, from.line, to.line + 1, lendiff) }

		  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change")
		  if (changeHandler || changesHandler) {
		    var obj = {
		      from: from, to: to,
		      text: change.text,
		      removed: change.removed,
		      origin: change.origin
		    }
		    if (changeHandler) { signalLater(cm, "change", cm, obj) }
		    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj) }
		  }
		  cm.display.selForContextMenu = null
		}

		function replaceRange(doc, code, from, to, origin) {
		  if (!to) { to = from }
		  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp }
		  if (typeof code == "string") { code = doc.splitLines(code) }
		  makeChange(doc, {from: from, to: to, text: code, origin: origin})
		}

		// Rebasing/resetting history to deal with externally-sourced changes

		function rebaseHistSelSingle(pos, from, to, diff) {
		  if (to < pos.line) {
		    pos.line += diff
		  } else if (from < pos.line) {
		    pos.line = from
		    pos.ch = 0
		  }
		}

		// Tries to rebase an array of history events given a change in the
		// document. If the change touches the same lines as the event, the
		// event, and everything 'behind' it, is discarded. If the change is
		// before the event, the event's positions are updated. Uses a
		// copy-on-write scheme for the positions, to avoid having to
		// reallocate them all on every rebase, but also avoid problems with
		// shared position objects being unsafely updated.
		function rebaseHistArray(array, from, to, diff) {
		  for (var i = 0; i < array.length; ++i) {
		    var sub = array[i], ok = true
		    if (sub.ranges) {
		      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true }
		      for (var j = 0; j < sub.ranges.length; j++) {
		        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)
		        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
		      }
		      continue
		    }
		    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
		      var cur = sub.changes[j$1]
		      if (to < cur.from.line) {
		        cur.from = Pos(cur.from.line + diff, cur.from.ch)
		        cur.to = Pos(cur.to.line + diff, cur.to.ch)
		      } else if (from <= cur.to.line) {
		        ok = false
		        break
		      }
		    }
		    if (!ok) {
		      array.splice(0, i + 1)
		      i = 0
		    }
		  }
		}

		function rebaseHist(hist, change) {
		  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1
		  rebaseHistArray(hist.done, from, to, diff)
		  rebaseHistArray(hist.undone, from, to, diff)
		}

		// Utility for applying a change to a line by handle or number,
		// returning the number and optionally registering the line as
		// changed.
		function changeLine(doc, handle, changeType, op) {
		  var no = handle, line = handle
		  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)) }
		  else { no = lineNo(handle) }
		  if (no == null) { return null }
		  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType) }
		  return line
		}

		// The document is represented as a BTree consisting of leaves, with
		// chunk of lines in them, and branches, with up to ten leaves or
		// other branch nodes below them. The top node is always a branch
		// node, and is the document object itself (meaning it has
		// additional methods and properties).
		//
		// All nodes have parent links. The tree is used both to go from
		// line numbers to line objects, and to go from objects to numbers.
		// It also indexes by height, and is used to convert between height
		// and line object, and to find the total height of the document.
		//
		// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

		function LeafChunk(lines) {
		  var this$1 = this;

		  this.lines = lines
		  this.parent = null
		  var height = 0
		  for (var i = 0; i < lines.length; ++i) {
		    lines[i].parent = this$1
		    height += lines[i].height
		  }
		  this.height = height
		}

		LeafChunk.prototype = {
		  chunkSize: function() { return this.lines.length },
		  // Remove the n lines at offset 'at'.
		  removeInner: function(at, n) {
		    var this$1 = this;

		    for (var i = at, e = at + n; i < e; ++i) {
		      var line = this$1.lines[i]
		      this$1.height -= line.height
		      cleanUpLine(line)
		      signalLater(line, "delete")
		    }
		    this.lines.splice(at, n)
		  },
		  // Helper used to collapse a small branch into a single leaf.
		  collapse: function(lines) {
		    lines.push.apply(lines, this.lines)
		  },
		  // Insert the given array of lines at offset 'at', count them as
		  // having the given height.
		  insertInner: function(at, lines, height) {
		    var this$1 = this;

		    this.height += height
		    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at))
		    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1 }
		  },
		  // Used to iterate over a part of the tree.
		  iterN: function(at, n, op) {
		    var this$1 = this;

		    for (var e = at + n; at < e; ++at)
		      { if (op(this$1.lines[at])) { return true } }
		  }
		}

		function BranchChunk(children) {
		  var this$1 = this;

		  this.children = children
		  var size = 0, height = 0
		  for (var i = 0; i < children.length; ++i) {
		    var ch = children[i]
		    size += ch.chunkSize(); height += ch.height
		    ch.parent = this$1
		  }
		  this.size = size
		  this.height = height
		  this.parent = null
		}

		BranchChunk.prototype = {
		  chunkSize: function() { return this.size },
		  removeInner: function(at, n) {
		    var this$1 = this;

		    this.size -= n
		    for (var i = 0; i < this.children.length; ++i) {
		      var child = this$1.children[i], sz = child.chunkSize()
		      if (at < sz) {
		        var rm = Math.min(n, sz - at), oldHeight = child.height
		        child.removeInner(at, rm)
		        this$1.height -= oldHeight - child.height
		        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null }
		        if ((n -= rm) == 0) { break }
		        at = 0
		      } else { at -= sz }
		    }
		    // If the result is smaller than 25 lines, ensure that it is a
		    // single leaf node.
		    if (this.size - n < 25 &&
		        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
		      var lines = []
		      this.collapse(lines)
		      this.children = [new LeafChunk(lines)]
		      this.children[0].parent = this
		    }
		  },
		  collapse: function(lines) {
		    var this$1 = this;

		    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines) }
		  },
		  insertInner: function(at, lines, height) {
		    var this$1 = this;

		    this.size += lines.length
		    this.height += height
		    for (var i = 0; i < this.children.length; ++i) {
		      var child = this$1.children[i], sz = child.chunkSize()
		      if (at <= sz) {
		        child.insertInner(at, lines, height)
		        if (child.lines && child.lines.length > 50) {
		          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
		          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
		          var remaining = child.lines.length % 25 + 25
		          for (var pos = remaining; pos < child.lines.length;) {
		            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25))
		            child.height -= leaf.height
		            this$1.children.splice(++i, 0, leaf)
		            leaf.parent = this$1
		          }
		          child.lines = child.lines.slice(0, remaining)
		          this$1.maybeSpill()
		        }
		        break
		      }
		      at -= sz
		    }
		  },
		  // When a node has grown, check whether it should be split.
		  maybeSpill: function() {
		    if (this.children.length <= 10) { return }
		    var me = this
		    do {
		      var spilled = me.children.splice(me.children.length - 5, 5)
		      var sibling = new BranchChunk(spilled)
		      if (!me.parent) { // Become the parent node
		        var copy = new BranchChunk(me.children)
		        copy.parent = me
		        me.children = [copy, sibling]
		        me = copy
		     } else {
		        me.size -= sibling.size
		        me.height -= sibling.height
		        var myIndex = indexOf(me.parent.children, me)
		        me.parent.children.splice(myIndex + 1, 0, sibling)
		      }
		      sibling.parent = me.parent
		    } while (me.children.length > 10)
		    me.parent.maybeSpill()
		  },
		  iterN: function(at, n, op) {
		    var this$1 = this;

		    for (var i = 0; i < this.children.length; ++i) {
		      var child = this$1.children[i], sz = child.chunkSize()
		      if (at < sz) {
		        var used = Math.min(n, sz - at)
		        if (child.iterN(at, used, op)) { return true }
		        if ((n -= used) == 0) { break }
		        at = 0
		      } else { at -= sz }
		    }
		  }
		}

		// Line widgets are block elements displayed above or below a line.

		function LineWidget(doc, node, options) {
		  var this$1 = this;

		  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
		    { this$1[opt] = options[opt] } } }
		  this.doc = doc
		  this.node = node
		}
		eventMixin(LineWidget)

		function adjustScrollWhenAboveVisible(cm, line, diff) {
		  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
		    { addToScrollPos(cm, null, diff) }
		}

		LineWidget.prototype.clear = function() {
		  var this$1 = this;

		  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line)
		  if (no == null || !ws) { return }
		  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1) } }
		  if (!ws.length) { line.widgets = null }
		  var height = widgetHeight(this)
		  updateLineHeight(line, Math.max(0, line.height - height))
		  if (cm) { runInOp(cm, function () {
		    adjustScrollWhenAboveVisible(cm, line, -height)
		    regLineChange(cm, no, "widget")
		  }) }
		}
		LineWidget.prototype.changed = function() {
		  var oldH = this.height, cm = this.doc.cm, line = this.line
		  this.height = null
		  var diff = widgetHeight(this) - oldH
		  if (!diff) { return }
		  updateLineHeight(line, line.height + diff)
		  if (cm) { runInOp(cm, function () {
		    cm.curOp.forceUpdate = true
		    adjustScrollWhenAboveVisible(cm, line, diff)
		  }) }
		}

		function addLineWidget(doc, handle, node, options) {
		  var widget = new LineWidget(doc, node, options)
		  var cm = doc.cm
		  if (cm && widget.noHScroll) { cm.display.alignWidgets = true }
		  changeLine(doc, handle, "widget", function (line) {
		    var widgets = line.widgets || (line.widgets = [])
		    if (widget.insertAt == null) { widgets.push(widget) }
		    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget) }
		    widget.line = line
		    if (cm && !lineIsHidden(doc, line)) {
		      var aboveVisible = heightAtLine(line) < doc.scrollTop
		      updateLineHeight(line, line.height + widgetHeight(widget))
		      if (aboveVisible) { addToScrollPos(cm, null, widget.height) }
		      cm.curOp.forceUpdate = true
		    }
		    return true
		  })
		  return widget
		}

		// TEXTMARKERS

		// Created with markText and setBookmark methods. A TextMarker is a
		// handle that can be used to clear or find a marked position in the
		// document. Line objects hold arrays (markedSpans) containing
		// {from, to, marker} object pointing to such marker objects, and
		// indicating that such a marker is present on that line. Multiple
		// lines may point to the same marker when it spans across lines.
		// The spans will have null for their from/to properties when the
		// marker continues beyond the start/end of the line. Markers have
		// links back to the lines they currently touch.

		// Collapsed markers have unique ids, in order to be able to order
		// them, which is needed for uniquely determining an outer marker
		// when they overlap (they may nest, but not partially overlap).
		var nextMarkerId = 0

		function TextMarker(doc, type) {
		  this.lines = []
		  this.type = type
		  this.doc = doc
		  this.id = ++nextMarkerId
		}
		eventMixin(TextMarker)

		// Clear the marker.
		TextMarker.prototype.clear = function() {
		  var this$1 = this;

		  if (this.explicitlyCleared) { return }
		  var cm = this.doc.cm, withOp = cm && !cm.curOp
		  if (withOp) { startOperation(cm) }
		  if (hasHandler(this, "clear")) {
		    var found = this.find()
		    if (found) { signalLater(this, "clear", found.from, found.to) }
		  }
		  var min = null, max = null
		  for (var i = 0; i < this.lines.length; ++i) {
		    var line = this$1.lines[i]
		    var span = getMarkedSpanFor(line.markedSpans, this$1)
		    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text") }
		    else if (cm) {
		      if (span.to != null) { max = lineNo(line) }
		      if (span.from != null) { min = lineNo(line) }
		    }
		    line.markedSpans = removeMarkedSpan(line.markedSpans, span)
		    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
		      { updateLineHeight(line, textHeight(cm.display)) }
		  }
		  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
		    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual)
		    if (len > cm.display.maxLineLength) {
		      cm.display.maxLine = visual
		      cm.display.maxLineLength = len
		      cm.display.maxLineChanged = true
		    }
		  } }

		  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1) }
		  this.lines.length = 0
		  this.explicitlyCleared = true
		  if (this.atomic && this.doc.cantEdit) {
		    this.doc.cantEdit = false
		    if (cm) { reCheckSelection(cm.doc) }
		  }
		  if (cm) { signalLater(cm, "markerCleared", cm, this) }
		  if (withOp) { endOperation(cm) }
		  if (this.parent) { this.parent.clear() }
		}

		// Find the position of the marker in the document. Returns a {from,
		// to} object by default. Side can be passed to get a specific side
		// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
		// Pos objects returned contain a line object, rather than a line
		// number (used to prevent looking up the same line twice).
		TextMarker.prototype.find = function(side, lineObj) {
		  var this$1 = this;

		  if (side == null && this.type == "bookmark") { side = 1 }
		  var from, to
		  for (var i = 0; i < this.lines.length; ++i) {
		    var line = this$1.lines[i]
		    var span = getMarkedSpanFor(line.markedSpans, this$1)
		    if (span.from != null) {
		      from = Pos(lineObj ? line : lineNo(line), span.from)
		      if (side == -1) { return from }
		    }
		    if (span.to != null) {
		      to = Pos(lineObj ? line : lineNo(line), span.to)
		      if (side == 1) { return to }
		    }
		  }
		  return from && {from: from, to: to}
		}

		// Signals that the marker's widget changed, and surrounding layout
		// should be recomputed.
		TextMarker.prototype.changed = function() {
		  var pos = this.find(-1, true), widget = this, cm = this.doc.cm
		  if (!pos || !cm) { return }
		  runInOp(cm, function () {
		    var line = pos.line, lineN = lineNo(pos.line)
		    var view = findViewForLine(cm, lineN)
		    if (view) {
		      clearLineMeasurementCacheFor(view)
		      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true
		    }
		    cm.curOp.updateMaxLine = true
		    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
		      var oldHeight = widget.height
		      widget.height = null
		      var dHeight = widgetHeight(widget) - oldHeight
		      if (dHeight)
		        { updateLineHeight(line, line.height + dHeight) }
		    }
		  })
		}

		TextMarker.prototype.attachLine = function(line) {
		  if (!this.lines.length && this.doc.cm) {
		    var op = this.doc.cm.curOp
		    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
		      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this) }
		  }
		  this.lines.push(line)
		}
		TextMarker.prototype.detachLine = function(line) {
		  this.lines.splice(indexOf(this.lines, line), 1)
		  if (!this.lines.length && this.doc.cm) {
		    var op = this.doc.cm.curOp
		    ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
		  }
		}

		// Create a marker, wire it up to the right lines, and
		function markText(doc, from, to, options, type) {
		  // Shared markers (across linked documents) are handled separately
		  // (markTextShared will call out to this again, once per
		  // document).
		  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
		  // Ensure we are in an operation.
		  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

		  var marker = new TextMarker(doc, type), diff = cmp(from, to)
		  if (options) { copyObj(options, marker, false) }
		  // Don't connect empty markers unless clearWhenEmpty is false
		  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
		    { return marker }
		  if (marker.replacedWith) {
		    // Showing up as a widget implies collapsed (widget replaces text)
		    marker.collapsed = true
		    marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget")
		    marker.widgetNode.setAttribute("role", "presentation") // hide from accessibility tree
		    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true") }
		    if (options.insertLeft) { marker.widgetNode.insertLeft = true }
		  }
		  if (marker.collapsed) {
		    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
		        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
		      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
		    seeCollapsedSpans()
		  }

		  if (marker.addToHistory)
		    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN) }

		  var curLine = from.line, cm = doc.cm, updateMaxLine
		  doc.iter(curLine, to.line + 1, function (line) {
		    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
		      { updateMaxLine = true }
		    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0) }
		    addMarkedSpan(line, new MarkedSpan(marker,
		                                       curLine == from.line ? from.ch : null,
		                                       curLine == to.line ? to.ch : null))
		    ++curLine
		  })
		  // lineIsHidden depends on the presence of the spans, so needs a second pass
		  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
		    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0) }
		  }) }

		  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }) }

		  if (marker.readOnly) {
		    seeReadOnlySpans()
		    if (doc.history.done.length || doc.history.undone.length)
		      { doc.clearHistory() }
		  }
		  if (marker.collapsed) {
		    marker.id = ++nextMarkerId
		    marker.atomic = true
		  }
		  if (cm) {
		    // Sync editor state
		    if (updateMaxLine) { cm.curOp.updateMaxLine = true }
		    if (marker.collapsed)
		      { regChange(cm, from.line, to.line + 1) }
		    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
		      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text") } }
		    if (marker.atomic) { reCheckSelection(cm.doc) }
		    signalLater(cm, "markerAdded", cm, marker)
		  }
		  return marker
		}

		// SHARED TEXTMARKERS

		// A shared marker spans multiple linked documents. It is
		// implemented as a meta-marker-object controlling multiple normal
		// markers.
		function SharedTextMarker(markers, primary) {
		  var this$1 = this;

		  this.markers = markers
		  this.primary = primary
		  for (var i = 0; i < markers.length; ++i)
		    { markers[i].parent = this$1 }
		}
		eventMixin(SharedTextMarker)

		SharedTextMarker.prototype.clear = function() {
		  var this$1 = this;

		  if (this.explicitlyCleared) { return }
		  this.explicitlyCleared = true
		  for (var i = 0; i < this.markers.length; ++i)
		    { this$1.markers[i].clear() }
		  signalLater(this, "clear")
		}
		SharedTextMarker.prototype.find = function(side, lineObj) {
		  return this.primary.find(side, lineObj)
		}

		function markTextShared(doc, from, to, options, type) {
		  options = copyObj(options)
		  options.shared = false
		  var markers = [markText(doc, from, to, options, type)], primary = markers[0]
		  var widget = options.widgetNode
		  linkedDocs(doc, function (doc) {
		    if (widget) { options.widgetNode = widget.cloneNode(true) }
		    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type))
		    for (var i = 0; i < doc.linked.length; ++i)
		      { if (doc.linked[i].isParent) { return } }
		    primary = lst(markers)
		  })
		  return new SharedTextMarker(markers, primary)
		}

		function findSharedMarkers(doc) {
		  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
		}

		function copySharedMarkers(doc, markers) {
		  for (var i = 0; i < markers.length; i++) {
		    var marker = markers[i], pos = marker.find()
		    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to)
		    if (cmp(mFrom, mTo)) {
		      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type)
		      marker.markers.push(subMark)
		      subMark.parent = marker
		    }
		  }
		}

		function detachSharedMarkers(markers) {
		  var loop = function ( i ) {
		    var marker = markers[i], linked = [marker.primary.doc]
		    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); })
		    for (var j = 0; j < marker.markers.length; j++) {
		      var subMarker = marker.markers[j]
		      if (indexOf(linked, subMarker.doc) == -1) {
		        subMarker.parent = null
		        marker.markers.splice(j--, 1)
		      }
		    }
		  };

		  for (var i = 0; i < markers.length; i++) loop( i );
		}

		var nextDocId = 0
		var Doc = function(text, mode, firstLine, lineSep) {
		  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep) }
		  if (firstLine == null) { firstLine = 0 }

		  BranchChunk.call(this, [new LeafChunk([new Line("", null)])])
		  this.first = firstLine
		  this.scrollTop = this.scrollLeft = 0
		  this.cantEdit = false
		  this.cleanGeneration = 1
		  this.frontier = firstLine
		  var start = Pos(firstLine, 0)
		  this.sel = simpleSelection(start)
		  this.history = new History(null)
		  this.id = ++nextDocId
		  this.modeOption = mode
		  this.lineSep = lineSep
		  this.extend = false

		  if (typeof text == "string") { text = this.splitLines(text) }
		  updateDoc(this, {from: start, to: start, text: text})
		  setSelection(this, simpleSelection(start), sel_dontScroll)
		}

		Doc.prototype = createObj(BranchChunk.prototype, {
		  constructor: Doc,
		  // Iterate over the document. Supports two forms -- with only one
		  // argument, it calls that for each line in the document. With
		  // three, it iterates over the range given by the first two (with
		  // the second being non-inclusive).
		  iter: function(from, to, op) {
		    if (op) { this.iterN(from - this.first, to - from, op) }
		    else { this.iterN(this.first, this.first + this.size, from) }
		  },

		  // Non-public interface for adding and removing lines.
		  insert: function(at, lines) {
		    var height = 0
		    for (var i = 0; i < lines.length; ++i) { height += lines[i].height }
		    this.insertInner(at - this.first, lines, height)
		  },
		  remove: function(at, n) { this.removeInner(at - this.first, n) },

		  // From here, the methods are part of the public interface. Most
		  // are also available from CodeMirror (editor) instances.

		  getValue: function(lineSep) {
		    var lines = getLines(this, this.first, this.first + this.size)
		    if (lineSep === false) { return lines }
		    return lines.join(lineSep || this.lineSeparator())
		  },
		  setValue: docMethodOp(function(code) {
		    var top = Pos(this.first, 0), last = this.first + this.size - 1
		    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
		                      text: this.splitLines(code), origin: "setValue", full: true}, true)
		    setSelection(this, simpleSelection(top))
		  }),
		  replaceRange: function(code, from, to, origin) {
		    from = clipPos(this, from)
		    to = to ? clipPos(this, to) : from
		    replaceRange(this, code, from, to, origin)
		  },
		  getRange: function(from, to, lineSep) {
		    var lines = getBetween(this, clipPos(this, from), clipPos(this, to))
		    if (lineSep === false) { return lines }
		    return lines.join(lineSep || this.lineSeparator())
		  },

		  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

		  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
		  getLineNumber: function(line) {return lineNo(line)},

		  getLineHandleVisualStart: function(line) {
		    if (typeof line == "number") { line = getLine(this, line) }
		    return visualLine(line)
		  },

		  lineCount: function() {return this.size},
		  firstLine: function() {return this.first},
		  lastLine: function() {return this.first + this.size - 1},

		  clipPos: function(pos) {return clipPos(this, pos)},

		  getCursor: function(start) {
		    var range = this.sel.primary(), pos
		    if (start == null || start == "head") { pos = range.head }
		    else if (start == "anchor") { pos = range.anchor }
		    else if (start == "end" || start == "to" || start === false) { pos = range.to() }
		    else { pos = range.from() }
		    return pos
		  },
		  listSelections: function() { return this.sel.ranges },
		  somethingSelected: function() {return this.sel.somethingSelected()},

		  setCursor: docMethodOp(function(line, ch, options) {
		    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options)
		  }),
		  setSelection: docMethodOp(function(anchor, head, options) {
		    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)
		  }),
		  extendSelection: docMethodOp(function(head, other, options) {
		    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)
		  }),
		  extendSelections: docMethodOp(function(heads, options) {
		    extendSelections(this, clipPosArray(this, heads), options)
		  }),
		  extendSelectionsBy: docMethodOp(function(f, options) {
		    var heads = map(this.sel.ranges, f)
		    extendSelections(this, clipPosArray(this, heads), options)
		  }),
		  setSelections: docMethodOp(function(ranges, primary, options) {
		    var this$1 = this;

		    if (!ranges.length) { return }
		    var out = []
		    for (var i = 0; i < ranges.length; i++)
		      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
		                         clipPos(this$1, ranges[i].head)) }
		    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex) }
		    setSelection(this, normalizeSelection(out, primary), options)
		  }),
		  addSelection: docMethodOp(function(anchor, head, options) {
		    var ranges = this.sel.ranges.slice(0)
		    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)))
		    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)
		  }),

		  getSelection: function(lineSep) {
		    var this$1 = this;

		    var ranges = this.sel.ranges, lines
		    for (var i = 0; i < ranges.length; i++) {
		      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())
		      lines = lines ? lines.concat(sel) : sel
		    }
		    if (lineSep === false) { return lines }
		    else { return lines.join(lineSep || this.lineSeparator()) }
		  },
		  getSelections: function(lineSep) {
		    var this$1 = this;

		    var parts = [], ranges = this.sel.ranges
		    for (var i = 0; i < ranges.length; i++) {
		      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())
		      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()) }
		      parts[i] = sel
		    }
		    return parts
		  },
		  replaceSelection: function(code, collapse, origin) {
		    var dup = []
		    for (var i = 0; i < this.sel.ranges.length; i++)
		      { dup[i] = code }
		    this.replaceSelections(dup, collapse, origin || "+input")
		  },
		  replaceSelections: docMethodOp(function(code, collapse, origin) {
		    var this$1 = this;

		    var changes = [], sel = this.sel
		    for (var i = 0; i < sel.ranges.length; i++) {
		      var range = sel.ranges[i]
		      changes[i] = {from: range.from(), to: range.to(), text: this$1.splitLines(code[i]), origin: origin}
		    }
		    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse)
		    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
		      { makeChange(this$1, changes[i$1]) }
		    if (newSel) { setSelectionReplaceHistory(this, newSel) }
		    else if (this.cm) { ensureCursorVisible(this.cm) }
		  }),
		  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo")}),
		  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo")}),
		  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true)}),
		  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true)}),

		  setExtending: function(val) {this.extend = val},
		  getExtending: function() {return this.extend},

		  historySize: function() {
		    var hist = this.history, done = 0, undone = 0
		    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done } }
		    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone } }
		    return {undo: done, redo: undone}
		  },
		  clearHistory: function() {this.history = new History(this.history.maxGeneration)},

		  markClean: function() {
		    this.cleanGeneration = this.changeGeneration(true)
		  },
		  changeGeneration: function(forceSplit) {
		    if (forceSplit)
		      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null }
		    return this.history.generation
		  },
		  isClean: function (gen) {
		    return this.history.generation == (gen || this.cleanGeneration)
		  },

		  getHistory: function() {
		    return {done: copyHistoryArray(this.history.done),
		            undone: copyHistoryArray(this.history.undone)}
		  },
		  setHistory: function(histData) {
		    var hist = this.history = new History(this.history.maxGeneration)
		    hist.done = copyHistoryArray(histData.done.slice(0), null, true)
		    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)
		  },

		  setGutterMarker: docMethodOp(function(line, gutterID, value) {
		    return changeLine(this, line, "gutter", function (line) {
		      var markers = line.gutterMarkers || (line.gutterMarkers = {})
		      markers[gutterID] = value
		      if (!value && isEmpty(markers)) { line.gutterMarkers = null }
		      return true
		    })
		  }),

		  clearGutter: docMethodOp(function(gutterID) {
		    var this$1 = this;

		    this.iter(function (line) {
		      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
		        changeLine(this$1, line, "gutter", function () {
		          line.gutterMarkers[gutterID] = null
		          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null }
		          return true
		        })
		      }
		    })
		  }),

		  lineInfo: function(line) {
		    var n
		    if (typeof line == "number") {
		      if (!isLine(this, line)) { return null }
		      n = line
		      line = getLine(this, line)
		      if (!line) { return null }
		    } else {
		      n = lineNo(line)
		      if (n == null) { return null }
		    }
		    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
		            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
		            widgets: line.widgets}
		  },

		  addLineClass: docMethodOp(function(handle, where, cls) {
		    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
		      var prop = where == "text" ? "textClass"
		               : where == "background" ? "bgClass"
		               : where == "gutter" ? "gutterClass" : "wrapClass"
		      if (!line[prop]) { line[prop] = cls }
		      else if (classTest(cls).test(line[prop])) { return false }
		      else { line[prop] += " " + cls }
		      return true
		    })
		  }),
		  removeLineClass: docMethodOp(function(handle, where, cls) {
		    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
		      var prop = where == "text" ? "textClass"
		               : where == "background" ? "bgClass"
		               : where == "gutter" ? "gutterClass" : "wrapClass"
		      var cur = line[prop]
		      if (!cur) { return false }
		      else if (cls == null) { line[prop] = null }
		      else {
		        var found = cur.match(classTest(cls))
		        if (!found) { return false }
		        var end = found.index + found[0].length
		        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null
		      }
		      return true
		    })
		  }),

		  addLineWidget: docMethodOp(function(handle, node, options) {
		    return addLineWidget(this, handle, node, options)
		  }),
		  removeLineWidget: function(widget) { widget.clear() },

		  markText: function(from, to, options) {
		    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
		  },
		  setBookmark: function(pos, options) {
		    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
		                    insertLeft: options && options.insertLeft,
		                    clearWhenEmpty: false, shared: options && options.shared,
		                    handleMouseEvents: options && options.handleMouseEvents}
		    pos = clipPos(this, pos)
		    return markText(this, pos, pos, realOpts, "bookmark")
		  },
		  findMarksAt: function(pos) {
		    pos = clipPos(this, pos)
		    var markers = [], spans = getLine(this, pos.line).markedSpans
		    if (spans) { for (var i = 0; i < spans.length; ++i) {
		      var span = spans[i]
		      if ((span.from == null || span.from <= pos.ch) &&
		          (span.to == null || span.to >= pos.ch))
		        { markers.push(span.marker.parent || span.marker) }
		    } }
		    return markers
		  },
		  findMarks: function(from, to, filter) {
		    from = clipPos(this, from); to = clipPos(this, to)
		    var found = [], lineNo = from.line
		    this.iter(from.line, to.line + 1, function (line) {
		      var spans = line.markedSpans
		      if (spans) { for (var i = 0; i < spans.length; i++) {
		        var span = spans[i]
		        if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
		              span.from == null && lineNo != from.line ||
		              span.from != null && lineNo == to.line && span.from >= to.ch) &&
		            (!filter || filter(span.marker)))
		          { found.push(span.marker.parent || span.marker) }
		      } }
		      ++lineNo
		    })
		    return found
		  },
		  getAllMarks: function() {
		    var markers = []
		    this.iter(function (line) {
		      var sps = line.markedSpans
		      if (sps) { for (var i = 0; i < sps.length; ++i)
		        { if (sps[i].from != null) { markers.push(sps[i].marker) } } }
		    })
		    return markers
		  },

		  posFromIndex: function(off) {
		    var ch, lineNo = this.first, sepSize = this.lineSeparator().length
		    this.iter(function (line) {
		      var sz = line.text.length + sepSize
		      if (sz > off) { ch = off; return true }
		      off -= sz
		      ++lineNo
		    })
		    return clipPos(this, Pos(lineNo, ch))
		  },
		  indexFromPos: function (coords) {
		    coords = clipPos(this, coords)
		    var index = coords.ch
		    if (coords.line < this.first || coords.ch < 0) { return 0 }
		    var sepSize = this.lineSeparator().length
		    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
		      index += line.text.length + sepSize
		    })
		    return index
		  },

		  copy: function(copyHistory) {
		    var doc = new Doc(getLines(this, this.first, this.first + this.size),
		                      this.modeOption, this.first, this.lineSep)
		    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft
		    doc.sel = this.sel
		    doc.extend = false
		    if (copyHistory) {
		      doc.history.undoDepth = this.history.undoDepth
		      doc.setHistory(this.getHistory())
		    }
		    return doc
		  },

		  linkedDoc: function(options) {
		    if (!options) { options = {} }
		    var from = this.first, to = this.first + this.size
		    if (options.from != null && options.from > from) { from = options.from }
		    if (options.to != null && options.to < to) { to = options.to }
		    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep)
		    if (options.sharedHist) { copy.history = this.history
		    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist})
		    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}]
		    copySharedMarkers(copy, findSharedMarkers(this))
		    return copy
		  },
		  unlinkDoc: function(other) {
		    var this$1 = this;

		    if (other instanceof CodeMirror) { other = other.doc }
		    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
		      var link = this$1.linked[i]
		      if (link.doc != other) { continue }
		      this$1.linked.splice(i, 1)
		      other.unlinkDoc(this$1)
		      detachSharedMarkers(findSharedMarkers(this$1))
		      break
		    } }
		    // If the histories were shared, split them again
		    if (other.history == this.history) {
		      var splitIds = [other.id]
		      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true)
		      other.history = new History(null)
		      other.history.done = copyHistoryArray(this.history.done, splitIds)
		      other.history.undone = copyHistoryArray(this.history.undone, splitIds)
		    }
		  },
		  iterLinkedDocs: function(f) {linkedDocs(this, f)},

		  getMode: function() {return this.mode},
		  getEditor: function() {return this.cm},

		  splitLines: function(str) {
		    if (this.lineSep) { return str.split(this.lineSep) }
		    return splitLinesAuto(str)
		  },
		  lineSeparator: function() { return this.lineSep || "\n" }
		})

		// Public alias.
		Doc.prototype.eachLine = Doc.prototype.iter

		// Kludge to work around strange IE behavior where it'll sometimes
		// re-fire a series of drag-related events right after the drop (#1551)
		var lastDrop = 0

		function onDrop(e) {
		  var cm = this
		  clearDragCursor(cm)
		  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
		    { return }
		  e_preventDefault(e)
		  if (ie) { lastDrop = +new Date }
		  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files
		  if (!pos || cm.isReadOnly()) { return }
		  // Might be a file drop, in which case we simply extract the text
		  // and insert it.
		  if (files && files.length && window.FileReader && window.File) {
		    var n = files.length, text = Array(n), read = 0
		    var loadFile = function (file, i) {
		      if (cm.options.allowDropFileTypes &&
		          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
		        { return }

		      var reader = new FileReader
		      reader.onload = operation(cm, function () {
		        var content = reader.result
		        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = "" }
		        text[i] = content
		        if (++read == n) {
		          pos = clipPos(cm.doc, pos)
		          var change = {from: pos, to: pos,
		                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
		                        origin: "paste"}
		          makeChange(cm.doc, change)
		          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))
		        }
		      })
		      reader.readAsText(file)
		    }
		    for (var i = 0; i < n; ++i) { loadFile(files[i], i) }
		  } else { // Normal drop
		    // Don't do a replace if the drop happened inside of the selected text.
		    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
		      cm.state.draggingText(e)
		      // Ensure the editor is re-focused
		      setTimeout(function () { return cm.display.input.focus(); }, 20)
		      return
		    }
		    try {
		      var text$1 = e.dataTransfer.getData("Text")
		      if (text$1) {
		        var selected
		        if (cm.state.draggingText && !cm.state.draggingText.copy)
		          { selected = cm.listSelections() }
		        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))
		        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
		          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag") } }
		        cm.replaceSelection(text$1, "around", "paste")
		        cm.display.input.focus()
		      }
		    }
		    catch(e){}
		  }
		}

		function onDragStart(cm, e) {
		  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
		  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

		  e.dataTransfer.setData("Text", cm.getSelection())
		  e.dataTransfer.effectAllowed = "copyMove"

		  // Use dummy image instead of default browsers image.
		  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
		  if (e.dataTransfer.setDragImage && !safari) {
		    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;")
		    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
		    if (presto) {
		      img.width = img.height = 1
		      cm.display.wrapper.appendChild(img)
		      // Force a relayout, or Opera won't use our image for some obscure reason
		      img._top = img.offsetTop
		    }
		    e.dataTransfer.setDragImage(img, 0, 0)
		    if (presto) { img.parentNode.removeChild(img) }
		  }
		}

		function onDragOver(cm, e) {
		  var pos = posFromMouse(cm, e)
		  if (!pos) { return }
		  var frag = document.createDocumentFragment()
		  drawSelectionCursor(cm, pos, frag)
		  if (!cm.display.dragCursor) {
		    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors")
		    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)
		  }
		  removeChildrenAndAdd(cm.display.dragCursor, frag)
		}

		function clearDragCursor(cm) {
		  if (cm.display.dragCursor) {
		    cm.display.lineSpace.removeChild(cm.display.dragCursor)
		    cm.display.dragCursor = null
		  }
		}

		// These must be handled carefully, because naively registering a
		// handler for each editor will cause the editors to never be
		// garbage collected.

		function forEachCodeMirror(f) {
		  if (!document.body.getElementsByClassName) { return }
		  var byClass = document.body.getElementsByClassName("CodeMirror")
		  for (var i = 0; i < byClass.length; i++) {
		    var cm = byClass[i].CodeMirror
		    if (cm) { f(cm) }
		  }
		}

		var globalsRegistered = false
		function ensureGlobalHandlers() {
		  if (globalsRegistered) { return }
		  registerGlobalHandlers()
		  globalsRegistered = true
		}
		function registerGlobalHandlers() {
		  // When the window resizes, we need to refresh active editors.
		  var resizeTimer
		  on(window, "resize", function () {
		    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
		      resizeTimer = null
		      forEachCodeMirror(onResize)
		    }, 100) }
		  })
		  // When the window loses focus, we want to show the editor as blurred
		  on(window, "blur", function () { return forEachCodeMirror(onBlur); })
		}
		// Called when the window resizes
		function onResize(cm) {
		  var d = cm.display
		  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
		    { return }
		  // Might be a text scaling operation, clear size caches.
		  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null
		  d.scrollbarsClipped = false
		  cm.setSize()
		}

		var keyNames = {
		  3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
		  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
		  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
		  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
		  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
		  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
		  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
		  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
		}

		// Number keys
		for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i) }
		// Alphabetic keys
		for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1) }
		// Function keys
		for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2 }

		var keyMap = {}

		keyMap.basic = {
		  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
		  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
		  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
		  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
		  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
		  "Esc": "singleSelection"
		}
		// Note that the save and find-related commands aren't defined by
		// default. User code or addons can define them. Unknown commands
		// are simply ignored.
		keyMap.pcDefault = {
		  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
		  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
		  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
		  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
		  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
		  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
		  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
		  fallthrough: "basic"
		}
		// Very basic readline/emacs-style bindings, which are standard on Mac.
		keyMap.emacsy = {
		  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
		  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
		  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
		  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
		  "Ctrl-O": "openLine"
		}
		keyMap.macDefault = {
		  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
		  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
		  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
		  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
		  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
		  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
		  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
		  fallthrough: ["basic", "emacsy"]
		}
		keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault

		// KEYMAP DISPATCH

		function normalizeKeyName(name) {
		  var parts = name.split(/-(?!$)/)
		  name = parts[parts.length - 1]
		  var alt, ctrl, shift, cmd
		  for (var i = 0; i < parts.length - 1; i++) {
		    var mod = parts[i]
		    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true }
		    else if (/^a(lt)?$/i.test(mod)) { alt = true }
		    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }
		    else if (/^s(hift)?$/i.test(mod)) { shift = true }
		    else { throw new Error("Unrecognized modifier name: " + mod) }
		  }
		  if (alt) { name = "Alt-" + name }
		  if (ctrl) { name = "Ctrl-" + name }
		  if (cmd) { name = "Cmd-" + name }
		  if (shift) { name = "Shift-" + name }
		  return name
		}

		// This is a kludge to keep keymaps mostly working as raw objects
		// (backwards compatibility) while at the same time support features
		// like normalization and multi-stroke key bindings. It compiles a
		// new normalized keymap, and then updates the old object to reflect
		// this.
		function normalizeKeyMap(keymap) {
		  var copy = {}
		  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
		    var value = keymap[keyname]
		    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
		    if (value == "...") { delete keymap[keyname]; continue }

		    var keys = map(keyname.split(" "), normalizeKeyName)
		    for (var i = 0; i < keys.length; i++) {
		      var val = (void 0), name = (void 0)
		      if (i == keys.length - 1) {
		        name = keys.join(" ")
		        val = value
		      } else {
		        name = keys.slice(0, i + 1).join(" ")
		        val = "..."
		      }
		      var prev = copy[name]
		      if (!prev) { copy[name] = val }
		      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
		    }
		    delete keymap[keyname]
		  } }
		  for (var prop in copy) { keymap[prop] = copy[prop] }
		  return keymap
		}

		function lookupKey(key, map, handle, context) {
		  map = getKeyMap(map)
		  var found = map.call ? map.call(key, context) : map[key]
		  if (found === false) { return "nothing" }
		  if (found === "...") { return "multi" }
		  if (found != null && handle(found)) { return "handled" }

		  if (map.fallthrough) {
		    if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
		      { return lookupKey(key, map.fallthrough, handle, context) }
		    for (var i = 0; i < map.fallthrough.length; i++) {
		      var result = lookupKey(key, map.fallthrough[i], handle, context)
		      if (result) { return result }
		    }
		  }
		}

		// Modifier key presses don't count as 'real' key presses for the
		// purpose of keymap fallthrough.
		function isModifierKey(value) {
		  var name = typeof value == "string" ? value : keyNames[value.keyCode]
		  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
		}

		// Look up the name of a key as indicated by an event object.
		function keyName(event, noShift) {
		  if (presto && event.keyCode == 34 && event["char"]) { return false }
		  var base = keyNames[event.keyCode], name = base
		  if (name == null || event.altGraphKey) { return false }
		  if (event.altKey && base != "Alt") { name = "Alt-" + name }
		  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name }
		  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name }
		  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name }
		  return name
		}

		function getKeyMap(val) {
		  return typeof val == "string" ? keyMap[val] : val
		}

		// Helper for deleting text near the selection(s), used to implement
		// backspace, delete, and similar functionality.
		function deleteNearSelection(cm, compute) {
		  var ranges = cm.doc.sel.ranges, kill = []
		  // Build up a set of ranges to kill first, merging overlapping
		  // ranges.
		  for (var i = 0; i < ranges.length; i++) {
		    var toKill = compute(ranges[i])
		    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
		      var replaced = kill.pop()
		      if (cmp(replaced.from, toKill.from) < 0) {
		        toKill.from = replaced.from
		        break
		      }
		    }
		    kill.push(toKill)
		  }
		  // Next, remove those actual ranges.
		  runInOp(cm, function () {
		    for (var i = kill.length - 1; i >= 0; i--)
		      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete") }
		    ensureCursorVisible(cm)
		  })
		}

		// Commands are parameter-less actions that can be performed on an
		// editor, mostly used for keybindings.
		var commands = {
		  selectAll: selectAll,
		  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
		  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
		    if (range.empty()) {
		      var len = getLine(cm.doc, range.head.line).text.length
		      if (range.head.ch == len && range.head.line < cm.lastLine())
		        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
		      else
		        { return {from: range.head, to: Pos(range.head.line, len)} }
		    } else {
		      return {from: range.from(), to: range.to()}
		    }
		  }); },
		  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
		    from: Pos(range.from().line, 0),
		    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
		  }); }); },
		  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
		    from: Pos(range.from().line, 0), to: range.from()
		  }); }); },
		  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5
		    var leftPos = cm.coordsChar({left: 0, top: top}, "div")
		    return {from: leftPos, to: range.from()}
		  }); },
		  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5
		    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
		    return {from: range.from(), to: rightPos }
		  }); },
		  undo: function (cm) { return cm.undo(); },
		  redo: function (cm) { return cm.redo(); },
		  undoSelection: function (cm) { return cm.undoSelection(); },
		  redoSelection: function (cm) { return cm.redoSelection(); },
		  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
		  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
		  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
		    {origin: "+move", bias: 1}
		  ); },
		  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
		    {origin: "+move", bias: 1}
		  ); },
		  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
		    {origin: "+move", bias: -1}
		  ); },
		  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5
		    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
		  }, sel_move); },
		  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5
		    return cm.coordsChar({left: 0, top: top}, "div")
		  }, sel_move); },
		  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5
		    var pos = cm.coordsChar({left: 0, top: top}, "div")
		    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
		    return pos
		  }, sel_move); },
		  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
		  goLineDown: function (cm) { return cm.moveV(1, "line"); },
		  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
		  goPageDown: function (cm) { return cm.moveV(1, "page"); },
		  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
		  goCharRight: function (cm) { return cm.moveH(1, "char"); },
		  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
		  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
		  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
		  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
		  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
		  goWordRight: function (cm) { return cm.moveH(1, "word"); },
		  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
		  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
		  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
		  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
		  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
		  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
		  indentAuto: function (cm) { return cm.indentSelection("smart"); },
		  indentMore: function (cm) { return cm.indentSelection("add"); },
		  indentLess: function (cm) { return cm.indentSelection("subtract"); },
		  insertTab: function (cm) { return cm.replaceSelection("\t"); },
		  insertSoftTab: function (cm) {
		    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize
		    for (var i = 0; i < ranges.length; i++) {
		      var pos = ranges[i].from()
		      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)
		      spaces.push(spaceStr(tabSize - col % tabSize))
		    }
		    cm.replaceSelections(spaces)
		  },
		  defaultTab: function (cm) {
		    if (cm.somethingSelected()) { cm.indentSelection("add") }
		    else { cm.execCommand("insertTab") }
		  },
		  // Swap the two chars left and right of each selection's head.
		  // Move cursor behind the two swapped characters afterwards.
		  //
		  // Doesn't consider line feeds a character.
		  // Doesn't scan more than one line above to find a character.
		  // Doesn't do anything on an empty line.
		  // Doesn't do anything with non-empty selections.
		  transposeChars: function (cm) { return runInOp(cm, function () {
		    var ranges = cm.listSelections(), newSel = []
		    for (var i = 0; i < ranges.length; i++) {
		      if (!ranges[i].empty()) { continue }
		      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text
		      if (line) {
		        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1) }
		        if (cur.ch > 0) {
		          cur = new Pos(cur.line, cur.ch + 1)
		          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
		                          Pos(cur.line, cur.ch - 2), cur, "+transpose")
		        } else if (cur.line > cm.doc.first) {
		          var prev = getLine(cm.doc, cur.line - 1).text
		          if (prev) {
		            cur = new Pos(cur.line, 1)
		            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
		                            prev.charAt(prev.length - 1),
		                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose")
		          }
		        }
		      }
		      newSel.push(new Range(cur, cur))
		    }
		    cm.setSelections(newSel)
		  }); },
		  newlineAndIndent: function (cm) { return runInOp(cm, function () {
		    var sels = cm.listSelections()
		    for (var i = sels.length - 1; i >= 0; i--)
		      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input") }
		    sels = cm.listSelections()
		    for (var i$1 = 0; i$1 < sels.length; i$1++)
		      { cm.indentLine(sels[i$1].from().line, null, true) }
		    ensureCursorVisible(cm)
		  }); },
		  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
		  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
		}


		function lineStart(cm, lineN) {
		  var line = getLine(cm.doc, lineN)
		  var visual = visualLine(line)
		  if (visual != line) { lineN = lineNo(visual) }
		  var order = getOrder(visual)
		  var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual)
		  return Pos(lineN, ch)
		}
		function lineEnd(cm, lineN) {
		  var merged, line = getLine(cm.doc, lineN)
		  while (merged = collapsedSpanAtEnd(line)) {
		    line = merged.find(1, true).line
		    lineN = null
		  }
		  var order = getOrder(line)
		  var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line)
		  return Pos(lineN == null ? lineNo(line) : lineN, ch)
		}
		function lineStartSmart(cm, pos) {
		  var start = lineStart(cm, pos.line)
		  var line = getLine(cm.doc, start.line)
		  var order = getOrder(line)
		  if (!order || order[0].level == 0) {
		    var firstNonWS = Math.max(0, line.text.search(/\S/))
		    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch
		    return Pos(start.line, inWS ? 0 : firstNonWS)
		  }
		  return start
		}

		// Run a handler that was bound to a key.
		function doHandleBinding(cm, bound, dropShift) {
		  if (typeof bound == "string") {
		    bound = commands[bound]
		    if (!bound) { return false }
		  }
		  // Ensure previous input has been read, so that the handler sees a
		  // consistent view of the document
		  cm.display.input.ensurePolled()
		  var prevShift = cm.display.shift, done = false
		  try {
		    if (cm.isReadOnly()) { cm.state.suppressEdits = true }
		    if (dropShift) { cm.display.shift = false }
		    done = bound(cm) != Pass
		  } finally {
		    cm.display.shift = prevShift
		    cm.state.suppressEdits = false
		  }
		  return done
		}

		function lookupKeyForEditor(cm, name, handle) {
		  for (var i = 0; i < cm.state.keyMaps.length; i++) {
		    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)
		    if (result) { return result }
		  }
		  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
		    || lookupKey(name, cm.options.keyMap, handle, cm)
		}

		var stopSeq = new Delayed
		function dispatchKey(cm, name, e, handle) {
		  var seq = cm.state.keySeq
		  if (seq) {
		    if (isModifierKey(name)) { return "handled" }
		    stopSeq.set(50, function () {
		      if (cm.state.keySeq == seq) {
		        cm.state.keySeq = null
		        cm.display.input.reset()
		      }
		    })
		    name = seq + " " + name
		  }
		  var result = lookupKeyForEditor(cm, name, handle)

		  if (result == "multi")
		    { cm.state.keySeq = name }
		  if (result == "handled")
		    { signalLater(cm, "keyHandled", cm, name, e) }

		  if (result == "handled" || result == "multi") {
		    e_preventDefault(e)
		    restartBlink(cm)
		  }

		  if (seq && !result && /\'$/.test(name)) {
		    e_preventDefault(e)
		    return true
		  }
		  return !!result
		}

		// Handle a key from the keydown event.
		function handleKeyBinding(cm, e) {
		  var name = keyName(e, true)
		  if (!name) { return false }

		  if (e.shiftKey && !cm.state.keySeq) {
		    // First try to resolve full name (including 'Shift-'). Failing
		    // that, see if there is a cursor-motion command (starting with
		    // 'go') bound to the keyname without 'Shift-'.
		    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
		        || dispatchKey(cm, name, e, function (b) {
		             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
		               { return doHandleBinding(cm, b) }
		           })
		  } else {
		    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
		  }
		}

		// Handle a key from the keypress event
		function handleCharBinding(cm, e, ch) {
		  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
		}

		var lastStoppedKey = null
		function onKeyDown(e) {
		  var cm = this
		  cm.curOp.focus = activeElt()
		  if (signalDOMEvent(cm, e)) { return }
		  // IE does strange things with escape.
		  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false }
		  var code = e.keyCode
		  cm.display.shift = code == 16 || e.shiftKey
		  var handled = handleKeyBinding(cm, e)
		  if (presto) {
		    lastStoppedKey = handled ? code : null
		    // Opera has no cut event... we try to at least catch the key combo
		    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
		      { cm.replaceSelection("", null, "cut") }
		  }

		  // Turn mouse into crosshair when Alt is held on Mac.
		  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
		    { showCrossHair(cm) }
		}

		function showCrossHair(cm) {
		  var lineDiv = cm.display.lineDiv
		  addClass(lineDiv, "CodeMirror-crosshair")

		  function up(e) {
		    if (e.keyCode == 18 || !e.altKey) {
		      rmClass(lineDiv, "CodeMirror-crosshair")
		      off(document, "keyup", up)
		      off(document, "mouseover", up)
		    }
		  }
		  on(document, "keyup", up)
		  on(document, "mouseover", up)
		}

		function onKeyUp(e) {
		  if (e.keyCode == 16) { this.doc.sel.shift = false }
		  signalDOMEvent(this, e)
		}

		function onKeyPress(e) {
		  var cm = this
		  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
		  var keyCode = e.keyCode, charCode = e.charCode
		  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
		  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
		  var ch = String.fromCharCode(charCode == null ? keyCode : charCode)
		  // Some browsers fire keypress events for backspace
		  if (ch == "\x08") { return }
		  if (handleCharBinding(cm, e, ch)) { return }
		  cm.display.input.onKeyPress(e)
		}

		// A mouse down can be a single click, double click, triple click,
		// start of selection drag, start of text drag, new cursor
		// (ctrl-click), rectangle drag (alt-drag), or xwin
		// middle-click-paste. Or it might be a click on something we should
		// not interfere with, such as a scrollbar or widget.
		function onMouseDown(e) {
		  var cm = this, display = cm.display
		  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
		  display.input.ensurePolled()
		  display.shift = e.shiftKey

		  if (eventInWidget(display, e)) {
		    if (!webkit) {
		      // Briefly turn off draggability, to allow widgets to do
		      // normal dragging things.
		      display.scroller.draggable = false
		      setTimeout(function () { return display.scroller.draggable = true; }, 100)
		    }
		    return
		  }
		  if (clickInGutter(cm, e)) { return }
		  var start = posFromMouse(cm, e)
		  window.focus()

		  switch (e_button(e)) {
		  case 1:
		    // #3261: make sure, that we're not starting a second selection
		    if (cm.state.selectingText)
		      { cm.state.selectingText(e) }
		    else if (start)
		      { leftButtonDown(cm, e, start) }
		    else if (e_target(e) == display.scroller)
		      { e_preventDefault(e) }
		    break
		  case 2:
		    if (webkit) { cm.state.lastMiddleDown = +new Date }
		    if (start) { extendSelection(cm.doc, start) }
		    setTimeout(function () { return display.input.focus(); }, 20)
		    e_preventDefault(e)
		    break
		  case 3:
		    if (captureRightClick) { onContextMenu(cm, e) }
		    else { delayBlurEvent(cm) }
		    break
		  }
		}

		var lastClick;
		var lastDoubleClick;
		function leftButtonDown(cm, e, start) {
		  if (ie) { setTimeout(bind(ensureFocus, cm), 0) }
		  else { cm.curOp.focus = activeElt() }

		  var now = +new Date, type
		  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
		    type = "triple"
		  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
		    type = "double"
		    lastDoubleClick = {time: now, pos: start}
		  } else {
		    type = "single"
		    lastClick = {time: now, pos: start}
		  }

		  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained
		  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
		      type == "single" && (contained = sel.contains(start)) > -1 &&
		      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
		      (cmp(contained.to(), start) > 0 || start.xRel < 0))
		    { leftButtonStartDrag(cm, e, start, modifier) }
		  else
		    { leftButtonSelect(cm, e, start, type, modifier) }
		}

		// Start a text drag. When it ends, see if any dragging actually
		// happen, and treat as a click if it didn't.
		function leftButtonStartDrag(cm, e, start, modifier) {
		  var display = cm.display, startTime = +new Date
		  var dragEnd = operation(cm, function (e2) {
		    if (webkit) { display.scroller.draggable = false }
		    cm.state.draggingText = false
		    off(document, "mouseup", dragEnd)
		    off(display.scroller, "drop", dragEnd)
		    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
		      e_preventDefault(e2)
		      if (!modifier && +new Date - 200 < startTime)
		        { extendSelection(cm.doc, start) }
		      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
		      if (webkit || ie && ie_version == 9)
		        { setTimeout(function () {document.body.focus(); display.input.focus()}, 20) }
		      else
		        { display.input.focus() }
		    }
		  })
		  // Let the drag handler handle this.
		  if (webkit) { display.scroller.draggable = true }
		  cm.state.draggingText = dragEnd
		  dragEnd.copy = mac ? e.altKey : e.ctrlKey
		  // IE's approach to draggable
		  if (display.scroller.dragDrop) { display.scroller.dragDrop() }
		  on(document, "mouseup", dragEnd)
		  on(display.scroller, "drop", dragEnd)
		}

		// Normal selection, as opposed to text dragging.
		function leftButtonSelect(cm, e, start, type, addNew) {
		  var display = cm.display, doc = cm.doc
		  e_preventDefault(e)

		  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges
		  if (addNew && !e.shiftKey) {
		    ourIndex = doc.sel.contains(start)
		    if (ourIndex > -1)
		      { ourRange = ranges[ourIndex] }
		    else
		      { ourRange = new Range(start, start) }
		  } else {
		    ourRange = doc.sel.primary()
		    ourIndex = doc.sel.primIndex
		  }

		  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
		    type = "rect"
		    if (!addNew) { ourRange = new Range(start, start) }
		    start = posFromMouse(cm, e, true, true)
		    ourIndex = -1
		  } else if (type == "double") {
		    var word = cm.findWordAt(start)
		    if (cm.display.shift || doc.extend)
		      { ourRange = extendRange(doc, ourRange, word.anchor, word.head) }
		    else
		      { ourRange = word }
		  } else if (type == "triple") {
		    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)))
		    if (cm.display.shift || doc.extend)
		      { ourRange = extendRange(doc, ourRange, line.anchor, line.head) }
		    else
		      { ourRange = line }
		  } else {
		    ourRange = extendRange(doc, ourRange, start)
		  }

		  if (!addNew) {
		    ourIndex = 0
		    setSelection(doc, new Selection([ourRange], 0), sel_mouse)
		    startSel = doc.sel
		  } else if (ourIndex == -1) {
		    ourIndex = ranges.length
		    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
		                 {scroll: false, origin: "*mouse"})
		  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
		    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
		                 {scroll: false, origin: "*mouse"})
		    startSel = doc.sel
		  } else {
		    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)
		  }

		  var lastPos = start
		  function extendTo(pos) {
		    if (cmp(lastPos, pos) == 0) { return }
		    lastPos = pos

		    if (type == "rect") {
		      var ranges = [], tabSize = cm.options.tabSize
		      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize)
		      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize)
		      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol)
		      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
		           line <= end; line++) {
		        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize)
		        if (left == right)
		          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) }
		        else if (text.length > leftPos)
		          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))) }
		      }
		      if (!ranges.length) { ranges.push(new Range(start, start)) }
		      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
		                   {origin: "*mouse", scroll: false})
		      cm.scrollIntoView(pos)
		    } else {
		      var oldRange = ourRange
		      var anchor = oldRange.anchor, head = pos
		      if (type != "single") {
		        var range
		        if (type == "double")
		          { range = cm.findWordAt(pos) }
		        else
		          { range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))) }
		        if (cmp(range.anchor, anchor) > 0) {
		          head = range.head
		          anchor = minPos(oldRange.from(), range.anchor)
		        } else {
		          head = range.anchor
		          anchor = maxPos(oldRange.to(), range.head)
		        }
		      }
		      var ranges$1 = startSel.ranges.slice(0)
		      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head)
		      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)
		    }
		  }

		  var editorSize = display.wrapper.getBoundingClientRect()
		  // Used to ensure timeout re-tries don't fire when another extend
		  // happened in the meantime (clearTimeout isn't reliable -- at
		  // least on Chrome, the timeouts still happen even when cleared,
		  // if the clear happens after their scheduled firing time).
		  var counter = 0

		  function extend(e) {
		    var curCount = ++counter
		    var cur = posFromMouse(cm, e, true, type == "rect")
		    if (!cur) { return }
		    if (cmp(cur, lastPos) != 0) {
		      cm.curOp.focus = activeElt()
		      extendTo(cur)
		      var visible = visibleLines(display, doc)
		      if (cur.line >= visible.to || cur.line < visible.from)
		        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e) }}), 150) }
		    } else {
		      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0
		      if (outside) { setTimeout(operation(cm, function () {
		        if (counter != curCount) { return }
		        display.scroller.scrollTop += outside
		        extend(e)
		      }), 50) }
		    }
		  }

		  function done(e) {
		    cm.state.selectingText = false
		    counter = Infinity
		    e_preventDefault(e)
		    display.input.focus()
		    off(document, "mousemove", move)
		    off(document, "mouseup", up)
		    doc.history.lastSelOrigin = null
		  }

		  var move = operation(cm, function (e) {
		    if (!e_button(e)) { done(e) }
		    else { extend(e) }
		  })
		  var up = operation(cm, done)
		  cm.state.selectingText = up
		  on(document, "mousemove", move)
		  on(document, "mouseup", up)
		}


		// Determines whether an event happened in the gutter, and fires the
		// handlers for the corresponding event.
		function gutterEvent(cm, e, type, prevent) {
		  var mX, mY
		  try { mX = e.clientX; mY = e.clientY }
		  catch(e) { return false }
		  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
		  if (prevent) { e_preventDefault(e) }

		  var display = cm.display
		  var lineBox = display.lineDiv.getBoundingClientRect()

		  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
		  mY -= lineBox.top - display.viewOffset

		  for (var i = 0; i < cm.options.gutters.length; ++i) {
		    var g = display.gutters.childNodes[i]
		    if (g && g.getBoundingClientRect().right >= mX) {
		      var line = lineAtHeight(cm.doc, mY)
		      var gutter = cm.options.gutters[i]
		      signal(cm, type, cm, line, gutter, e)
		      return e_defaultPrevented(e)
		    }
		  }
		}

		function clickInGutter(cm, e) {
		  return gutterEvent(cm, e, "gutterClick", true)
		}

		// CONTEXT MENU HANDLING

		// To make the context menu work, we need to briefly unhide the
		// textarea (making it as unobtrusive as possible) to let the
		// right-click take effect on it.
		function onContextMenu(cm, e) {
		  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
		  if (signalDOMEvent(cm, e, "contextmenu")) { return }
		  cm.display.input.onContextMenu(e)
		}

		function contextMenuInGutter(cm, e) {
		  if (!hasHandler(cm, "gutterContextMenu")) { return false }
		  return gutterEvent(cm, e, "gutterContextMenu", false)
		}

		function themeChanged(cm) {
		  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
		    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-")
		  clearCaches(cm)
		}

		var Init = {toString: function(){return "CodeMirror.Init"}}

		var defaults = {}
		var optionHandlers = {}

		function defineOptions(CodeMirror) {
		  var optionHandlers = CodeMirror.optionHandlers

		  function option(name, deflt, handle, notOnInit) {
		    CodeMirror.defaults[name] = deflt
		    if (handle) { optionHandlers[name] =
		      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old) }} : handle }
		  }

		  CodeMirror.defineOption = option

		  // Passed to option handlers when there is no old value.
		  CodeMirror.Init = Init

		  // These two are, on init, called from the constructor because they
		  // have to be initialized before the editor can start at all.
		  option("value", "", function (cm, val) { return cm.setValue(val); }, true)
		  option("mode", null, function (cm, val) {
		    cm.doc.modeOption = val
		    loadMode(cm)
		  }, true)

		  option("indentUnit", 2, loadMode, true)
		  option("indentWithTabs", false)
		  option("smartIndent", true)
		  option("tabSize", 4, function (cm) {
		    resetModeState(cm)
		    clearCaches(cm)
		    regChange(cm)
		  }, true)
		  option("lineSeparator", null, function (cm, val) {
		    cm.doc.lineSep = val
		    if (!val) { return }
		    var newBreaks = [], lineNo = cm.doc.first
		    cm.doc.iter(function (line) {
		      for (var pos = 0;;) {
		        var found = line.text.indexOf(val, pos)
		        if (found == -1) { break }
		        pos = found + val.length
		        newBreaks.push(Pos(lineNo, found))
		      }
		      lineNo++
		    })
		    for (var i = newBreaks.length - 1; i >= 0; i--)
		      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)) }
		  })
		  option("specialChars", /[\u0000-\u001f\u007f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
		    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g")
		    if (old != Init) { cm.refresh() }
		  })
		  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true)
		  option("electricChars", true)
		  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
		    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
		  }, true)
		  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true)
		  option("rtlMoveVisually", !windows)
		  option("wholeLineUpdateBefore", true)

		  option("theme", "default", function (cm) {
		    themeChanged(cm)
		    guttersChanged(cm)
		  }, true)
		  option("keyMap", "default", function (cm, val, old) {
		    var next = getKeyMap(val)
		    var prev = old != Init && getKeyMap(old)
		    if (prev && prev.detach) { prev.detach(cm, next) }
		    if (next.attach) { next.attach(cm, prev || null) }
		  })
		  option("extraKeys", null)

		  option("lineWrapping", false, wrappingChanged, true)
		  option("gutters", [], function (cm) {
		    setGuttersForLineNumbers(cm.options)
		    guttersChanged(cm)
		  }, true)
		  option("fixedGutter", true, function (cm, val) {
		    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0"
		    cm.refresh()
		  }, true)
		  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true)
		  option("scrollbarStyle", "native", function (cm) {
		    initScrollbars(cm)
		    updateScrollbars(cm)
		    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)
		    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)
		  }, true)
		  option("lineNumbers", false, function (cm) {
		    setGuttersForLineNumbers(cm.options)
		    guttersChanged(cm)
		  }, true)
		  option("firstLineNumber", 1, guttersChanged, true)
		  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true)
		  option("showCursorWhenSelecting", false, updateSelection, true)

		  option("resetSelectionOnContextMenu", true)
		  option("lineWiseCopyCut", true)

		  option("readOnly", false, function (cm, val) {
		    if (val == "nocursor") {
		      onBlur(cm)
		      cm.display.input.blur()
		      cm.display.disabled = true
		    } else {
		      cm.display.disabled = false
		    }
		    cm.display.input.readOnlyChanged(val)
		  })
		  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset() }}, true)
		  option("dragDrop", true, dragDropChanged)
		  option("allowDropFileTypes", null)

		  option("cursorBlinkRate", 530)
		  option("cursorScrollMargin", 0)
		  option("cursorHeight", 1, updateSelection, true)
		  option("singleCursorHeightPerLine", true, updateSelection, true)
		  option("workTime", 100)
		  option("workDelay", 100)
		  option("flattenSpans", true, resetModeState, true)
		  option("addModeClass", false, resetModeState, true)
		  option("pollInterval", 100)
		  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; })
		  option("historyEventDelay", 1250)
		  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true)
		  option("maxHighlightLength", 10000, resetModeState, true)
		  option("moveInputWithCursor", true, function (cm, val) {
		    if (!val) { cm.display.input.resetPosition() }
		  })

		  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; })
		  option("autofocus", null)
		}

		function guttersChanged(cm) {
		  updateGutters(cm)
		  regChange(cm)
		  alignHorizontally(cm)
		}

		function dragDropChanged(cm, value, old) {
		  var wasOn = old && old != Init
		  if (!value != !wasOn) {
		    var funcs = cm.display.dragFunctions
		    var toggle = value ? on : off
		    toggle(cm.display.scroller, "dragstart", funcs.start)
		    toggle(cm.display.scroller, "dragenter", funcs.enter)
		    toggle(cm.display.scroller, "dragover", funcs.over)
		    toggle(cm.display.scroller, "dragleave", funcs.leave)
		    toggle(cm.display.scroller, "drop", funcs.drop)
		  }
		}

		function wrappingChanged(cm) {
		  if (cm.options.lineWrapping) {
		    addClass(cm.display.wrapper, "CodeMirror-wrap")
		    cm.display.sizer.style.minWidth = ""
		    cm.display.sizerWidth = null
		  } else {
		    rmClass(cm.display.wrapper, "CodeMirror-wrap")
		    findMaxLine(cm)
		  }
		  estimateLineHeights(cm)
		  regChange(cm)
		  clearCaches(cm)
		  setTimeout(function () { return updateScrollbars(cm); }, 100)
		}

		// A CodeMirror instance represents an editor. This is the object
		// that user code is usually dealing with.

		function CodeMirror(place, options) {
		  var this$1 = this;

		  if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

		  this.options = options = options ? copyObj(options) : {}
		  // Determine effective options based on given values and defaults.
		  copyObj(defaults, options, false)
		  setGuttersForLineNumbers(options)

		  var doc = options.value
		  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator) }
		  this.doc = doc

		  var input = new CodeMirror.inputStyles[options.inputStyle](this)
		  var display = this.display = new Display(place, doc, input)
		  display.wrapper.CodeMirror = this
		  updateGutters(this)
		  themeChanged(this)
		  if (options.lineWrapping)
		    { this.display.wrapper.className += " CodeMirror-wrap" }
		  initScrollbars(this)

		  this.state = {
		    keyMaps: [],  // stores maps added by addKeyMap
		    overlays: [], // highlighting overlays, as added by addOverlay
		    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
		    overwrite: false,
		    delayingBlurEvent: false,
		    focused: false,
		    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
		    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
		    selectingText: false,
		    draggingText: false,
		    highlight: new Delayed(), // stores highlight worker timeout
		    keySeq: null,  // Unfinished key sequence
		    specialChars: null
		  }

		  if (options.autofocus && !mobile) { display.input.focus() }

		  // Override magic textarea content restore that IE sometimes does
		  // on our hidden textarea on reload
		  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20) }

		  registerEventHandlers(this)
		  ensureGlobalHandlers()

		  startOperation(this)
		  this.curOp.forceUpdate = true
		  attachDoc(this, doc)

		  if ((options.autofocus && !mobile) || this.hasFocus())
		    { setTimeout(bind(onFocus, this), 20) }
		  else
		    { onBlur(this) }

		  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
		    { optionHandlers[opt](this$1, options[opt], Init) } }
		  maybeUpdateLineNumberWidth(this)
		  if (options.finishInit) { options.finishInit(this) }
		  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1) }
		  endOperation(this)
		  // Suppress optimizelegibility in Webkit, since it breaks text
		  // measuring on line wrapping boundaries.
		  if (webkit && options.lineWrapping &&
		      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
		    { display.lineDiv.style.textRendering = "auto" }
		}

		// The default configuration options.
		CodeMirror.defaults = defaults
		// Functions to run when options are changed.
		CodeMirror.optionHandlers = optionHandlers

		// Attach the necessary event handlers when initializing the editor
		function registerEventHandlers(cm) {
		  var d = cm.display
		  on(d.scroller, "mousedown", operation(cm, onMouseDown))
		  // Older IE's will not fire a second mousedown for a double click
		  if (ie && ie_version < 11)
		    { on(d.scroller, "dblclick", operation(cm, function (e) {
		      if (signalDOMEvent(cm, e)) { return }
		      var pos = posFromMouse(cm, e)
		      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
		      e_preventDefault(e)
		      var word = cm.findWordAt(pos)
		      extendSelection(cm.doc, word.anchor, word.head)
		    })) }
		  else
		    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }) }
		  // Some browsers fire contextmenu *after* opening the menu, at
		  // which point we can't mess with it anymore. Context menu is
		  // handled in onMouseDown for these browsers.
		  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }) }

		  // Used to suppress mouse event handling when a touch happens
		  var touchFinished, prevTouch = {end: 0}
		  function finishTouch() {
		    if (d.activeTouch) {
		      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000)
		      prevTouch = d.activeTouch
		      prevTouch.end = +new Date
		    }
		  }
		  function isMouseLikeTouchEvent(e) {
		    if (e.touches.length != 1) { return false }
		    var touch = e.touches[0]
		    return touch.radiusX <= 1 && touch.radiusY <= 1
		  }
		  function farAway(touch, other) {
		    if (other.left == null) { return true }
		    var dx = other.left - touch.left, dy = other.top - touch.top
		    return dx * dx + dy * dy > 20 * 20
		  }
		  on(d.scroller, "touchstart", function (e) {
		    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
		      d.input.ensurePolled()
		      clearTimeout(touchFinished)
		      var now = +new Date
		      d.activeTouch = {start: now, moved: false,
		                       prev: now - prevTouch.end <= 300 ? prevTouch : null}
		      if (e.touches.length == 1) {
		        d.activeTouch.left = e.touches[0].pageX
		        d.activeTouch.top = e.touches[0].pageY
		      }
		    }
		  })
		  on(d.scroller, "touchmove", function () {
		    if (d.activeTouch) { d.activeTouch.moved = true }
		  })
		  on(d.scroller, "touchend", function (e) {
		    var touch = d.activeTouch
		    if (touch && !eventInWidget(d, e) && touch.left != null &&
		        !touch.moved && new Date - touch.start < 300) {
		      var pos = cm.coordsChar(d.activeTouch, "page"), range
		      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
		        { range = new Range(pos, pos) }
		      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
		        { range = cm.findWordAt(pos) }
		      else // Triple tap
		        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
		      cm.setSelection(range.anchor, range.head)
		      cm.focus()
		      e_preventDefault(e)
		    }
		    finishTouch()
		  })
		  on(d.scroller, "touchcancel", finishTouch)

		  // Sync scrolling between fake scrollbars and real scrollable
		  // area, ensure viewport is updated when scrolling.
		  on(d.scroller, "scroll", function () {
		    if (d.scroller.clientHeight) {
		      setScrollTop(cm, d.scroller.scrollTop)
		      setScrollLeft(cm, d.scroller.scrollLeft, true)
		      signal(cm, "scroll", cm)
		    }
		  })

		  // Listen to wheel events in order to try and update the viewport on time.
		  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); })
		  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); })

		  // Prevent wrapper from ever scrolling
		  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; })

		  d.dragFunctions = {
		    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e) }},
		    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e) }},
		    start: function (e) { return onDragStart(cm, e); },
		    drop: operation(cm, onDrop),
		    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm) }}
		  }

		  var inp = d.input.getField()
		  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); })
		  on(inp, "keydown", operation(cm, onKeyDown))
		  on(inp, "keypress", operation(cm, onKeyPress))
		  on(inp, "focus", function (e) { return onFocus(cm, e); })
		  on(inp, "blur", function (e) { return onBlur(cm, e); })
		}

		var initHooks = []
		CodeMirror.defineInitHook = function (f) { return initHooks.push(f); }

		// Indent the given line. The how parameter can be "smart",
		// "add"/null, "subtract", or "prev". When aggressive is false
		// (typically set to true for forced single-line indents), empty
		// lines are not indented, and places where the mode returns Pass
		// are left alone.
		function indentLine(cm, n, how, aggressive) {
		  var doc = cm.doc, state
		  if (how == null) { how = "add" }
		  if (how == "smart") {
		    // Fall back to "prev" when the mode doesn't have an indentation
		    // method.
		    if (!doc.mode.indent) { how = "prev" }
		    else { state = getStateBefore(cm, n) }
		  }

		  var tabSize = cm.options.tabSize
		  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize)
		  if (line.stateAfter) { line.stateAfter = null }
		  var curSpaceString = line.text.match(/^\s*/)[0], indentation
		  if (!aggressive && !/\S/.test(line.text)) {
		    indentation = 0
		    how = "not"
		  } else if (how == "smart") {
		    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)
		    if (indentation == Pass || indentation > 150) {
		      if (!aggressive) { return }
		      how = "prev"
		    }
		  }
		  if (how == "prev") {
		    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize) }
		    else { indentation = 0 }
		  } else if (how == "add") {
		    indentation = curSpace + cm.options.indentUnit
		  } else if (how == "subtract") {
		    indentation = curSpace - cm.options.indentUnit
		  } else if (typeof how == "number") {
		    indentation = curSpace + how
		  }
		  indentation = Math.max(0, indentation)

		  var indentString = "", pos = 0
		  if (cm.options.indentWithTabs)
		    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t"} }
		  if (pos < indentation) { indentString += spaceStr(indentation - pos) }

		  if (indentString != curSpaceString) {
		    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input")
		    line.stateAfter = null
		    return true
		  } else {
		    // Ensure that, if the cursor was in the whitespace at the start
		    // of the line, it is moved to the end of that space.
		    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
		      var range = doc.sel.ranges[i$1]
		      if (range.head.line == n && range.head.ch < curSpaceString.length) {
		        var pos$1 = Pos(n, curSpaceString.length)
		        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))
		        break
		      }
		    }
		  }
		}

		// This will be set to a {lineWise: bool, text: [string]} object, so
		// that, when pasting, we know what kind of selections the copied
		// text was made out of.
		var lastCopied = null

		function setLastCopied(newLastCopied) {
		  lastCopied = newLastCopied
		}

		function applyTextInput(cm, inserted, deleted, sel, origin) {
		  var doc = cm.doc
		  cm.display.shift = false
		  if (!sel) { sel = doc.sel }

		  var paste = cm.state.pasteIncoming || origin == "paste"
		  var textLines = splitLinesAuto(inserted), multiPaste = null
		  // When pasing N lines into N selections, insert one line per selection
		  if (paste && sel.ranges.length > 1) {
		    if (lastCopied && lastCopied.text.join("\n") == inserted) {
		      if (sel.ranges.length % lastCopied.text.length == 0) {
		        multiPaste = []
		        for (var i = 0; i < lastCopied.text.length; i++)
		          { multiPaste.push(doc.splitLines(lastCopied.text[i])) }
		      }
		    } else if (textLines.length == sel.ranges.length) {
		      multiPaste = map(textLines, function (l) { return [l]; })
		    }
		  }

		  var updateInput
		  // Normal behavior is to insert the new text into every selection
		  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
		    var range = sel.ranges[i$1]
		    var from = range.from(), to = range.to()
		    if (range.empty()) {
		      if (deleted && deleted > 0) // Handle deletion
		        { from = Pos(from.line, from.ch - deleted) }
		      else if (cm.state.overwrite && !paste) // Handle overwrite
		        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) }
		      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
		        { from = to = Pos(from.line, 0) }
		    }
		    updateInput = cm.curOp.updateInput
		    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
		                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")}
		    makeChange(cm.doc, changeEvent)
		    signalLater(cm, "inputRead", cm, changeEvent)
		  }
		  if (inserted && !paste)
		    { triggerElectric(cm, inserted) }

		  ensureCursorVisible(cm)
		  cm.curOp.updateInput = updateInput
		  cm.curOp.typing = true
		  cm.state.pasteIncoming = cm.state.cutIncoming = false
		}

		function handlePaste(e, cm) {
		  var pasted = e.clipboardData && e.clipboardData.getData("Text")
		  if (pasted) {
		    e.preventDefault()
		    if (!cm.isReadOnly() && !cm.options.disableInput)
		      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }) }
		    return true
		  }
		}

		function triggerElectric(cm, inserted) {
		  // When an 'electric' character is inserted, immediately trigger a reindent
		  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
		  var sel = cm.doc.sel

		  for (var i = sel.ranges.length - 1; i >= 0; i--) {
		    var range = sel.ranges[i]
		    if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
		    var mode = cm.getModeAt(range.head)
		    var indented = false
		    if (mode.electricChars) {
		      for (var j = 0; j < mode.electricChars.length; j++)
		        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
		          indented = indentLine(cm, range.head.line, "smart")
		          break
		        } }
		    } else if (mode.electricInput) {
		      if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
		        { indented = indentLine(cm, range.head.line, "smart") }
		    }
		    if (indented) { signalLater(cm, "electricInput", cm, range.head.line) }
		  }
		}

		function copyableRanges(cm) {
		  var text = [], ranges = []
		  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
		    var line = cm.doc.sel.ranges[i].head.line
		    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)}
		    ranges.push(lineRange)
		    text.push(cm.getRange(lineRange.anchor, lineRange.head))
		  }
		  return {text: text, ranges: ranges}
		}

		function disableBrowserMagic(field, spellcheck) {
		  field.setAttribute("autocorrect", "off")
		  field.setAttribute("autocapitalize", "off")
		  field.setAttribute("spellcheck", !!spellcheck)
		}

		function hiddenTextarea() {
		  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none")
		  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;")
		  // The textarea is kept positioned near the cursor to prevent the
		  // fact that it'll be scrolled into view on input from scrolling
		  // our fake cursor out of view. On webkit, when wrap=off, paste is
		  // very slow. So make the area wide instead.
		  if (webkit) { te.style.width = "1000px" }
		  else { te.setAttribute("wrap", "off") }
		  // If border: 0; -- iOS fails to open keyboard (issue #1287)
		  if (ios) { te.style.border = "1px solid black" }
		  disableBrowserMagic(te)
		  return div
		}

		// The publicly visible API. Note that methodOp(f) means
		// 'wrap f in an operation, performed on its `this` parameter'.

		// This is not the complete set of editor methods. Most of the
		// methods defined on the Doc type are also injected into
		// CodeMirror.prototype, for backwards compatibility and
		// convenience.

		function addEditorMethods(CodeMirror) {
		  var optionHandlers = CodeMirror.optionHandlers

		  var helpers = CodeMirror.helpers = {}

		  CodeMirror.prototype = {
		    constructor: CodeMirror,
		    focus: function(){window.focus(); this.display.input.focus()},

		    setOption: function(option, value) {
		      var options = this.options, old = options[option]
		      if (options[option] == value && option != "mode") { return }
		      options[option] = value
		      if (optionHandlers.hasOwnProperty(option))
		        { operation(this, optionHandlers[option])(this, value, old) }
		      signal(this, "optionChange", this, option)
		    },

		    getOption: function(option) {return this.options[option]},
		    getDoc: function() {return this.doc},

		    addKeyMap: function(map, bottom) {
		      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map))
		    },
		    removeKeyMap: function(map) {
		      var maps = this.state.keyMaps
		      for (var i = 0; i < maps.length; ++i)
		        { if (maps[i] == map || maps[i].name == map) {
		          maps.splice(i, 1)
		          return true
		        } }
		    },

		    addOverlay: methodOp(function(spec, options) {
		      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec)
		      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
		      insertSorted(this.state.overlays,
		                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
		                    priority: (options && options.priority) || 0},
		                   function (overlay) { return overlay.priority; })
		      this.state.modeGen++
		      regChange(this)
		    }),
		    removeOverlay: methodOp(function(spec) {
		      var this$1 = this;

		      var overlays = this.state.overlays
		      for (var i = 0; i < overlays.length; ++i) {
		        var cur = overlays[i].modeSpec
		        if (cur == spec || typeof spec == "string" && cur.name == spec) {
		          overlays.splice(i, 1)
		          this$1.state.modeGen++
		          regChange(this$1)
		          return
		        }
		      }
		    }),

		    indentLine: methodOp(function(n, dir, aggressive) {
		      if (typeof dir != "string" && typeof dir != "number") {
		        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev" }
		        else { dir = dir ? "add" : "subtract" }
		      }
		      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive) }
		    }),
		    indentSelection: methodOp(function(how) {
		      var this$1 = this;

		      var ranges = this.doc.sel.ranges, end = -1
		      for (var i = 0; i < ranges.length; i++) {
		        var range = ranges[i]
		        if (!range.empty()) {
		          var from = range.from(), to = range.to()
		          var start = Math.max(end, from.line)
		          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1
		          for (var j = start; j < end; ++j)
		            { indentLine(this$1, j, how) }
		          var newRanges = this$1.doc.sel.ranges
		          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
		            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll) }
		        } else if (range.head.line > end) {
		          indentLine(this$1, range.head.line, how, true)
		          end = range.head.line
		          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1) }
		        }
		      }
		    }),

		    // Fetch the parser token for a given character. Useful for hacks
		    // that want to inspect the mode state (say, for completion).
		    getTokenAt: function(pos, precise) {
		      return takeToken(this, pos, precise)
		    },

		    getLineTokens: function(line, precise) {
		      return takeToken(this, Pos(line), precise, true)
		    },

		    getTokenTypeAt: function(pos) {
		      pos = clipPos(this.doc, pos)
		      var styles = getLineStyles(this, getLine(this.doc, pos.line))
		      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch
		      var type
		      if (ch == 0) { type = styles[2] }
		      else { for (;;) {
		        var mid = (before + after) >> 1
		        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid }
		        else if (styles[mid * 2 + 1] < ch) { before = mid + 1 }
		        else { type = styles[mid * 2 + 2]; break }
		      } }
		      var cut = type ? type.indexOf("overlay ") : -1
		      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
		    },

		    getModeAt: function(pos) {
		      var mode = this.doc.mode
		      if (!mode.innerMode) { return mode }
		      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
		    },

		    getHelper: function(pos, type) {
		      return this.getHelpers(pos, type)[0]
		    },

		    getHelpers: function(pos, type) {
		      var this$1 = this;

		      var found = []
		      if (!helpers.hasOwnProperty(type)) { return found }
		      var help = helpers[type], mode = this.getModeAt(pos)
		      if (typeof mode[type] == "string") {
		        if (help[mode[type]]) { found.push(help[mode[type]]) }
		      } else if (mode[type]) {
		        for (var i = 0; i < mode[type].length; i++) {
		          var val = help[mode[type][i]]
		          if (val) { found.push(val) }
		        }
		      } else if (mode.helperType && help[mode.helperType]) {
		        found.push(help[mode.helperType])
		      } else if (help[mode.name]) {
		        found.push(help[mode.name])
		      }
		      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
		        var cur = help._global[i$1]
		        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
		          { found.push(cur.val) }
		      }
		      return found
		    },

		    getStateAfter: function(line, precise) {
		      var doc = this.doc
		      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line)
		      return getStateBefore(this, line + 1, precise)
		    },

		    cursorCoords: function(start, mode) {
		      var pos, range = this.doc.sel.primary()
		      if (start == null) { pos = range.head }
		      else if (typeof start == "object") { pos = clipPos(this.doc, start) }
		      else { pos = start ? range.from() : range.to() }
		      return cursorCoords(this, pos, mode || "page")
		    },

		    charCoords: function(pos, mode) {
		      return charCoords(this, clipPos(this.doc, pos), mode || "page")
		    },

		    coordsChar: function(coords, mode) {
		      coords = fromCoordSystem(this, coords, mode || "page")
		      return coordsChar(this, coords.left, coords.top)
		    },

		    lineAtHeight: function(height, mode) {
		      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top
		      return lineAtHeight(this.doc, height + this.display.viewOffset)
		    },
		    heightAtLine: function(line, mode, includeWidgets) {
		      var end = false, lineObj
		      if (typeof line == "number") {
		        var last = this.doc.first + this.doc.size - 1
		        if (line < this.doc.first) { line = this.doc.first }
		        else if (line > last) { line = last; end = true }
		        lineObj = getLine(this.doc, line)
		      } else {
		        lineObj = line
		      }
		      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets).top +
		        (end ? this.doc.height - heightAtLine(lineObj) : 0)
		    },

		    defaultTextHeight: function() { return textHeight(this.display) },
		    defaultCharWidth: function() { return charWidth(this.display) },

		    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

		    addWidget: function(pos, node, scroll, vert, horiz) {
		      var display = this.display
		      pos = cursorCoords(this, clipPos(this.doc, pos))
		      var top = pos.bottom, left = pos.left
		      node.style.position = "absolute"
		      node.setAttribute("cm-ignore-events", "true")
		      this.display.input.setUneditable(node)
		      display.sizer.appendChild(node)
		      if (vert == "over") {
		        top = pos.top
		      } else if (vert == "above" || vert == "near") {
		        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
		        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth)
		        // Default to positioning above (if specified and possible); otherwise default to positioning below
		        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
		          { top = pos.top - node.offsetHeight }
		        else if (pos.bottom + node.offsetHeight <= vspace)
		          { top = pos.bottom }
		        if (left + node.offsetWidth > hspace)
		          { left = hspace - node.offsetWidth }
		      }
		      node.style.top = top + "px"
		      node.style.left = node.style.right = ""
		      if (horiz == "right") {
		        left = display.sizer.clientWidth - node.offsetWidth
		        node.style.right = "0px"
		      } else {
		        if (horiz == "left") { left = 0 }
		        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2 }
		        node.style.left = left + "px"
		      }
		      if (scroll)
		        { scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight) }
		    },

		    triggerOnKeyDown: methodOp(onKeyDown),
		    triggerOnKeyPress: methodOp(onKeyPress),
		    triggerOnKeyUp: onKeyUp,

		    execCommand: function(cmd) {
		      if (commands.hasOwnProperty(cmd))
		        { return commands[cmd].call(null, this) }
		    },

		    triggerElectric: methodOp(function(text) { triggerElectric(this, text) }),

		    findPosH: function(from, amount, unit, visually) {
		      var this$1 = this;

		      var dir = 1
		      if (amount < 0) { dir = -1; amount = -amount }
		      var cur = clipPos(this.doc, from)
		      for (var i = 0; i < amount; ++i) {
		        cur = findPosH(this$1.doc, cur, dir, unit, visually)
		        if (cur.hitSide) { break }
		      }
		      return cur
		    },

		    moveH: methodOp(function(dir, unit) {
		      var this$1 = this;

		      this.extendSelectionsBy(function (range) {
		        if (this$1.display.shift || this$1.doc.extend || range.empty())
		          { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
		        else
		          { return dir < 0 ? range.from() : range.to() }
		      }, sel_move)
		    }),

		    deleteH: methodOp(function(dir, unit) {
		      var sel = this.doc.sel, doc = this.doc
		      if (sel.somethingSelected())
		        { doc.replaceSelection("", null, "+delete") }
		      else
		        { deleteNearSelection(this, function (range) {
		          var other = findPosH(doc, range.head, dir, unit, false)
		          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
		        }) }
		    }),

		    findPosV: function(from, amount, unit, goalColumn) {
		      var this$1 = this;

		      var dir = 1, x = goalColumn
		      if (amount < 0) { dir = -1; amount = -amount }
		      var cur = clipPos(this.doc, from)
		      for (var i = 0; i < amount; ++i) {
		        var coords = cursorCoords(this$1, cur, "div")
		        if (x == null) { x = coords.left }
		        else { coords.left = x }
		        cur = findPosV(this$1, coords, dir, unit)
		        if (cur.hitSide) { break }
		      }
		      return cur
		    },

		    moveV: methodOp(function(dir, unit) {
		      var this$1 = this;

		      var doc = this.doc, goals = []
		      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected()
		      doc.extendSelectionsBy(function (range) {
		        if (collapse)
		          { return dir < 0 ? range.from() : range.to() }
		        var headPos = cursorCoords(this$1, range.head, "div")
		        if (range.goalColumn != null) { headPos.left = range.goalColumn }
		        goals.push(headPos.left)
		        var pos = findPosV(this$1, headPos, dir, unit)
		        if (unit == "page" && range == doc.sel.primary())
		          { addToScrollPos(this$1, null, charCoords(this$1, pos, "div").top - headPos.top) }
		        return pos
		      }, sel_move)
		      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
		        { doc.sel.ranges[i].goalColumn = goals[i] } }
		    }),

		    // Find the word at the given position (as returned by coordsChar).
		    findWordAt: function(pos) {
		      var doc = this.doc, line = getLine(doc, pos.line).text
		      var start = pos.ch, end = pos.ch
		      if (line) {
		        var helper = this.getHelper(pos, "wordChars")
		        if ((pos.xRel < 0 || end == line.length) && start) { --start; } else { ++end }
		        var startChar = line.charAt(start)
		        var check = isWordChar(startChar, helper)
		          ? function (ch) { return isWordChar(ch, helper); }
		          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
		          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); }
		        while (start > 0 && check(line.charAt(start - 1))) { --start }
		        while (end < line.length && check(line.charAt(end))) { ++end }
		      }
		      return new Range(Pos(pos.line, start), Pos(pos.line, end))
		    },

		    toggleOverwrite: function(value) {
		      if (value != null && value == this.state.overwrite) { return }
		      if (this.state.overwrite = !this.state.overwrite)
		        { addClass(this.display.cursorDiv, "CodeMirror-overwrite") }
		      else
		        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite") }

		      signal(this, "overwriteToggle", this, this.state.overwrite)
		    },
		    hasFocus: function() { return this.display.input.getField() == activeElt() },
		    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

		    scrollTo: methodOp(function(x, y) {
		      if (x != null || y != null) { resolveScrollToPos(this) }
		      if (x != null) { this.curOp.scrollLeft = x }
		      if (y != null) { this.curOp.scrollTop = y }
		    }),
		    getScrollInfo: function() {
		      var scroller = this.display.scroller
		      return {left: scroller.scrollLeft, top: scroller.scrollTop,
		              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
		              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
		              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
		    },

		    scrollIntoView: methodOp(function(range, margin) {
		      if (range == null) {
		        range = {from: this.doc.sel.primary().head, to: null}
		        if (margin == null) { margin = this.options.cursorScrollMargin }
		      } else if (typeof range == "number") {
		        range = {from: Pos(range, 0), to: null}
		      } else if (range.from == null) {
		        range = {from: range, to: null}
		      }
		      if (!range.to) { range.to = range.from }
		      range.margin = margin || 0

		      if (range.from.line != null) {
		        resolveScrollToPos(this)
		        this.curOp.scrollToPos = range
		      } else {
		        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
		                                      Math.min(range.from.top, range.to.top) - range.margin,
		                                      Math.max(range.from.right, range.to.right),
		                                      Math.max(range.from.bottom, range.to.bottom) + range.margin)
		        this.scrollTo(sPos.scrollLeft, sPos.scrollTop)
		      }
		    }),

		    setSize: methodOp(function(width, height) {
		      var this$1 = this;

		      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; }
		      if (width != null) { this.display.wrapper.style.width = interpret(width) }
		      if (height != null) { this.display.wrapper.style.height = interpret(height) }
		      if (this.options.lineWrapping) { clearLineMeasurementCache(this) }
		      var lineNo = this.display.viewFrom
		      this.doc.iter(lineNo, this.display.viewTo, function (line) {
		        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
		          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
		        ++lineNo
		      })
		      this.curOp.forceUpdate = true
		      signal(this, "refresh", this)
		    }),

		    operation: function(f){return runInOp(this, f)},

		    refresh: methodOp(function() {
		      var oldHeight = this.display.cachedTextHeight
		      regChange(this)
		      this.curOp.forceUpdate = true
		      clearCaches(this)
		      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop)
		      updateGutterSpace(this)
		      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
		        { estimateLineHeights(this) }
		      signal(this, "refresh", this)
		    }),

		    swapDoc: methodOp(function(doc) {
		      var old = this.doc
		      old.cm = null
		      attachDoc(this, doc)
		      clearCaches(this)
		      this.display.input.reset()
		      this.scrollTo(doc.scrollLeft, doc.scrollTop)
		      this.curOp.forceScroll = true
		      signalLater(this, "swapDoc", this, old)
		      return old
		    }),

		    getInputField: function(){return this.display.input.getField()},
		    getWrapperElement: function(){return this.display.wrapper},
		    getScrollerElement: function(){return this.display.scroller},
		    getGutterElement: function(){return this.display.gutters}
		  }
		  eventMixin(CodeMirror)

		  CodeMirror.registerHelper = function(type, name, value) {
		    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []} }
		    helpers[type][name] = value
		  }
		  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
		    CodeMirror.registerHelper(type, name, value)
		    helpers[type]._global.push({pred: predicate, val: value})
		  }
		}

		// Used for horizontal relative motion. Dir is -1 or 1 (left or
		// right), unit can be "char", "column" (like char, but doesn't
		// cross line boundaries), "word" (across next word), or "group" (to
		// the start of next group of word or non-word-non-whitespace
		// chars). The visually param controls whether, in right-to-left
		// text, direction 1 means to move towards the next index in the
		// string, or towards the character to the right of the current
		// position. The resulting position will have a hitSide=true
		// property if it reached the end of the document.
		function findPosH(doc, pos, dir, unit, visually) {
		  var line = pos.line, ch = pos.ch, origDir = dir
		  var lineObj = getLine(doc, line)
		  function findNextLine() {
		    var l = line + dir
		    if (l < doc.first || l >= doc.first + doc.size) { return false }
		    line = l
		    return lineObj = getLine(doc, l)
		  }
		  function moveOnce(boundToLine) {
		    var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true)
		    if (next == null) {
		      if (!boundToLine && findNextLine()) {
		        if (visually) { ch = (dir < 0 ? lineRight : lineLeft)(lineObj) }
		        else { ch = dir < 0 ? lineObj.text.length : 0 }
		      } else { return false }
		    } else { ch = next }
		    return true
		  }

		  if (unit == "char") {
		    moveOnce()
		  } else if (unit == "column") {
		    moveOnce(true)
		  } else if (unit == "word" || unit == "group") {
		    var sawType = null, group = unit == "group"
		    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars")
		    for (var first = true;; first = false) {
		      if (dir < 0 && !moveOnce(!first)) { break }
		      var cur = lineObj.text.charAt(ch) || "\n"
		      var type = isWordChar(cur, helper) ? "w"
		        : group && cur == "\n" ? "n"
		        : !group || /\s/.test(cur) ? null
		        : "p"
		      if (group && !first && !type) { type = "s" }
		      if (sawType && sawType != type) {
		        if (dir < 0) {dir = 1; moveOnce()}
		        break
		      }

		      if (type) { sawType = type }
		      if (dir > 0 && !moveOnce(!first)) { break }
		    }
		  }
		  var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true)
		  if (!cmp(pos, result)) { result.hitSide = true }
		  return result
		}

		// For relative vertical movement. Dir may be -1 or 1. Unit can be
		// "page" or "line". The resulting position will have a hitSide=true
		// property if it reached the end of the document.
		function findPosV(cm, pos, dir, unit) {
		  var doc = cm.doc, x = pos.left, y
		  if (unit == "page") {
		    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)
		    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3)
		    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount

		  } else if (unit == "line") {
		    y = dir > 0 ? pos.bottom + 3 : pos.top - 3
		  }
		  var target
		  for (;;) {
		    target = coordsChar(cm, x, y)
		    if (!target.outside) { break }
		    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
		    y += dir * 5
		  }
		  return target
		}

		// CONTENTEDITABLE INPUT STYLE

		var ContentEditableInput = function(cm) {
		  this.cm = cm
		  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null
		  this.polling = new Delayed()
		  this.composing = null
		  this.gracePeriod = false
		  this.readDOMTimeout = null
		};

		ContentEditableInput.prototype.init = function (display) {
		    var this$1 = this;

		  var input = this, cm = input.cm
		  var div = input.div = display.lineDiv
		  disableBrowserMagic(div, cm.options.spellcheck)

		  on(div, "paste", function (e) {
		    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
		    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
		    if (ie_version <= 11) { setTimeout(operation(cm, function () {
		      if (!input.pollContent()) { regChange(cm) }
		    }), 20) }
		  })

		  on(div, "compositionstart", function (e) {
		    this$1.composing = {data: e.data, done: false}
		  })
		  on(div, "compositionupdate", function (e) {
		    if (!this$1.composing) { this$1.composing = {data: e.data, done: false} }
		  })
		  on(div, "compositionend", function (e) {
		    if (this$1.composing) {
		      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon() }
		      this$1.composing.done = true
		    }
		  })

		  on(div, "touchstart", function () { return input.forceCompositionEnd(); })

		  on(div, "input", function () {
		    if (!this$1.composing) { this$1.readFromDOMSoon() }
		  })

		  function onCopyCut(e) {
		    if (signalDOMEvent(cm, e)) { return }
		    if (cm.somethingSelected()) {
		      setLastCopied({lineWise: false, text: cm.getSelections()})
		      if (e.type == "cut") { cm.replaceSelection("", null, "cut") }
		    } else if (!cm.options.lineWiseCopyCut) {
		      return
		    } else {
		      var ranges = copyableRanges(cm)
		      setLastCopied({lineWise: true, text: ranges.text})
		      if (e.type == "cut") {
		        cm.operation(function () {
		          cm.setSelections(ranges.ranges, 0, sel_dontScroll)
		          cm.replaceSelection("", null, "cut")
		        })
		      }
		    }
		    if (e.clipboardData) {
		      e.clipboardData.clearData()
		      var content = lastCopied.text.join("\n")
		      // iOS exposes the clipboard API, but seems to discard content inserted into it
		      e.clipboardData.setData("Text", content)
		      if (e.clipboardData.getData("Text") == content) {
		        e.preventDefault()
		        return
		      }
		    }
		    // Old-fashioned briefly-focus-a-textarea hack
		    var kludge = hiddenTextarea(), te = kludge.firstChild
		    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild)
		    te.value = lastCopied.text.join("\n")
		    var hadFocus = document.activeElement
		    selectInput(te)
		    setTimeout(function () {
		      cm.display.lineSpace.removeChild(kludge)
		      hadFocus.focus()
		      if (hadFocus == div) { input.showPrimarySelection() }
		    }, 50)
		  }
		  on(div, "copy", onCopyCut)
		  on(div, "cut", onCopyCut)
		};

		ContentEditableInput.prototype.prepareSelection = function () {
		  var result = prepareSelection(this.cm, false)
		  result.focus = this.cm.state.focused
		  return result
		};

		ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
		  if (!info || !this.cm.display.view.length) { return }
		  if (info.focus || takeFocus) { this.showPrimarySelection() }
		  this.showMultipleSelections(info)
		};

		ContentEditableInput.prototype.showPrimarySelection = function () {
		  var sel = window.getSelection(), prim = this.cm.doc.sel.primary()
		  var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset)
		  var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset)
		  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
		      cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
		      cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
		    { return }

		  var start = posToDOM(this.cm, prim.from())
		  var end = posToDOM(this.cm, prim.to())
		  if (!start && !end) { return }

		  var view = this.cm.display.view
		  var old = sel.rangeCount && sel.getRangeAt(0)
		  if (!start) {
		    start = {node: view[0].measure.map[2], offset: 0}
		  } else if (!end) { // FIXME dangerously hacky
		    var measure = view[view.length - 1].measure
		    var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map
		    end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]}
		  }

		  var rng
		  try { rng = range(start.node, start.offset, end.offset, end.node) }
		  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
		  if (rng) {
		    if (!gecko && this.cm.state.focused) {
		      sel.collapse(start.node, start.offset)
		      if (!rng.collapsed) {
		        sel.removeAllRanges()
		        sel.addRange(rng)
		      }
		    } else {
		      sel.removeAllRanges()
		      sel.addRange(rng)
		    }
		    if (old && sel.anchorNode == null) { sel.addRange(old) }
		    else if (gecko) { this.startGracePeriod() }
		  }
		  this.rememberSelection()
		};

		ContentEditableInput.prototype.startGracePeriod = function () {
		    var this$1 = this;

		  clearTimeout(this.gracePeriod)
		  this.gracePeriod = setTimeout(function () {
		    this$1.gracePeriod = false
		    if (this$1.selectionChanged())
		      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }) }
		  }, 20)
		};

		ContentEditableInput.prototype.showMultipleSelections = function (info) {
		  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)
		  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)
		};

		ContentEditableInput.prototype.rememberSelection = function () {
		  var sel = window.getSelection()
		  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset
		  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset
		};

		ContentEditableInput.prototype.selectionInEditor = function () {
		  var sel = window.getSelection()
		  if (!sel.rangeCount) { return false }
		  var node = sel.getRangeAt(0).commonAncestorContainer
		  return contains(this.div, node)
		};

		ContentEditableInput.prototype.focus = function () {
		  if (this.cm.options.readOnly != "nocursor") {
		    if (!this.selectionInEditor())
		      { this.showSelection(this.prepareSelection(), true) }
		    this.div.focus()
		  }
		};
		ContentEditableInput.prototype.blur = function () { this.div.blur() };
		ContentEditableInput.prototype.getField = function () { return this.div };

		ContentEditableInput.prototype.supportsTouch = function () { return true };

		ContentEditableInput.prototype.receivedFocus = function () {
		  var input = this
		  if (this.selectionInEditor())
		    { this.pollSelection() }
		  else
		    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }) }

		  function poll() {
		    if (input.cm.state.focused) {
		      input.pollSelection()
		      input.polling.set(input.cm.options.pollInterval, poll)
		    }
		  }
		  this.polling.set(this.cm.options.pollInterval, poll)
		};

		ContentEditableInput.prototype.selectionChanged = function () {
		  var sel = window.getSelection()
		  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
		    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
		};

		ContentEditableInput.prototype.pollSelection = function () {
		  if (!this.composing && this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) {
		    var sel = window.getSelection(), cm = this.cm
		    this.rememberSelection()
		    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)
		    var head = domToPos(cm, sel.focusNode, sel.focusOffset)
		    if (anchor && head) { runInOp(cm, function () {
		      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll)
		      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true }
		    }) }
		  }
		};

		ContentEditableInput.prototype.pollContent = function () {
		  if (this.readDOMTimeout != null) {
		    clearTimeout(this.readDOMTimeout)
		    this.readDOMTimeout = null
		  }

		  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary()
		  var from = sel.from(), to = sel.to()
		  if (from.ch == 0 && from.line > cm.firstLine())
		    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length) }
		  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
		    { to = Pos(to.line + 1, 0) }
		  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

		  var fromIndex, fromLine, fromNode
		  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
		    fromLine = lineNo(display.view[0].line)
		    fromNode = display.view[0].node
		  } else {
		    fromLine = lineNo(display.view[fromIndex].line)
		    fromNode = display.view[fromIndex - 1].node.nextSibling
		  }
		  var toIndex = findViewIndex(cm, to.line)
		  var toLine, toNode
		  if (toIndex == display.view.length - 1) {
		    toLine = display.viewTo - 1
		    toNode = display.lineDiv.lastChild
		  } else {
		    toLine = lineNo(display.view[toIndex + 1].line) - 1
		    toNode = display.view[toIndex + 1].node.previousSibling
		  }

		  if (!fromNode) { return false }
		  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine))
		  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length))
		  while (newText.length > 1 && oldText.length > 1) {
		    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine-- }
		    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++ }
		    else { break }
		  }

		  var cutFront = 0, cutEnd = 0
		  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length)
		  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
		    { ++cutFront }
		  var newBot = lst(newText), oldBot = lst(oldText)
		  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
		                           oldBot.length - (oldText.length == 1 ? cutFront : 0))
		  while (cutEnd < maxCutEnd &&
		         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
		    { ++cutEnd }

		  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "")
		  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "")

		  var chFrom = Pos(fromLine, cutFront)
		  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0)
		  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
		    replaceRange(cm.doc, newText, chFrom, chTo, "+input")
		    return true
		  }
		};

		ContentEditableInput.prototype.ensurePolled = function () {
		  this.forceCompositionEnd()
		};
		ContentEditableInput.prototype.reset = function () {
		  this.forceCompositionEnd()
		};
		ContentEditableInput.prototype.forceCompositionEnd = function () {
		  if (!this.composing) { return }
		  clearTimeout(this.readDOMTimeout)
		  this.composing = null
		  if (!this.pollContent()) { regChange(this.cm) }
		  this.div.blur()
		  this.div.focus()
		};
		ContentEditableInput.prototype.readFromDOMSoon = function () {
		    var this$1 = this;

		  if (this.readDOMTimeout != null) { return }
		  this.readDOMTimeout = setTimeout(function () {
		    this$1.readDOMTimeout = null
		    if (this$1.composing) {
		      if (this$1.composing.done) { this$1.composing = null }
		      else { return }
		    }
		    if (this$1.cm.isReadOnly() || !this$1.pollContent())
		      { runInOp(this$1.cm, function () { return regChange(this$1.cm); }) }
		  }, 80)
		};

		ContentEditableInput.prototype.setUneditable = function (node) {
		  node.contentEditable = "false"
		};

		ContentEditableInput.prototype.onKeyPress = function (e) {
		  e.preventDefault()
		  if (!this.cm.isReadOnly())
		    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0) }
		};

		ContentEditableInput.prototype.readOnlyChanged = function (val) {
		  this.div.contentEditable = String(val != "nocursor")
		};

		ContentEditableInput.prototype.onContextMenu = function () {};
		ContentEditableInput.prototype.resetPosition = function () {};

		ContentEditableInput.prototype.needsContentAttribute = true

		function posToDOM(cm, pos) {
		  var view = findViewForLine(cm, pos.line)
		  if (!view || view.hidden) { return null }
		  var line = getLine(cm.doc, pos.line)
		  var info = mapFromLineView(view, line, pos.line)

		  var order = getOrder(line), side = "left"
		  if (order) {
		    var partPos = getBidiPartAt(order, pos.ch)
		    side = partPos % 2 ? "right" : "left"
		  }
		  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)
		  result.offset = result.collapse == "right" ? result.end : result.start
		  return result
		}

		function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

		function domTextBetween(cm, from, to, fromLine, toLine) {
		  var text = "", closing = false, lineSep = cm.doc.lineSeparator()
		  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
		  function walk(node) {
		    if (node.nodeType == 1) {
		      var cmText = node.getAttribute("cm-text")
		      if (cmText != null) {
		        if (cmText == "") { text += node.textContent.replace(/\u200b/g, "") }
		        else { text += cmText }
		        return
		      }
		      var markerID = node.getAttribute("cm-marker"), range
		      if (markerID) {
		        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID))
		        if (found.length && (range = found[0].find()))
		          { text += getBetween(cm.doc, range.from, range.to).join(lineSep) }
		        return
		      }
		      if (node.getAttribute("contenteditable") == "false") { return }
		      for (var i = 0; i < node.childNodes.length; i++)
		        { walk(node.childNodes[i]) }
		      if (/^(pre|div|p)$/i.test(node.nodeName))
		        { closing = true }
		    } else if (node.nodeType == 3) {
		      var val = node.nodeValue
		      if (!val) { return }
		      if (closing) {
		        text += lineSep
		        closing = false
		      }
		      text += val
		    }
		  }
		  for (;;) {
		    walk(from)
		    if (from == to) { break }
		    from = from.nextSibling
		  }
		  return text
		}

		function domToPos(cm, node, offset) {
		  var lineNode
		  if (node == cm.display.lineDiv) {
		    lineNode = cm.display.lineDiv.childNodes[offset]
		    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
		    node = null; offset = 0
		  } else {
		    for (lineNode = node;; lineNode = lineNode.parentNode) {
		      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
		      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
		    }
		  }
		  for (var i = 0; i < cm.display.view.length; i++) {
		    var lineView = cm.display.view[i]
		    if (lineView.node == lineNode)
		      { return locateNodeInLineView(lineView, node, offset) }
		  }
		}

		function locateNodeInLineView(lineView, node, offset) {
		  var wrapper = lineView.text.firstChild, bad = false
		  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
		  if (node == wrapper) {
		    bad = true
		    node = wrapper.childNodes[offset]
		    offset = 0
		    if (!node) {
		      var line = lineView.rest ? lst(lineView.rest) : lineView.line
		      return badPos(Pos(lineNo(line), line.text.length), bad)
		    }
		  }

		  var textNode = node.nodeType == 3 ? node : null, topNode = node
		  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
		    textNode = node.firstChild
		    if (offset) { offset = textNode.nodeValue.length }
		  }
		  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode }
		  var measure = lineView.measure, maps = measure.maps

		  function find(textNode, topNode, offset) {
		    for (var i = -1; i < (maps ? maps.length : 0); i++) {
		      var map = i < 0 ? measure.map : maps[i]
		      for (var j = 0; j < map.length; j += 3) {
		        var curNode = map[j + 2]
		        if (curNode == textNode || curNode == topNode) {
		          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i])
		          var ch = map[j] + offset
		          if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)] }
		          return Pos(line, ch)
		        }
		      }
		    }
		  }
		  var found = find(textNode, topNode, offset)
		  if (found) { return badPos(found, bad) }

		  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
		  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
		    found = find(after, after.firstChild, 0)
		    if (found)
		      { return badPos(Pos(found.line, found.ch - dist), bad) }
		    else
		      { dist += after.textContent.length }
		  }
		  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
		    found = find(before, before.firstChild, -1)
		    if (found)
		      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
		    else
		      { dist$1 += before.textContent.length }
		  }
		}

		// TEXTAREA INPUT STYLE

		var TextareaInput = function(cm) {
		  this.cm = cm
		  // See input.poll and input.reset
		  this.prevInput = ""

		  // Flag that indicates whether we expect input to appear real soon
		  // now (after some event like 'keypress' or 'input') and are
		  // polling intensively.
		  this.pollingFast = false
		  // Self-resetting timeout for the poller
		  this.polling = new Delayed()
		  // Tracks when input.reset has punted to just putting a short
		  // string into the textarea instead of the full selection.
		  this.inaccurateSelection = false
		  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
		  this.hasSelection = false
		  this.composing = null
		};

		TextareaInput.prototype.init = function (display) {
		    var this$1 = this;

		  var input = this, cm = this.cm

		  // Wraps and hides input textarea
		  var div = this.wrapper = hiddenTextarea()
		  // The semihidden textarea that is focused when the editor is
		  // focused, and receives input.
		  var te = this.textarea = div.firstChild
		  display.wrapper.insertBefore(div, display.wrapper.firstChild)

		  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
		  if (ios) { te.style.width = "0px" }

		  on(te, "input", function () {
		    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null }
		    input.poll()
		  })

		  on(te, "paste", function (e) {
		    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

		    cm.state.pasteIncoming = true
		    input.fastPoll()
		  })

		  function prepareCopyCut(e) {
		    if (signalDOMEvent(cm, e)) { return }
		    if (cm.somethingSelected()) {
		      setLastCopied({lineWise: false, text: cm.getSelections()})
		      if (input.inaccurateSelection) {
		        input.prevInput = ""
		        input.inaccurateSelection = false
		        te.value = lastCopied.text.join("\n")
		        selectInput(te)
		      }
		    } else if (!cm.options.lineWiseCopyCut) {
		      return
		    } else {
		      var ranges = copyableRanges(cm)
		      setLastCopied({lineWise: true, text: ranges.text})
		      if (e.type == "cut") {
		        cm.setSelections(ranges.ranges, null, sel_dontScroll)
		      } else {
		        input.prevInput = ""
		        te.value = ranges.text.join("\n")
		        selectInput(te)
		      }
		    }
		    if (e.type == "cut") { cm.state.cutIncoming = true }
		  }
		  on(te, "cut", prepareCopyCut)
		  on(te, "copy", prepareCopyCut)

		  on(display.scroller, "paste", function (e) {
		    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
		    cm.state.pasteIncoming = true
		    input.focus()
		  })

		  // Prevent normal selection in the editor (we handle our own)
		  on(display.lineSpace, "selectstart", function (e) {
		    if (!eventInWidget(display, e)) { e_preventDefault(e) }
		  })

		  on(te, "compositionstart", function () {
		    var start = cm.getCursor("from")
		    if (input.composing) { input.composing.range.clear() }
		    input.composing = {
		      start: start,
		      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
		    }
		  })
		  on(te, "compositionend", function () {
		    if (input.composing) {
		      input.poll()
		      input.composing.range.clear()
		      input.composing = null
		    }
		  })
		};

		TextareaInput.prototype.prepareSelection = function () {
		  // Redraw the selection and/or cursor
		  var cm = this.cm, display = cm.display, doc = cm.doc
		  var result = prepareSelection(cm)

		  // Move the hidden textarea near the cursor to prevent scrolling artifacts
		  if (cm.options.moveInputWithCursor) {
		    var headPos = cursorCoords(cm, doc.sel.primary().head, "div")
		    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect()
		    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
		                                        headPos.top + lineOff.top - wrapOff.top))
		    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
		                                         headPos.left + lineOff.left - wrapOff.left))
		  }

		  return result
		};

		TextareaInput.prototype.showSelection = function (drawn) {
		  var cm = this.cm, display = cm.display
		  removeChildrenAndAdd(display.cursorDiv, drawn.cursors)
		  removeChildrenAndAdd(display.selectionDiv, drawn.selection)
		  if (drawn.teTop != null) {
		    this.wrapper.style.top = drawn.teTop + "px"
		    this.wrapper.style.left = drawn.teLeft + "px"
		  }
		};

		// Reset the input to correspond to the selection (or to be empty,
		// when not typing and nothing is selected)
		TextareaInput.prototype.reset = function (typing) {
		  if (this.contextMenuPending) { return }
		  var minimal, selected, cm = this.cm, doc = cm.doc
		  if (cm.somethingSelected()) {
		    this.prevInput = ""
		    var range = doc.sel.primary()
		    minimal = hasCopyEvent &&
		      (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000)
		    var content = minimal ? "-" : selected || cm.getSelection()
		    this.textarea.value = content
		    if (cm.state.focused) { selectInput(this.textarea) }
		    if (ie && ie_version >= 9) { this.hasSelection = content }
		  } else if (!typing) {
		    this.prevInput = this.textarea.value = ""
		    if (ie && ie_version >= 9) { this.hasSelection = null }
		  }
		  this.inaccurateSelection = minimal
		};

		TextareaInput.prototype.getField = function () { return this.textarea };

		TextareaInput.prototype.supportsTouch = function () { return false };

		TextareaInput.prototype.focus = function () {
		  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
		    try { this.textarea.focus() }
		    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
		  }
		};

		TextareaInput.prototype.blur = function () { this.textarea.blur() };

		TextareaInput.prototype.resetPosition = function () {
		  this.wrapper.style.top = this.wrapper.style.left = 0
		};

		TextareaInput.prototype.receivedFocus = function () { this.slowPoll() };

		// Poll for input changes, using the normal rate of polling. This
		// runs as long as the editor is focused.
		TextareaInput.prototype.slowPoll = function () {
		    var this$1 = this;

		  if (this.pollingFast) { return }
		  this.polling.set(this.cm.options.pollInterval, function () {
		    this$1.poll()
		    if (this$1.cm.state.focused) { this$1.slowPoll() }
		  })
		};

		// When an event has just come in that is likely to add or change
		// something in the input textarea, we poll faster, to ensure that
		// the change appears on the screen quickly.
		TextareaInput.prototype.fastPoll = function () {
		  var missed = false, input = this
		  input.pollingFast = true
		  function p() {
		    var changed = input.poll()
		    if (!changed && !missed) {missed = true; input.polling.set(60, p)}
		    else {input.pollingFast = false; input.slowPoll()}
		  }
		  input.polling.set(20, p)
		};

		// Read input from the textarea, and update the document to match.
		// When something is selected, it is present in the textarea, and
		// selected (unless it is huge, in which case a placeholder is
		// used). When nothing is selected, the cursor sits after previously
		// seen text (can be empty), which is stored in prevInput (we must
		// not reset the textarea when typing, because that breaks IME).
		TextareaInput.prototype.poll = function () {
		    var this$1 = this;

		  var cm = this.cm, input = this.textarea, prevInput = this.prevInput
		  // Since this is called a *lot*, try to bail out as cheaply as
		  // possible when it is clear that nothing happened. hasSelection
		  // will be the case when there is a lot of text in the textarea,
		  // in which case reading its value would be expensive.
		  if (this.contextMenuPending || !cm.state.focused ||
		      (hasSelection(input) && !prevInput && !this.composing) ||
		      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
		    { return false }

		  var text = input.value
		  // If nothing changed, bail.
		  if (text == prevInput && !cm.somethingSelected()) { return false }
		  // Work around nonsensical selection resetting in IE9/10, and
		  // inexplicable appearance of private area unicode characters on
		  // some key combos in Mac (#2689).
		  if (ie && ie_version >= 9 && this.hasSelection === text ||
		      mac && /[\uf700-\uf7ff]/.test(text)) {
		    cm.display.input.reset()
		    return false
		  }

		  if (cm.doc.sel == cm.display.selForContextMenu) {
		    var first = text.charCodeAt(0)
		    if (first == 0x200b && !prevInput) { prevInput = "\u200b" }
		    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
		  }
		  // Find the part of the input that is actually new
		  var same = 0, l = Math.min(prevInput.length, text.length)
		  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same }

		  runInOp(cm, function () {
		    applyTextInput(cm, text.slice(same), prevInput.length - same,
		                   null, this$1.composing ? "*compose" : null)

		    // Don't leave long text in the textarea, since it makes further polling slow
		    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = "" }
		    else { this$1.prevInput = text }

		    if (this$1.composing) {
		      this$1.composing.range.clear()
		      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
		                                         {className: "CodeMirror-composing"})
		    }
		  })
		  return true
		};

		TextareaInput.prototype.ensurePolled = function () {
		  if (this.pollingFast && this.poll()) { this.pollingFast = false }
		};

		TextareaInput.prototype.onKeyPress = function () {
		  if (ie && ie_version >= 9) { this.hasSelection = null }
		  this.fastPoll()
		};

		TextareaInput.prototype.onContextMenu = function (e) {
		  var input = this, cm = input.cm, display = cm.display, te = input.textarea
		  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop
		  if (!pos || presto) { return } // Opera is difficult.

		  // Reset the current text selection only if the click is done outside of the selection
		  // and 'resetSelectionOnContextMenu' option is true.
		  var reset = cm.options.resetSelectionOnContextMenu
		  if (reset && cm.doc.sel.contains(pos) == -1)
		    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll) }

		  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText
		  input.wrapper.style.cssText = "position: absolute"
		  var wrapperBox = input.wrapper.getBoundingClientRect()
		  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);"
		  var oldScrollY
		  if (webkit) { oldScrollY = window.scrollY } // Work around Chrome issue (#2712)
		  display.input.focus()
		  if (webkit) { window.scrollTo(null, oldScrollY) }
		  display.input.reset()
		  // Adds "Select all" to context menu in FF
		  if (!cm.somethingSelected()) { te.value = input.prevInput = " " }
		  input.contextMenuPending = true
		  display.selForContextMenu = cm.doc.sel
		  clearTimeout(display.detectingSelectAll)

		  // Select-all will be greyed out if there's nothing to select, so
		  // this adds a zero-width space so that we can later check whether
		  // it got selected.
		  function prepareSelectAllHack() {
		    if (te.selectionStart != null) {
		      var selected = cm.somethingSelected()
		      var extval = "\u200b" + (selected ? te.value : "")
		      te.value = "\u21da" // Used to catch context-menu undo
		      te.value = extval
		      input.prevInput = selected ? "" : "\u200b"
		      te.selectionStart = 1; te.selectionEnd = extval.length
		      // Re-set this, in case some other handler touched the
		      // selection in the meantime.
		      display.selForContextMenu = cm.doc.sel
		    }
		  }
		  function rehide() {
		    input.contextMenuPending = false
		    input.wrapper.style.cssText = oldWrapperCSS
		    te.style.cssText = oldCSS
		    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos) }

		    // Try to detect the user choosing select-all
		    if (te.selectionStart != null) {
		      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack() }
		      var i = 0, poll = function () {
		        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
		            te.selectionEnd > 0 && input.prevInput == "\u200b")
		          { operation(cm, selectAll)(cm) }
		        else if (i++ < 10) { display.detectingSelectAll = setTimeout(poll, 500) }
		        else { display.input.reset() }
		      }
		      display.detectingSelectAll = setTimeout(poll, 200)
		    }
		  }

		  if (ie && ie_version >= 9) { prepareSelectAllHack() }
		  if (captureRightClick) {
		    e_stop(e)
		    var mouseup = function () {
		      off(window, "mouseup", mouseup)
		      setTimeout(rehide, 20)
		    }
		    on(window, "mouseup", mouseup)
		  } else {
		    setTimeout(rehide, 50)
		  }
		};

		TextareaInput.prototype.readOnlyChanged = function (val) {
		  if (!val) { this.reset() }
		};

		TextareaInput.prototype.setUneditable = function () {};

		TextareaInput.prototype.needsContentAttribute = false

		function fromTextArea(textarea, options) {
		  options = options ? copyObj(options) : {}
		  options.value = textarea.value
		  if (!options.tabindex && textarea.tabIndex)
		    { options.tabindex = textarea.tabIndex }
		  if (!options.placeholder && textarea.placeholder)
		    { options.placeholder = textarea.placeholder }
		  // Set autofocus to true if this textarea is focused, or if it has
		  // autofocus and no other element is focused.
		  if (options.autofocus == null) {
		    var hasFocus = activeElt()
		    options.autofocus = hasFocus == textarea ||
		      textarea.getAttribute("autofocus") != null && hasFocus == document.body
		  }

		  function save() {textarea.value = cm.getValue()}

		  var realSubmit
		  if (textarea.form) {
		    on(textarea.form, "submit", save)
		    // Deplorable hack to make the submit method do the right thing.
		    if (!options.leaveSubmitMethodAlone) {
		      var form = textarea.form
		      realSubmit = form.submit
		      try {
		        var wrappedSubmit = form.submit = function () {
		          save()
		          form.submit = realSubmit
		          form.submit()
		          form.submit = wrappedSubmit
		        }
		      } catch(e) {}
		    }
		  }

		  options.finishInit = function (cm) {
		    cm.save = save
		    cm.getTextArea = function () { return textarea; }
		    cm.toTextArea = function () {
		      cm.toTextArea = isNaN // Prevent this from being ran twice
		      save()
		      textarea.parentNode.removeChild(cm.getWrapperElement())
		      textarea.style.display = ""
		      if (textarea.form) {
		        off(textarea.form, "submit", save)
		        if (typeof textarea.form.submit == "function")
		          { textarea.form.submit = realSubmit }
		      }
		    }
		  }

		  textarea.style.display = "none"
		  var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
		    options)
		  return cm
		}

		function addLegacyProps(CodeMirror) {
		  CodeMirror.off = off
		  CodeMirror.on = on
		  CodeMirror.wheelEventPixels = wheelEventPixels
		  CodeMirror.Doc = Doc
		  CodeMirror.splitLines = splitLinesAuto
		  CodeMirror.countColumn = countColumn
		  CodeMirror.findColumn = findColumn
		  CodeMirror.isWordChar = isWordCharBasic
		  CodeMirror.Pass = Pass
		  CodeMirror.signal = signal
		  CodeMirror.Line = Line
		  CodeMirror.changeEnd = changeEnd
		  CodeMirror.scrollbarModel = scrollbarModel
		  CodeMirror.Pos = Pos
		  CodeMirror.cmpPos = cmp
		  CodeMirror.modes = modes
		  CodeMirror.mimeModes = mimeModes
		  CodeMirror.resolveMode = resolveMode
		  CodeMirror.getMode = getMode
		  CodeMirror.modeExtensions = modeExtensions
		  CodeMirror.extendMode = extendMode
		  CodeMirror.copyState = copyState
		  CodeMirror.startState = startState
		  CodeMirror.innerMode = innerMode
		  CodeMirror.commands = commands
		  CodeMirror.keyMap = keyMap
		  CodeMirror.keyName = keyName
		  CodeMirror.isModifierKey = isModifierKey
		  CodeMirror.lookupKey = lookupKey
		  CodeMirror.normalizeKeyMap = normalizeKeyMap
		  CodeMirror.StringStream = StringStream
		  CodeMirror.SharedTextMarker = SharedTextMarker
		  CodeMirror.TextMarker = TextMarker
		  CodeMirror.LineWidget = LineWidget
		  CodeMirror.e_preventDefault = e_preventDefault
		  CodeMirror.e_stopPropagation = e_stopPropagation
		  CodeMirror.e_stop = e_stop
		  CodeMirror.addClass = addClass
		  CodeMirror.contains = contains
		  CodeMirror.rmClass = rmClass
		  CodeMirror.keyNames = keyNames
		}

		// EDITOR CONSTRUCTOR

		defineOptions(CodeMirror)

		addEditorMethods(CodeMirror)

		// Set up methods on CodeMirror's prototype to redirect to the editor's document.
		var dontDelegate = "iter insert remove copy getEditor constructor".split(" ")
		for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
		  { CodeMirror.prototype[prop] = (function(method) {
		    return function() {return method.apply(this.doc, arguments)}
		  })(Doc.prototype[prop]) } }

		eventMixin(Doc)

		// INPUT HANDLING

		CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput}

		// MODE DEFINITION AND QUERYING

		// Extra arguments are stored as the mode's dependencies, which is
		// used by (legacy) mechanisms like loadmode.js to automatically
		// load a mode. (Preferred mechanism is the require/define calls.)
		CodeMirror.defineMode = function(name/*, mode, …*/) {
		  if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name }
		  defineMode.apply(this, arguments)
		}

		CodeMirror.defineMIME = defineMIME

		// Minimal default mode.
		CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); })
		CodeMirror.defineMIME("text/plain", "null")

		// EXTENSIONS

		CodeMirror.defineExtension = function (name, func) {
		  CodeMirror.prototype[name] = func
		}
		CodeMirror.defineDocExtension = function (name, func) {
		  Doc.prototype[name] = func
		}

		CodeMirror.fromTextArea = fromTextArea

		addLegacyProps(CodeMirror)

		CodeMirror.version = "5.23.0"

		return CodeMirror;

		})));

	/***/ },
	/* 5 */
	/***/ function(module, exports) {

		// removed by extract-text-webpack-plugin

	/***/ },
	/* 6 */,
	/* 7 */,
	/* 8 */,
	/* 9 */,
	/* 10 */,
	/* 11 */,
	/* 12 */,
	/* 13 */
	/***/ function(module, exports) {

		// removed by extract-text-webpack-plugin

	/***/ },
	/* 14 */,
	/* 15 */
	/***/ function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_15__;

	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
	  $.extend($.summernote.lang, {
	    'zh-CN': {
	      font: {
	        bold: '粗体',
	        italic: '斜体',
	        underline: '下划线',
	        clear: '清除格式',
	        height: '行高',
	        name: '字体',
	        strikethrough: '删除线',
	        subscript: '下标',
	        superscript: '上标',
	        size: '字号'
	      },
	      image: {
	        image: '图片',
	        insert: '插入图片',
	        resizeFull: '缩放至 100%',
	        resizeHalf: '缩放至 50%',
	        resizeQuarter: '缩放至 25%',
	        floatLeft: '靠左浮动',
	        floatRight: '靠右浮动',
	        floatNone: '取消浮动',
	        shapeRounded: '形状: 圆角',
	        shapeCircle: '形状: 圆',
	        shapeThumbnail: '形状: 缩略图',
	        shapeNone: '形状: 无',
	        dragImageHere: '将图片拖拽至此处',
	        selectFromFiles: '从本地上传',
	        maximumFileSize: '文件大小最大值',
	        maximumFileSizeError: '文件大小超出最大值。',
	        url: '图片地址',
	        remove: '移除图片'
	      },
	      video: {
	        video: '视频',
	        videoLink: '视频链接',
	        insert: '插入视频',
	        url: '视频地址',
	        providers: '(优酷, Instagram, DailyMotion, Youtube等)'
	      },
	      link: {
	        link: '链接',
	        insert: '插入链接',
	        unlink: '去除链接',
	        edit: '编辑链接',
	        textToDisplay: '显示文本',
	        url: '链接地址',
	        openInNewWindow: '在新窗口打开'
	      },
	      table: {
	        table: '表格'
	      },
	      hr: {
	        insert: '水平线'
	      },
	      style: {
	        style: '样式',
	        p: '普通',
	        blockquote: '引用',
	        pre: '代码',
	        h1: '标题 1',
	        h2: '标题 2',
	        h3: '标题 3',
	        h4: '标题 4',
	        h5: '标题 5',
	        h6: '标题 6'
	      },
	      lists: {
	        unordered: '无序列表',
	        ordered: '有序列表'
	      },
	      options: {
	        help: '帮助',
	        fullscreen: '全屏',
	        codeview: '源代码'
	      },
	      paragraph: {
	        paragraph: '段落',
	        outdent: '减少缩进',
	        indent: '增加缩进',
	        left: '左对齐',
	        center: '居中对齐',
	        right: '右对齐',
	        justify: '两端对齐'
	      },
	      color: {
	        recent: '最近使用',
	        more: '更多',
	        background: '背景',
	        foreground: '前景',
	        transparent: '透明',
	        setTransparent: '透明',
	        reset: '重置',
	        resetToDefault: '默认'
	      },
	      shortcut: {
	        shortcuts: '快捷键',
	        close: '关闭',
	        textFormatting: '文本格式',
	        action: '动作',
	        paragraphFormatting: '段落格式',
	        documentStyle: '文档样式',
	        extraKeys: '额外按键'
	      },
	      history: {
	        undo: '撤销',
	        redo: '重做'
	      }
	    }
	  });
	})(jQuery);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.values = exports.untouch = exports.unregisterField = exports.touch = exports.SubmissionError = exports.submit = exports.stopSubmit = exports.stopAsyncValidation = exports.startSubmit = exports.startAsyncValidation = exports.setSubmitSucceeded = exports.setSubmitFailed = exports.reset = exports.registerField = exports.reduxForm = exports.reducer = exports.propTypes = exports.hasSubmitFailed = exports.hasSubmitSucceeded = exports.isSubmitting = exports.isValid = exports.isPristine = exports.isInvalid = exports.isDirty = exports.initialize = exports.getFormSubmitErrors = exports.getFormAsyncErrors = exports.getFormSyncErrors = exports.getFormInitialValues = exports.getFormValues = exports.formValueSelector = exports.focus = exports.FormSection = exports.Form = exports.FieldArray = exports.Fields = exports.Field = exports.destroy = exports.change = exports.blur = exports.autofill = exports.arrayUnshift = exports.arraySwap = exports.arraySplice = exports.arrayShift = exports.arrayRemoveAll = exports.arrayRemove = exports.arrayPush = exports.arrayPop = exports.arrayMove = exports.arrayInsert = exports.actionTypes = undefined;

	var _createAll2 = __webpack_require__(13);

	var _createAll3 = _interopRequireDefault(_createAll2);

	var _plain = __webpack_require__(208);

	var _plain2 = _interopRequireDefault(_plain);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _createAll = (0, _createAll3.default)(_plain2.default);

	var actionTypes = _createAll.actionTypes,
	    arrayInsert = _createAll.arrayInsert,
	    arrayMove = _createAll.arrayMove,
	    arrayPop = _createAll.arrayPop,
	    arrayPush = _createAll.arrayPush,
	    arrayRemove = _createAll.arrayRemove,
	    arrayRemoveAll = _createAll.arrayRemoveAll,
	    arrayShift = _createAll.arrayShift,
	    arraySplice = _createAll.arraySplice,
	    arraySwap = _createAll.arraySwap,
	    arrayUnshift = _createAll.arrayUnshift,
	    autofill = _createAll.autofill,
	    blur = _createAll.blur,
	    change = _createAll.change,
	    destroy = _createAll.destroy,
	    Field = _createAll.Field,
	    Fields = _createAll.Fields,
	    FieldArray = _createAll.FieldArray,
	    Form = _createAll.Form,
	    FormSection = _createAll.FormSection,
	    focus = _createAll.focus,
	    formValueSelector = _createAll.formValueSelector,
	    getFormValues = _createAll.getFormValues,
	    getFormInitialValues = _createAll.getFormInitialValues,
	    getFormSyncErrors = _createAll.getFormSyncErrors,
	    getFormAsyncErrors = _createAll.getFormAsyncErrors,
	    getFormSubmitErrors = _createAll.getFormSubmitErrors,
	    initialize = _createAll.initialize,
	    isDirty = _createAll.isDirty,
	    isInvalid = _createAll.isInvalid,
	    isPristine = _createAll.isPristine,
	    isValid = _createAll.isValid,
	    isSubmitting = _createAll.isSubmitting,
	    hasSubmitSucceeded = _createAll.hasSubmitSucceeded,
	    hasSubmitFailed = _createAll.hasSubmitFailed,
	    propTypes = _createAll.propTypes,
	    reducer = _createAll.reducer,
	    reduxForm = _createAll.reduxForm,
	    registerField = _createAll.registerField,
	    reset = _createAll.reset,
	    setSubmitFailed = _createAll.setSubmitFailed,
	    setSubmitSucceeded = _createAll.setSubmitSucceeded,
	    startAsyncValidation = _createAll.startAsyncValidation,
	    startSubmit = _createAll.startSubmit,
	    stopAsyncValidation = _createAll.stopAsyncValidation,
	    stopSubmit = _createAll.stopSubmit,
	    submit = _createAll.submit,
	    SubmissionError = _createAll.SubmissionError,
	    touch = _createAll.touch,
	    unregisterField = _createAll.unregisterField,
	    untouch = _createAll.untouch,
	    values = _createAll.values;
	exports.actionTypes = actionTypes;
	exports.arrayInsert = arrayInsert;
	exports.arrayMove = arrayMove;
	exports.arrayPop = arrayPop;
	exports.arrayPush = arrayPush;
	exports.arrayRemove = arrayRemove;
	exports.arrayRemoveAll = arrayRemoveAll;
	exports.arrayShift = arrayShift;
	exports.arraySplice = arraySplice;
	exports.arraySwap = arraySwap;
	exports.arrayUnshift = arrayUnshift;
	exports.autofill = autofill;
	exports.blur = blur;
	exports.change = change;
	exports.destroy = destroy;
	exports.Field = Field;
	exports.Fields = Fields;
	exports.FieldArray = FieldArray;
	exports.Form = Form;
	exports.FormSection = FormSection;
	exports.focus = focus;
	exports.formValueSelector = formValueSelector;
	exports.getFormValues = getFormValues;
	exports.getFormInitialValues = getFormInitialValues;
	exports.getFormSyncErrors = getFormSyncErrors;
	exports.getFormAsyncErrors = getFormAsyncErrors;
	exports.getFormSubmitErrors = getFormSubmitErrors;
	exports.initialize = initialize;
	exports.isDirty = isDirty;
	exports.isInvalid = isInvalid;
	exports.isPristine = isPristine;
	exports.isValid = isValid;
	exports.isSubmitting = isSubmitting;
	exports.hasSubmitSucceeded = hasSubmitSucceeded;
	exports.hasSubmitFailed = hasSubmitFailed;
	exports.propTypes = propTypes;
	exports.reducer = reducer;
	exports.reduxForm = reduxForm;
	exports.registerField = registerField;
	exports.reset = reset;
	exports.setSubmitFailed = setSubmitFailed;
	exports.setSubmitSucceeded = setSubmitSucceeded;
	exports.startAsyncValidation = startAsyncValidation;
	exports.startSubmit = startSubmit;
	exports.stopAsyncValidation = stopAsyncValidation;
	exports.stopSubmit = stopSubmit;
	exports.submit = submit;
	exports.SubmissionError = SubmissionError;
	exports.touch = touch;
	exports.unregisterField = unregisterField;
	exports.untouch = untouch;
	exports.values = values;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _reducer = __webpack_require__(14);

	var _reducer2 = _interopRequireDefault(_reducer);

	var _reduxForm = __webpack_require__(67);

	var _reduxForm2 = _interopRequireDefault(_reduxForm);

	var _Field = __webpack_require__(219);

	var _Field2 = _interopRequireDefault(_Field);

	var _Fields = __webpack_require__(228);

	var _Fields2 = _interopRequireDefault(_Fields);

	var _FieldArray = __webpack_require__(230);

	var _FieldArray2 = _interopRequireDefault(_FieldArray);

	var _formValueSelector = __webpack_require__(233);

	var _formValueSelector2 = _interopRequireDefault(_formValueSelector);

	var _values = __webpack_require__(234);

	var _values2 = _interopRequireDefault(_values);

	var _getFormValues = __webpack_require__(235);

	var _getFormValues2 = _interopRequireDefault(_getFormValues);

	var _getFormInitialValues = __webpack_require__(236);

	var _getFormInitialValues2 = _interopRequireDefault(_getFormInitialValues);

	var _getFormSyncErrors = __webpack_require__(237);

	var _getFormSyncErrors2 = _interopRequireDefault(_getFormSyncErrors);

	var _getFormAsyncErrors = __webpack_require__(238);

	var _getFormAsyncErrors2 = _interopRequireDefault(_getFormAsyncErrors);

	var _getFormSubmitErrors = __webpack_require__(239);

	var _getFormSubmitErrors2 = _interopRequireDefault(_getFormSubmitErrors);

	var _isDirty = __webpack_require__(240);

	var _isDirty2 = _interopRequireDefault(_isDirty);

	var _isInvalid = __webpack_require__(242);

	var _isInvalid2 = _interopRequireDefault(_isInvalid);

	var _isPristine = __webpack_require__(241);

	var _isPristine2 = _interopRequireDefault(_isPristine);

	var _isValid = __webpack_require__(217);

	var _isValid2 = _interopRequireDefault(_isValid);

	var _isSubmitting = __webpack_require__(243);

	var _isSubmitting2 = _interopRequireDefault(_isSubmitting);

	var _hasSubmitSucceeded = __webpack_require__(244);

	var _hasSubmitSucceeded2 = _interopRequireDefault(_hasSubmitSucceeded);

	var _hasSubmitFailed = __webpack_require__(245);

	var _hasSubmitFailed2 = _interopRequireDefault(_hasSubmitFailed);

	var _Form = __webpack_require__(246);

	var _Form2 = _interopRequireDefault(_Form);

	var _FormSection = __webpack_require__(247);

	var _FormSection2 = _interopRequireDefault(_FormSection);

	var _SubmissionError = __webpack_require__(200);

	var _SubmissionError2 = _interopRequireDefault(_SubmissionError);

	var _propTypes = __webpack_require__(248);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _actions = __webpack_require__(198);

	var actions = _interopRequireWildcard(_actions);

	var _actionTypes = __webpack_require__(15);

	var actionTypes = _interopRequireWildcard(_actionTypes);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var createAll = function createAll(structure) {
	  return _extends({
	    // separate out field actions
	    actionTypes: actionTypes
	  }, actions, {
	    Field: (0, _Field2.default)(structure),
	    Fields: (0, _Fields2.default)(structure),
	    FieldArray: (0, _FieldArray2.default)(structure),
	    Form: _Form2.default,
	    FormSection: _FormSection2.default,
	    formValueSelector: (0, _formValueSelector2.default)(structure),
	    getFormValues: (0, _getFormValues2.default)(structure),
	    getFormInitialValues: (0, _getFormInitialValues2.default)(structure),
	    getFormSyncErrors: (0, _getFormSyncErrors2.default)(structure),
	    getFormAsyncErrors: (0, _getFormAsyncErrors2.default)(structure),
	    getFormSubmitErrors: (0, _getFormSubmitErrors2.default)(structure),
	    isDirty: (0, _isDirty2.default)(structure),
	    isInvalid: (0, _isInvalid2.default)(structure),
	    isPristine: (0, _isPristine2.default)(structure),
	    isValid: (0, _isValid2.default)(structure),
	    isSubmitting: (0, _isSubmitting2.default)(structure),
	    hasSubmitSucceeded: (0, _hasSubmitSucceeded2.default)(structure),
	    hasSubmitFailed: (0, _hasSubmitFailed2.default)(structure),
	    propTypes: _propTypes2.default,
	    reduxForm: (0, _reduxForm2.default)(structure),
	    reducer: (0, _reducer2.default)(structure),
	    SubmissionError: _SubmissionError2.default,
	    values: (0, _values2.default)(structure)
	  });
	};

	exports.default = createAll;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _actionTypes = __webpack_require__(15);

	var _deleteInWithCleanUp = __webpack_require__(16);

	var _deleteInWithCleanUp2 = _interopRequireDefault(_deleteInWithCleanUp);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var createReducer = function createReducer(structure) {
	  var _behaviors;

	  var deepEqual = structure.deepEqual,
	      empty = structure.empty,
	      getIn = structure.getIn,
	      setIn = structure.setIn,
	      deleteIn = structure.deleteIn,
	      fromJS = structure.fromJS,
	      keys = structure.keys,
	      size = structure.size,
	      splice = structure.splice;

	  var deleteInWithCleanUp = (0, _deleteInWithCleanUp2.default)(structure);
	  var doSplice = function doSplice(state, key, field, index, removeNum, value, force) {
	    var existing = getIn(state, key + '.' + field);
	    return existing || force ? setIn(state, key + '.' + field, splice(existing, index, removeNum, value)) : state;
	  };
	  var rootKeys = ['values', 'fields', 'submitErrors', 'asyncErrors'];
	  var arraySplice = function arraySplice(state, field, index, removeNum, value) {
	    var result = state;
	    var nonValuesValue = value != null ? empty : undefined;
	    result = doSplice(result, 'values', field, index, removeNum, value, true);
	    result = doSplice(result, 'fields', field, index, removeNum, nonValuesValue);
	    result = doSplice(result, 'submitErrors', field, index, removeNum, nonValuesValue);
	    result = doSplice(result, 'asyncErrors', field, index, removeNum, nonValuesValue);
	    return result;
	  };

	  var behaviors = (_behaviors = {}, _defineProperty(_behaviors, _actionTypes.ARRAY_INSERT, function (state, _ref) {
	    var _ref$meta = _ref.meta,
	        field = _ref$meta.field,
	        index = _ref$meta.index,
	        payload = _ref.payload;

	    return arraySplice(state, field, index, 0, payload);
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_MOVE, function (state, _ref2) {
	    var _ref2$meta = _ref2.meta,
	        field = _ref2$meta.field,
	        from = _ref2$meta.from,
	        to = _ref2$meta.to;

	    var array = getIn(state, 'values.' + field);
	    var length = array ? size(array) : 0;
	    var result = state;
	    if (length) {
	      rootKeys.forEach(function (key) {
	        var path = key + '.' + field;
	        if (getIn(result, path)) {
	          var value = getIn(result, path + '[' + from + ']');
	          result = setIn(result, path, splice(getIn(result, path), from, 1)); // remove
	          result = setIn(result, path, splice(getIn(result, path), to, 0, value)); // insert
	        }
	      });
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_POP, function (state, _ref3) {
	    var field = _ref3.meta.field;

	    var array = getIn(state, 'values.' + field);
	    var length = array ? size(array) : 0;
	    return length ? arraySplice(state, field, length - 1, 1) : state;
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_PUSH, function (state, _ref4) {
	    var field = _ref4.meta.field,
	        payload = _ref4.payload;

	    var array = getIn(state, 'values.' + field);
	    var length = array ? size(array) : 0;
	    return arraySplice(state, field, length, 0, payload);
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_REMOVE, function (state, _ref5) {
	    var _ref5$meta = _ref5.meta,
	        field = _ref5$meta.field,
	        index = _ref5$meta.index;

	    return arraySplice(state, field, index, 1);
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_REMOVE_ALL, function (state, _ref6) {
	    var field = _ref6.meta.field;

	    var array = getIn(state, 'values.' + field);
	    var length = array ? size(array) : 0;
	    return length ? arraySplice(state, field, 0, length) : state;
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_SHIFT, function (state, _ref7) {
	    var field = _ref7.meta.field;

	    return arraySplice(state, field, 0, 1);
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_SPLICE, function (state, _ref8) {
	    var _ref8$meta = _ref8.meta,
	        field = _ref8$meta.field,
	        index = _ref8$meta.index,
	        removeNum = _ref8$meta.removeNum,
	        payload = _ref8.payload;

	    return arraySplice(state, field, index, removeNum, payload);
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_SWAP, function (state, _ref9) {
	    var _ref9$meta = _ref9.meta,
	        field = _ref9$meta.field,
	        indexA = _ref9$meta.indexA,
	        indexB = _ref9$meta.indexB;

	    var result = state;
	    rootKeys.forEach(function (key) {
	      var valueA = getIn(result, key + '.' + field + '[' + indexA + ']');
	      var valueB = getIn(result, key + '.' + field + '[' + indexB + ']');
	      if (valueA !== undefined || valueB !== undefined) {
	        result = setIn(result, key + '.' + field + '[' + indexA + ']', valueB);
	        result = setIn(result, key + '.' + field + '[' + indexB + ']', valueA);
	      }
	    });
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.ARRAY_UNSHIFT, function (state, _ref10) {
	    var field = _ref10.meta.field,
	        payload = _ref10.payload;

	    return arraySplice(state, field, 0, 0, payload);
	  }), _defineProperty(_behaviors, _actionTypes.AUTOFILL, function (state, _ref11) {
	    var field = _ref11.meta.field,
	        payload = _ref11.payload;

	    var result = state;
	    result = deleteInWithCleanUp(result, 'asyncErrors.' + field);
	    result = deleteInWithCleanUp(result, 'submitErrors.' + field);
	    result = setIn(result, 'fields.' + field + '.autofilled', true);
	    result = setIn(result, 'values.' + field, payload);
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.BLUR, function (state, _ref12) {
	    var _ref12$meta = _ref12.meta,
	        field = _ref12$meta.field,
	        touch = _ref12$meta.touch,
	        payload = _ref12.payload;

	    var result = state;
	    var initial = getIn(result, 'initial.' + field);
	    if (initial === undefined && payload === '') {
	      result = deleteInWithCleanUp(result, 'values.' + field);
	    } else if (payload !== undefined) {
	      result = setIn(result, 'values.' + field, payload);
	    }
	    if (field === getIn(result, 'active')) {
	      result = deleteIn(result, 'active');
	    }
	    result = deleteIn(result, 'fields.' + field + '.active');
	    if (touch) {
	      result = setIn(result, 'fields.' + field + '.touched', true);
	      result = setIn(result, 'anyTouched', true);
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.CHANGE, function (state, _ref13) {
	    var _ref13$meta = _ref13.meta,
	        field = _ref13$meta.field,
	        touch = _ref13$meta.touch,
	        persistentSubmitErrors = _ref13$meta.persistentSubmitErrors,
	        payload = _ref13.payload;

	    var result = state;
	    var initial = getIn(result, 'initial.' + field);
	    if (initial === undefined && payload === '') {
	      result = deleteInWithCleanUp(result, 'values.' + field);
	    } else if (payload !== undefined) {
	      result = setIn(result, 'values.' + field, payload);
	    }
	    result = deleteInWithCleanUp(result, 'asyncErrors.' + field);
	    if (!persistentSubmitErrors) {
	      result = deleteInWithCleanUp(result, 'submitErrors.' + field);
	    }
	    result = deleteInWithCleanUp(result, 'fields.' + field + '.autofilled');
	    if (touch) {
	      result = setIn(result, 'fields.' + field + '.touched', true);
	      result = setIn(result, 'anyTouched', true);
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.CLEAR_SUBMIT, function (state) {
	    return deleteIn(state, 'triggerSubmit');
	  }), _defineProperty(_behaviors, _actionTypes.CLEAR_ASYNC_ERROR, function (state, _ref14) {
	    var field = _ref14.meta.field;

	    return deleteIn(state, 'asyncErrors.' + field);
	  }), _defineProperty(_behaviors, _actionTypes.FOCUS, function (state, _ref15) {
	    var field = _ref15.meta.field;

	    var result = state;
	    var previouslyActive = getIn(state, 'active');
	    result = deleteIn(result, 'fields.' + previouslyActive + '.active');
	    result = setIn(result, 'fields.' + field + '.visited', true);
	    result = setIn(result, 'fields.' + field + '.active', true);
	    result = setIn(result, 'active', field);
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.INITIALIZE, function (state, _ref16) {
	    var payload = _ref16.payload,
	        _ref16$meta = _ref16.meta,
	        keepDirty = _ref16$meta.keepDirty,
	        keepSubmitSucceeded = _ref16$meta.keepSubmitSucceeded;

	    var mapData = fromJS(payload);
	    var result = empty; // clean all field state

	    // persist old warnings, they will get recalculated if the new form values are different from the old values
	    var warning = getIn(state, 'warning');
	    if (warning) {
	      result = setIn(result, 'warning', warning);
	    }
	    var syncWarnings = getIn(state, 'syncWarnings');
	    if (syncWarnings) {
	      result = setIn(result, 'syncWarnings', syncWarnings);
	    }

	    // persist old errors, they will get recalculated if the new form values are different from the old values
	    var error = getIn(state, 'error');
	    if (error) {
	      result = setIn(result, 'error', error);
	    }
	    var syncErrors = getIn(state, 'syncErrors');
	    if (syncErrors) {
	      result = setIn(result, 'syncErrors', syncErrors);
	    }

	    var registeredFields = getIn(state, 'registeredFields');
	    if (registeredFields) {
	      result = setIn(result, 'registeredFields', registeredFields);
	    }
	    var newValues = mapData;
	    if (keepDirty && registeredFields) {
	      (function () {
	        //
	        // Keep the value of dirty fields while updating the value of
	        // pristine fields. This way, apps can reinitialize forms while
	        // avoiding stomping on user edits.
	        //
	        // Note 1: The initialize action replaces all initial values
	        // regardless of keepDirty.
	        //
	        // Note 2: When a field is dirty, keepDirty is enabled, and the field
	        // value is the same as the new initial value for the field, the
	        // initialize action causes the field to become pristine. That effect
	        // is what we want.
	        //
	        var previousValues = getIn(state, 'values');
	        var previousInitialValues = getIn(state, 'initial');
	        keys(registeredFields).forEach(function (name) {
	          var previousInitialValue = getIn(previousInitialValues, name);
	          var previousValue = getIn(previousValues, name);
	          if (!deepEqual(previousValue, previousInitialValue)) {
	            // This field was dirty. Restore the dirty value.
	            newValues = setIn(newValues, name, previousValue);
	          }
	        });
	      })();
	    }
	    if (keepSubmitSucceeded && getIn(state, 'submitSucceeded')) {
	      result = setIn(result, 'submitSucceeded', true);
	    }
	    result = setIn(result, 'values', newValues);
	    result = setIn(result, 'initial', mapData);
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.REGISTER_FIELD, function (state, _ref17) {
	    var _ref17$payload = _ref17.payload,
	        name = _ref17$payload.name,
	        type = _ref17$payload.type;

	    var key = 'registeredFields[\'' + name + '\']';
	    var field = getIn(state, key);
	    if (field) {
	      var count = getIn(field, 'count') + 1;
	      field = setIn(field, 'count', count);
	    } else {
	      field = fromJS({ name: name, type: type, count: 1 });
	    }
	    return setIn(state, key, field);
	  }), _defineProperty(_behaviors, _actionTypes.RESET, function (state) {
	    var result = empty;
	    var registeredFields = getIn(state, 'registeredFields');
	    if (registeredFields) {
	      result = setIn(result, 'registeredFields', registeredFields);
	    }
	    var values = getIn(state, 'initial');
	    if (values) {
	      result = setIn(result, 'values', values);
	      result = setIn(result, 'initial', values);
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.SUBMIT, function (state) {
	    return setIn(state, 'triggerSubmit', true);
	  }), _defineProperty(_behaviors, _actionTypes.START_ASYNC_VALIDATION, function (state, _ref18) {
	    var field = _ref18.meta.field;

	    return setIn(state, 'asyncValidating', field || true);
	  }), _defineProperty(_behaviors, _actionTypes.START_SUBMIT, function (state) {
	    return setIn(state, 'submitting', true);
	  }), _defineProperty(_behaviors, _actionTypes.STOP_ASYNC_VALIDATION, function (state, _ref19) {
	    var payload = _ref19.payload;

	    var result = state;
	    result = deleteIn(result, 'asyncValidating');
	    if (payload && Object.keys(payload).length) {
	      var _error = payload._error,
	          fieldErrors = _objectWithoutProperties(payload, ['_error']);

	      if (_error) {
	        result = setIn(result, 'error', _error);
	      }
	      if (Object.keys(fieldErrors).length) {
	        result = setIn(result, 'asyncErrors', fromJS(fieldErrors));
	      } else {
	        result = deleteIn(result, 'asyncErrors');
	      }
	    } else {
	      result = deleteIn(result, 'error');
	      result = deleteIn(result, 'asyncErrors');
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.STOP_SUBMIT, function (state, _ref20) {
	    var payload = _ref20.payload;

	    var result = state;
	    result = deleteIn(result, 'submitting');
	    result = deleteIn(result, 'submitFailed');
	    result = deleteIn(result, 'submitSucceeded');
	    if (payload && Object.keys(payload).length) {
	      var _error = payload._error,
	          fieldErrors = _objectWithoutProperties(payload, ['_error']);

	      if (_error) {
	        result = setIn(result, 'error', _error);
	      } else {
	        result = deleteIn(result, 'error');
	      }
	      if (Object.keys(fieldErrors).length) {
	        result = setIn(result, 'submitErrors', fromJS(fieldErrors));
	      } else {
	        result = deleteIn(result, 'submitErrors');
	      }
	      result = setIn(result, 'submitFailed', true);
	    } else {
	      result = setIn(result, 'submitSucceeded', true);
	      result = deleteIn(result, 'error');
	      result = deleteIn(result, 'submitErrors');
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.SET_SUBMIT_FAILED, function (state, _ref21) {
	    var fields = _ref21.meta.fields;

	    var result = state;
	    result = setIn(result, 'submitFailed', true);
	    result = deleteIn(result, 'submitSucceeded');
	    result = deleteIn(result, 'submitting');
	    fields.forEach(function (field) {
	      return result = setIn(result, 'fields.' + field + '.touched', true);
	    });
	    if (fields.length) {
	      result = setIn(result, 'anyTouched', true);
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.SET_SUBMIT_SUCCEEDED, function (state) {
	    var result = state;
	    result = deleteIn(result, 'submitFailed');
	    result = setIn(result, 'submitSucceeded', true);
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.TOUCH, function (state, _ref22) {
	    var fields = _ref22.meta.fields;

	    var result = state;
	    fields.forEach(function (field) {
	      return result = setIn(result, 'fields.' + field + '.touched', true);
	    });
	    result = setIn(result, 'anyTouched', true);
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.UNREGISTER_FIELD, function (state, _ref23) {
	    var _ref23$payload = _ref23.payload,
	        name = _ref23$payload.name,
	        destroyOnUnmount = _ref23$payload.destroyOnUnmount;

	    var result = state;
	    var key = 'registeredFields[\'' + name + '\']';
	    var field = getIn(result, key);
	    if (!field) {
	      return result;
	    }

	    var count = getIn(field, 'count') - 1;
	    if (count <= 0 && destroyOnUnmount) {
	      result = deleteIn(result, key);
	      if (deepEqual(getIn(result, 'registeredFields'), empty)) {
	        result = deleteIn(result, 'registeredFields');
	      }
	    } else {
	      field = setIn(field, 'count', count);
	      result = setIn(result, key, field);
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.UNTOUCH, function (state, _ref24) {
	    var fields = _ref24.meta.fields;

	    var result = state;
	    fields.forEach(function (field) {
	      return result = deleteIn(result, 'fields.' + field + '.touched');
	    });
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.UPDATE_SYNC_ERRORS, function (state, _ref25) {
	    var _ref25$payload = _ref25.payload,
	        syncErrors = _ref25$payload.syncErrors,
	        error = _ref25$payload.error;

	    var result = state;
	    if (error) {
	      result = setIn(result, 'error', error);
	      result = setIn(result, 'syncError', true);
	    } else {
	      result = deleteIn(result, 'error');
	      result = deleteIn(result, 'syncError');
	    }
	    if (Object.keys(syncErrors).length) {
	      result = setIn(result, 'syncErrors', syncErrors);
	    } else {
	      result = deleteIn(result, 'syncErrors');
	    }
	    return result;
	  }), _defineProperty(_behaviors, _actionTypes.UPDATE_SYNC_WARNINGS, function (state, _ref26) {
	    var _ref26$payload = _ref26.payload,
	        syncWarnings = _ref26$payload.syncWarnings,
	        warning = _ref26$payload.warning;

	    var result = state;
	    if (warning) {
	      result = setIn(result, 'warning', warning);
	    } else {
	      result = deleteIn(result, 'warning');
	    }
	    if (Object.keys(syncWarnings).length) {
	      result = setIn(result, 'syncWarnings', syncWarnings);
	    } else {
	      result = deleteIn(result, 'syncWarnings');
	    }
	    return result;
	  }), _behaviors);

	  var reducer = function reducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : empty;
	    var action = arguments[1];

	    var behavior = behaviors[action.type];
	    return behavior ? behavior(state, action) : state;
	  };

	  var byForm = function byForm(reducer) {
	    return function () {
	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : empty;
	      var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      var form = action && action.meta && action.meta.form;
	      if (!form) {
	        return state;
	      }
	      if (action.type === _actionTypes.DESTROY) {
	        return action.meta.form.reduce(function (result, form) {
	          return deleteInWithCleanUp(result, form);
	        }, state);
	      }
	      var formState = getIn(state, form);
	      var result = reducer(formState, action);
	      return result === formState ? state : setIn(state, form, result);
	    };
	  };

	  /**
	   * Adds additional functionality to the reducer
	   */
	  function decorate(target) {
	    target.plugin = function plugin(reducers) {
	      var _this = this;

	      // use 'function' keyword to enable 'this'
	      return decorate(function () {
	        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : empty;
	        var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	        return Object.keys(reducers).reduce(function (accumulator, key) {
	          var previousState = getIn(accumulator, key);
	          var nextState = reducers[key](previousState, action, getIn(state, key));
	          return nextState === previousState ? accumulator : setIn(accumulator, key, nextState);
	        }, _this(state, action));
	      });
	    };

	    return target;
	  }

	  return decorate(byForm(reducer));
	};

	exports.default = createReducer;

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var ARRAY_INSERT = exports.ARRAY_INSERT = '@@redux-form/ARRAY_INSERT';
	var ARRAY_MOVE = exports.ARRAY_MOVE = '@@redux-form/ARRAY_MOVE';
	var ARRAY_POP = exports.ARRAY_POP = '@@redux-form/ARRAY_POP';
	var ARRAY_PUSH = exports.ARRAY_PUSH = '@@redux-form/ARRAY_PUSH';
	var ARRAY_REMOVE = exports.ARRAY_REMOVE = '@@redux-form/ARRAY_REMOVE';
	var ARRAY_REMOVE_ALL = exports.ARRAY_REMOVE_ALL = '@@redux-form/ARRAY_REMOVE_ALL';
	var ARRAY_SHIFT = exports.ARRAY_SHIFT = '@@redux-form/ARRAY_SHIFT';
	var ARRAY_SPLICE = exports.ARRAY_SPLICE = '@@redux-form/ARRAY_SPLICE';
	var ARRAY_UNSHIFT = exports.ARRAY_UNSHIFT = '@@redux-form/ARRAY_UNSHIFT';
	var ARRAY_SWAP = exports.ARRAY_SWAP = '@@redux-form/ARRAY_SWAP';
	var AUTOFILL = exports.AUTOFILL = '@@redux-form/AUTOFILL';
	var BLUR = exports.BLUR = '@@redux-form/BLUR';
	var CHANGE = exports.CHANGE = '@@redux-form/CHANGE';
	var CLEAR_SUBMIT = exports.CLEAR_SUBMIT = '@@redux-form/CLEAR_SUBMIT';
	var CLEAR_ASYNC_ERROR = exports.CLEAR_ASYNC_ERROR = '@redux-form/CLEAR_ASYNC_ERROR';
	var DESTROY = exports.DESTROY = '@@redux-form/DESTROY';
	var FOCUS = exports.FOCUS = '@@redux-form/FOCUS';
	var INITIALIZE = exports.INITIALIZE = '@@redux-form/INITIALIZE';
	var REGISTER_FIELD = exports.REGISTER_FIELD = '@@redux-form/REGISTER_FIELD';
	var RESET = exports.RESET = '@@redux-form/RESET';
	var SET_SUBMIT_FAILED = exports.SET_SUBMIT_FAILED = '@@redux-form/SET_SUBMIT_FAILED';
	var SET_SUBMIT_SUCCEEDED = exports.SET_SUBMIT_SUCCEEDED = '@@redux-form/SET_SUBMIT_SUCCEEDED';
	var START_ASYNC_VALIDATION = exports.START_ASYNC_VALIDATION = '@@redux-form/START_ASYNC_VALIDATION';
	var START_SUBMIT = exports.START_SUBMIT = '@@redux-form/START_SUBMIT';
	var STOP_ASYNC_VALIDATION = exports.STOP_ASYNC_VALIDATION = '@@redux-form/STOP_ASYNC_VALIDATION';
	var STOP_SUBMIT = exports.STOP_SUBMIT = '@@redux-form/STOP_SUBMIT';
	var SUBMIT = exports.SUBMIT = '@@redux-form/SUBMIT';
	var TOUCH = exports.TOUCH = '@@redux-form/TOUCH';
	var UNREGISTER_FIELD = exports.UNREGISTER_FIELD = '@@redux-form/UNREGISTER_FIELD';
	var UNTOUCH = exports.UNTOUCH = '@@redux-form/UNTOUCH';
	var UPDATE_SYNC_ERRORS = exports.UPDATE_SYNC_ERRORS = '@@redux-form/UPDATE_SYNC_ERRORS';
	var UPDATE_SYNC_WARNINGS = exports.UPDATE_SYNC_WARNINGS = '@@redux-form/UPDATE_SYNC_WARNINGS';

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _toPath2 = __webpack_require__(17);

	var _toPath3 = _interopRequireDefault(_toPath2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var createDeleteInWithCleanUp = function createDeleteInWithCleanUp(_ref) {
	  var deepEqual = _ref.deepEqual,
	      empty = _ref.empty,
	      getIn = _ref.getIn,
	      deleteIn = _ref.deleteIn,
	      setIn = _ref.setIn;


	  var deleteInWithCleanUp = function deleteInWithCleanUp(state, path) {
	    if (path[path.length - 1] === ']') {
	      // array path
	      var pathTokens = (0, _toPath3.default)(path);
	      pathTokens.pop();
	      var parent = getIn(state, pathTokens.join('.'));
	      return parent ? setIn(state, path, undefined) : state;
	    }
	    var result = deleteIn(state, path);
	    var dotIndex = path.lastIndexOf('.');
	    if (dotIndex > 0) {
	      var parentPath = path.substring(0, dotIndex);
	      if (parentPath[parentPath.length - 1] !== ']') {
	        var _parent = getIn(result, parentPath);
	        if (deepEqual(_parent, empty)) {
	          return deleteInWithCleanUp(result, parentPath);
	        }
	      }
	    }
	    return result;
	  };

	  return deleteInWithCleanUp;
	};

	exports.default = createDeleteInWithCleanUp;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(18),
	    copyArray = __webpack_require__(19),
	    isArray = __webpack_require__(20),
	    isSymbol = __webpack_require__(21),
	    stringToPath = __webpack_require__(29),
	    toKey = __webpack_require__(64),
	    toString = __webpack_require__(65);

	/**
	 * Converts `value` to a property path array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {*} value The value to convert.
	 * @returns {Array} Returns the new property path array.
	 * @example
	 *
	 * _.toPath('a.b.c');
	 * // => ['a', 'b', 'c']
	 *
	 * _.toPath('a[0].b.c');
	 * // => ['a', '0', 'b', 'c']
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return arrayMap(value, toKey);
	  }
	  return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	}

	module.exports = toPath;


/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	module.exports = copyArray;


/***/ },
/* 20 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(22),
	    isObjectLike = __webpack_require__(28);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(23),
	    getRawTag = __webpack_require__(26),
	    objectToString = __webpack_require__(27);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(24);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(25);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ },
/* 25 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(23);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ },
/* 27 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(30);

	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(31);

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	module.exports = memoizeCapped;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(32);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(33),
	    mapCacheDelete = __webpack_require__(58),
	    mapCacheGet = __webpack_require__(61),
	    mapCacheHas = __webpack_require__(62),
	    mapCacheSet = __webpack_require__(63);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(34),
	    ListCache = __webpack_require__(49),
	    Map = __webpack_require__(57);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(35),
	    hashDelete = __webpack_require__(45),
	    hashGet = __webpack_require__(46),
	    hashHas = __webpack_require__(47),
	    hashSet = __webpack_require__(48);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(36);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(37);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(38),
	    getValue = __webpack_require__(44);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(39),
	    isMasked = __webpack_require__(41),
	    isObject = __webpack_require__(40),
	    toSource = __webpack_require__(43);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(22),
	    isObject = __webpack_require__(40);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ },
/* 40 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(42);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(24);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ },
/* 43 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(36);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(36);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(36);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(50),
	    listCacheDelete = __webpack_require__(51),
	    listCacheGet = __webpack_require__(54),
	    listCacheHas = __webpack_require__(55),
	    listCacheSet = __webpack_require__(56);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ },
/* 50 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(52);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(53);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ },
/* 53 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(52);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(52);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(52);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(37),
	    root = __webpack_require__(24);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(59);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(60);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ },
/* 60 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(59);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(59);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(59);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(21);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toKey;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(66);

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	module.exports = toString;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(23),
	    arrayMap = __webpack_require__(18),
	    isArray = __webpack_require__(20),
	    isSymbol = __webpack_require__(21);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = baseToString;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _merge4 = __webpack_require__(68);

	var _merge5 = _interopRequireDefault(_merge4);

	var _mapValues2 = __webpack_require__(123);

	var _mapValues3 = _interopRequireDefault(_mapValues2);

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _react = __webpack_require__(1);

	var _hoistNonReactStatics = __webpack_require__(168);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	var _reactRedux = __webpack_require__(169);

	var _redux = __webpack_require__(180);

	var _isPromise = __webpack_require__(196);

	var _isPromise2 = _interopRequireDefault(_isPromise);

	var _getDisplayName = __webpack_require__(197);

	var _getDisplayName2 = _interopRequireDefault(_getDisplayName);

	var _actions = __webpack_require__(198);

	var importedActions = _interopRequireWildcard(_actions);

	var _handleSubmit = __webpack_require__(199);

	var _handleSubmit2 = _interopRequireDefault(_handleSubmit);

	var _silenceEvent = __webpack_require__(202);

	var _silenceEvent2 = _interopRequireDefault(_silenceEvent);

	var _silenceEvents = __webpack_require__(204);

	var _silenceEvents2 = _interopRequireDefault(_silenceEvents);

	var _asyncValidation = __webpack_require__(205);

	var _asyncValidation2 = _interopRequireDefault(_asyncValidation);

	var _defaultShouldAsyncValidate = __webpack_require__(206);

	var _defaultShouldAsyncValidate2 = _interopRequireDefault(_defaultShouldAsyncValidate);

	var _defaultShouldValidate = __webpack_require__(207);

	var _defaultShouldValidate2 = _interopRequireDefault(_defaultShouldValidate);

	var _plain = __webpack_require__(208);

	var _plain2 = _interopRequireDefault(_plain);

	var _generateValidator2 = __webpack_require__(216);

	var _generateValidator3 = _interopRequireDefault(_generateValidator2);

	var _isValid = __webpack_require__(217);

	var _isValid2 = _interopRequireDefault(_isValid);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var isClassComponent = function isClassComponent(Component) {
	  return Boolean(Component && Component.prototype && _typeof(Component.prototype.isReactComponent) === 'object');
	};

	// extract field-specific actions

	var arrayInsert = importedActions.arrayInsert,
	    arrayMove = importedActions.arrayMove,
	    arrayPop = importedActions.arrayPop,
	    arrayPush = importedActions.arrayPush,
	    arrayRemove = importedActions.arrayRemove,
	    arrayRemoveAll = importedActions.arrayRemoveAll,
	    arrayShift = importedActions.arrayShift,
	    arraySplice = importedActions.arraySplice,
	    arraySwap = importedActions.arraySwap,
	    arrayUnshift = importedActions.arrayUnshift,
	    blur = importedActions.blur,
	    change = importedActions.change,
	    focus = importedActions.focus,
	    formActions = _objectWithoutProperties(importedActions, ['arrayInsert', 'arrayMove', 'arrayPop', 'arrayPush', 'arrayRemove', 'arrayRemoveAll', 'arrayShift', 'arraySplice', 'arraySwap', 'arrayUnshift', 'blur', 'change', 'focus']);

	var arrayActions = {
	  arrayInsert: arrayInsert,
	  arrayMove: arrayMove,
	  arrayPop: arrayPop,
	  arrayPush: arrayPush,
	  arrayRemove: arrayRemove,
	  arrayRemoveAll: arrayRemoveAll,
	  arrayShift: arrayShift,
	  arraySplice: arraySplice,
	  arraySwap: arraySwap,
	  arrayUnshift: arrayUnshift
	};

	var propsToNotUpdateFor = [].concat(_toConsumableArray(Object.keys(importedActions)), ['array', 'asyncErrors', 'initialized', 'initialValues', 'syncErrors', 'syncWarnings', 'values', 'registeredFields']);

	var checkSubmit = function checkSubmit(submit) {
	  if (!submit || typeof submit !== 'function') {
	    throw new Error('You must either pass handleSubmit() an onSubmit function or pass onSubmit as a prop');
	  }
	  return submit;
	};

	/**
	 * The decorator that is the main API to redux-form
	 */
	var createReduxForm = function createReduxForm(structure) {
	  var deepEqual = structure.deepEqual,
	      empty = structure.empty,
	      getIn = structure.getIn,
	      setIn = structure.setIn,
	      keys = structure.keys,
	      fromJS = structure.fromJS;

	  var isValid = (0, _isValid2.default)(structure);
	  return function (initialConfig) {
	    var config = _extends({
	      touchOnBlur: true,
	      touchOnChange: false,
	      persistentSubmitErrors: false,
	      destroyOnUnmount: true,
	      shouldAsyncValidate: _defaultShouldAsyncValidate2.default,
	      shouldValidate: _defaultShouldValidate2.default,
	      enableReinitialize: false,
	      keepDirtyOnReinitialize: false,
	      getFormState: function getFormState(state) {
	        return getIn(state, 'form');
	      },
	      pure: true,
	      forceUnregisterOnUnmount: false
	    }, initialConfig);

	    return function (WrappedComponent) {
	      var Form = function (_Component) {
	        _inherits(Form, _Component);

	        function Form(props) {
	          _classCallCheck(this, Form);

	          var _this = _possibleConstructorReturn(this, (Form.__proto__ || Object.getPrototypeOf(Form)).call(this, props));

	          _this.submit = _this.submit.bind(_this);
	          _this.reset = _this.reset.bind(_this);
	          _this.asyncValidate = _this.asyncValidate.bind(_this);
	          _this.getValues = _this.getValues.bind(_this);
	          _this.register = _this.register.bind(_this);
	          _this.unregister = _this.unregister.bind(_this);
	          _this.submitCompleted = _this.submitCompleted.bind(_this);
	          _this.submitFailed = _this.submitFailed.bind(_this);
	          _this.fieldValidators = {};
	          _this.lastFieldValidatorKeys = [];
	          _this.fieldWarners = {};
	          _this.lastFieldWarnerKeys = [];
	          return _this;
	        }

	        _createClass(Form, [{
	          key: 'getChildContext',
	          value: function getChildContext() {
	            var _this2 = this;

	            return {
	              _reduxForm: _extends({}, this.props, {
	                getFormState: function getFormState(state) {
	                  return getIn(_this2.props.getFormState(state), _this2.props.form);
	                },
	                asyncValidate: this.asyncValidate,
	                getValues: this.getValues,
	                sectionPrefix: undefined,
	                register: this.register,
	                unregister: this.unregister,
	                registerInnerOnSubmit: function registerInnerOnSubmit(innerOnSubmit) {
	                  return _this2.innerOnSubmit = innerOnSubmit;
	                }
	              })
	            };
	          }
	        }, {
	          key: 'initIfNeeded',
	          value: function initIfNeeded(nextProps) {
	            var enableReinitialize = this.props.enableReinitialize;

	            if (nextProps) {
	              if ((enableReinitialize || !nextProps.initialized) && !deepEqual(this.props.initialValues, nextProps.initialValues)) {
	                var keepDirty = nextProps.initialized && this.props.keepDirtyOnReinitialize;
	                this.props.initialize(nextProps.initialValues, keepDirty);
	              }
	            } else if (this.props.initialValues && (!this.props.initialized || enableReinitialize)) {
	              this.props.initialize(this.props.initialValues, this.props.keepDirtyOnReinitialize);
	            }
	          }
	        }, {
	          key: 'updateSyncErrorsIfNeeded',
	          value: function updateSyncErrorsIfNeeded(nextSyncErrors, nextError) {
	            var _props = this.props,
	                error = _props.error,
	                syncErrors = _props.syncErrors,
	                updateSyncErrors = _props.updateSyncErrors;

	            var noErrors = (!syncErrors || !Object.keys(syncErrors).length) && !error;
	            var nextNoErrors = (!nextSyncErrors || !Object.keys(nextSyncErrors).length) && !nextError;
	            if (!(noErrors && nextNoErrors) && (!_plain2.default.deepEqual(syncErrors, nextSyncErrors) || !_plain2.default.deepEqual(error, nextError))) {
	              updateSyncErrors(nextSyncErrors, nextError);
	            }
	          }
	        }, {
	          key: 'submitIfNeeded',
	          value: function submitIfNeeded(nextProps) {
	            var _props2 = this.props,
	                clearSubmit = _props2.clearSubmit,
	                triggerSubmit = _props2.triggerSubmit;

	            if (!triggerSubmit && nextProps.triggerSubmit) {
	              clearSubmit();
	              this.submit();
	            }
	          }
	        }, {
	          key: 'validateIfNeeded',
	          value: function validateIfNeeded(nextProps) {
	            var _props3 = this.props,
	                shouldValidate = _props3.shouldValidate,
	                validate = _props3.validate,
	                values = _props3.values;

	            var fieldLevelValidate = this.generateValidator();
	            if (validate || fieldLevelValidate) {
	              var initialRender = nextProps === undefined;
	              var fieldValidatorKeys = Object.keys(this.fieldValidators);
	              var shouldValidateResult = shouldValidate({
	                values: values,
	                nextProps: nextProps,
	                props: this.props,
	                initialRender: initialRender,
	                lastFieldValidatorKeys: this.lastFieldValidatorKeys,
	                fieldValidatorKeys: fieldValidatorKeys,
	                structure: structure
	              });

	              if (shouldValidateResult) {
	                var propsToValidate = initialRender ? this.props : nextProps;

	                var _merge2 = (0, _merge5.default)(validate ? validate(propsToValidate.values, propsToValidate) || {} : {}, fieldLevelValidate ? fieldLevelValidate(propsToValidate.values, propsToValidate) || {} : {}),
	                    _error = _merge2._error,
	                    nextSyncErrors = _objectWithoutProperties(_merge2, ['_error']);

	                this.lastFieldValidatorKeys = fieldValidatorKeys;
	                this.updateSyncErrorsIfNeeded(nextSyncErrors, _error);
	              }
	            }
	          }
	        }, {
	          key: 'updateSyncWarningsIfNeeded',
	          value: function updateSyncWarningsIfNeeded(nextSyncWarnings, nextWarning) {
	            var _props4 = this.props,
	                warning = _props4.warning,
	                syncWarnings = _props4.syncWarnings,
	                updateSyncWarnings = _props4.updateSyncWarnings;

	            var noWarnings = (!syncWarnings || !Object.keys(syncWarnings).length) && !warning;
	            var nextNoWarnings = (!nextSyncWarnings || !Object.keys(nextSyncWarnings).length) && !nextWarning;
	            if (!(noWarnings && nextNoWarnings) && (!_plain2.default.deepEqual(syncWarnings, nextSyncWarnings) || !_plain2.default.deepEqual(warning, nextWarning))) {
	              updateSyncWarnings(nextSyncWarnings, nextWarning);
	            }
	          }
	        }, {
	          key: 'warnIfNeeded',
	          value: function warnIfNeeded(nextProps) {
	            var _props5 = this.props,
	                shouldValidate = _props5.shouldValidate,
	                warn = _props5.warn,
	                values = _props5.values;

	            var fieldLevelWarn = this.generateWarner();
	            if (warn || fieldLevelWarn) {
	              var initialRender = nextProps === undefined;
	              var fieldWarnerKeys = Object.keys(this.fieldWarners);
	              var shouldWarnResult = shouldValidate({
	                values: values,
	                nextProps: nextProps,
	                props: this.props,
	                initialRender: initialRender,
	                lastFieldValidatorKeys: this.lastFieldWarnerKeys,
	                fieldValidatorKeys: fieldWarnerKeys,
	                structure: structure
	              });

	              if (shouldWarnResult) {
	                var propsToWarn = initialRender ? this.props : nextProps;

	                var _merge3 = (0, _merge5.default)(warn ? warn(propsToWarn.values, propsToWarn) : {}, fieldLevelWarn ? fieldLevelWarn(propsToWarn.values, propsToWarn) : {}),
	                    _warning = _merge3._warning,
	                    nextSyncWarnings = _objectWithoutProperties(_merge3, ['_warning']);

	                this.lastFieldWarnerKeys = fieldWarnerKeys;
	                this.updateSyncWarningsIfNeeded(nextSyncWarnings, _warning);
	              }
	            }
	          }
	        }, {
	          key: 'componentWillMount',
	          value: function componentWillMount() {
	            this.initIfNeeded();
	            this.validateIfNeeded();
	            this.warnIfNeeded();
	          }
	        }, {
	          key: 'componentWillReceiveProps',
	          value: function componentWillReceiveProps(nextProps) {
	            this.initIfNeeded(nextProps);
	            this.validateIfNeeded(nextProps);
	            this.warnIfNeeded(nextProps);
	            this.submitIfNeeded(nextProps);
	          }
	        }, {
	          key: 'shouldComponentUpdate',
	          value: function shouldComponentUpdate(nextProps) {
	            var _this3 = this;

	            if (!config.pure) return true;
	            return Object.keys(nextProps).some(function (prop) {
	              // useful to debug rerenders
	              // if (!plain.deepEqual(this.props[ prop ], nextProps[ prop ])) {
	              //   console.info(prop, 'changed', this.props[ prop ], '==>', nextProps[ prop ])
	              // }
	              return !~propsToNotUpdateFor.indexOf(prop) && !deepEqual(_this3.props[prop], nextProps[prop]);
	            });
	          }
	        }, {
	          key: 'componentWillUnmount',
	          value: function componentWillUnmount() {
	            var _props6 = this.props,
	                destroyOnUnmount = _props6.destroyOnUnmount,
	                destroy = _props6.destroy;

	            if (destroyOnUnmount) {
	              this.destroyed = true;
	              destroy();
	            }
	          }
	        }, {
	          key: 'getValues',
	          value: function getValues() {
	            return this.props.values;
	          }
	        }, {
	          key: 'isValid',
	          value: function isValid() {
	            return this.props.valid;
	          }
	        }, {
	          key: 'isPristine',
	          value: function isPristine() {
	            return this.props.pristine;
	          }
	        }, {
	          key: 'register',
	          value: function register(name, type, getValidator, getWarner) {
	            this.props.registerField(name, type);
	            if (getValidator) {
	              this.fieldValidators[name] = getValidator;
	            }
	            if (getWarner) {
	              this.fieldWarners[name] = getWarner;
	            }
	          }
	        }, {
	          key: 'unregister',
	          value: function unregister(name) {
	            if (!this.destroyed) {
	              if (this.props.destroyOnUnmount || this.props.forceUnregisterOnUnmount) {
	                this.props.unregisterField(name);
	                delete this.fieldValidators[name];
	                delete this.fieldWarners[name];
	              } else {
	                this.props.unregisterField(name, false);
	              }
	            }
	          }
	        }, {
	          key: 'getFieldList',
	          value: function getFieldList(options) {
	            var registeredFields = this.props.registeredFields;
	            var list = [];
	            if (!registeredFields) {
	              return list;
	            }
	            var keySeq = keys(registeredFields);
	            if (options && options.excludeFieldArray) {
	              keySeq = keySeq.filter(function (name) {
	                return getIn(registeredFields, '[\'' + name + '\'].type') !== 'FieldArray';
	              });
	            }
	            return fromJS(keySeq.reduce(function (acc, key) {
	              acc.push(key);
	              return acc;
	            }, list));
	          }
	        }, {
	          key: 'generateValidator',
	          value: function generateValidator() {
	            var _this4 = this;

	            var validators = {};
	            Object.keys(this.fieldValidators).forEach(function (name) {
	              var validator = _this4.fieldValidators[name]();
	              if (validator) {
	                validators[name] = validator;
	              }
	            });
	            return Object.keys(validators).length ? (0, _generateValidator3.default)(validators, structure) : undefined;
	          }
	        }, {
	          key: 'generateWarner',
	          value: function generateWarner() {
	            var _this5 = this;

	            var warners = {};
	            Object.keys(this.fieldWarners).forEach(function (name) {
	              var warner = _this5.fieldWarners[name]();
	              if (warner) {
	                warners[name] = warner;
	              }
	            });
	            return Object.keys(warners).length ? (0, _generateValidator3.default)(warners, structure) : undefined;
	          }
	        }, {
	          key: 'asyncValidate',
	          value: function asyncValidate(name, value) {
	            var _this6 = this;

	            var _props7 = this.props,
	                asyncBlurFields = _props7.asyncBlurFields,
	                asyncErrors = _props7.asyncErrors,
	                asyncValidate = _props7.asyncValidate,
	                dispatch = _props7.dispatch,
	                initialized = _props7.initialized,
	                pristine = _props7.pristine,
	                shouldAsyncValidate = _props7.shouldAsyncValidate,
	                startAsyncValidation = _props7.startAsyncValidation,
	                stopAsyncValidation = _props7.stopAsyncValidation,
	                syncErrors = _props7.syncErrors,
	                values = _props7.values;

	            var submitting = !name;
	            if (asyncValidate) {
	              var _ret = function () {
	                var valuesToValidate = submitting ? values : setIn(values, name, value);
	                var syncValidationPasses = submitting || !getIn(syncErrors, name);
	                var isBlurredField = !submitting && (!asyncBlurFields || ~asyncBlurFields.indexOf(name.replace(/\[[0-9]+\]/g, '[]')));
	                if ((isBlurredField || submitting) && shouldAsyncValidate({
	                  asyncErrors: asyncErrors,
	                  initialized: initialized,
	                  trigger: submitting ? 'submit' : 'blur',
	                  blurredField: name,
	                  pristine: pristine,
	                  syncValidationPasses: syncValidationPasses
	                })) {
	                  return {
	                    v: (0, _asyncValidation2.default)(function () {
	                      return asyncValidate(valuesToValidate, dispatch, _this6.props, name);
	                    }, startAsyncValidation, stopAsyncValidation, name)
	                  };
	                }
	              }();

	              if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	            }
	          }
	        }, {
	          key: 'submitCompleted',
	          value: function submitCompleted(result) {
	            delete this.submitPromise;
	            return result;
	          }
	        }, {
	          key: 'submitFailed',
	          value: function submitFailed(error) {
	            delete this.submitPromise;
	            throw error;
	          }
	        }, {
	          key: 'listenToSubmit',
	          value: function listenToSubmit(promise) {
	            if (!(0, _isPromise2.default)(promise)) {
	              return promise;
	            }
	            this.submitPromise = promise;
	            return promise.then(this.submitCompleted, this.submitFailed);
	          }
	        }, {
	          key: 'submit',
	          value: function submit(submitOrEvent) {
	            var _this7 = this;

	            var onSubmit = this.props.onSubmit;


	            if (!submitOrEvent || (0, _silenceEvent2.default)(submitOrEvent)) {
	              // submitOrEvent is an event: fire submit if not already submitting
	              if (!this.submitPromise) {
	                if (this.innerOnSubmit) {
	                  // will call "submitOrEvent is the submit function" block below
	                  return this.innerOnSubmit();
	                } else {
	                  return this.listenToSubmit((0, _handleSubmit2.default)(checkSubmit(onSubmit), this.props, this.props.validExceptSubmit, this.asyncValidate, this.getFieldList({ excludeFieldArray: true })));
	                }
	              }
	            } else {
	              // submitOrEvent is the submit function: return deferred submit thunk
	              return (0, _silenceEvents2.default)(function () {
	                return !_this7.submitPromise && _this7.listenToSubmit((0, _handleSubmit2.default)(checkSubmit(submitOrEvent), _this7.props, _this7.props.validExceptSubmit, _this7.asyncValidate, _this7.getFieldList({ excludeFieldArray: true })));
	              });
	            }
	          }
	        }, {
	          key: 'reset',
	          value: function reset() {
	            this.props.reset();
	          }
	        }, {
	          key: 'render',
	          value: function render() {
	            // remove some redux-form config-only props
	            /* eslint-disable no-unused-vars */
	            var _props8 = this.props,
	                anyTouched = _props8.anyTouched,
	                arrayInsert = _props8.arrayInsert,
	                arrayMove = _props8.arrayMove,
	                arrayPop = _props8.arrayPop,
	                arrayPush = _props8.arrayPush,
	                arrayRemove = _props8.arrayRemove,
	                arrayRemoveAll = _props8.arrayRemoveAll,
	                arrayShift = _props8.arrayShift,
	                arraySplice = _props8.arraySplice,
	                arraySwap = _props8.arraySwap,
	                arrayUnshift = _props8.arrayUnshift,
	                asyncErrors = _props8.asyncErrors,
	                asyncValidate = _props8.asyncValidate,
	                asyncValidating = _props8.asyncValidating,
	                blur = _props8.blur,
	                change = _props8.change,
	                destroy = _props8.destroy,
	                destroyOnUnmount = _props8.destroyOnUnmount,
	                forceUnregisterOnUnmount = _props8.forceUnregisterOnUnmount,
	                dirty = _props8.dirty,
	                dispatch = _props8.dispatch,
	                enableReinitialize = _props8.enableReinitialize,
	                error = _props8.error,
	                focus = _props8.focus,
	                form = _props8.form,
	                getFormState = _props8.getFormState,
	                initialize = _props8.initialize,
	                initialized = _props8.initialized,
	                initialValues = _props8.initialValues,
	                invalid = _props8.invalid,
	                keepDirtyOnReinitialize = _props8.keepDirtyOnReinitialize,
	                pristine = _props8.pristine,
	                propNamespace = _props8.propNamespace,
	                registeredFields = _props8.registeredFields,
	                registerField = _props8.registerField,
	                reset = _props8.reset,
	                setSubmitFailed = _props8.setSubmitFailed,
	                setSubmitSucceeded = _props8.setSubmitSucceeded,
	                shouldAsyncValidate = _props8.shouldAsyncValidate,
	                shouldValidate = _props8.shouldValidate,
	                startAsyncValidation = _props8.startAsyncValidation,
	                startSubmit = _props8.startSubmit,
	                stopAsyncValidation = _props8.stopAsyncValidation,
	                stopSubmit = _props8.stopSubmit,
	                submitting = _props8.submitting,
	                submitFailed = _props8.submitFailed,
	                submitSucceeded = _props8.submitSucceeded,
	                touch = _props8.touch,
	                touchOnBlur = _props8.touchOnBlur,
	                touchOnChange = _props8.touchOnChange,
	                persistentSubmitErrors = _props8.persistentSubmitErrors,
	                syncErrors = _props8.syncErrors,
	                syncWarnings = _props8.syncWarnings,
	                unregisterField = _props8.unregisterField,
	                untouch = _props8.untouch,
	                updateSyncErrors = _props8.updateSyncErrors,
	                updateSyncWarnings = _props8.updateSyncWarnings,
	                valid = _props8.valid,
	                validExceptSubmit = _props8.validExceptSubmit,
	                values = _props8.values,
	                warning = _props8.warning,
	                rest = _objectWithoutProperties(_props8, ['anyTouched', 'arrayInsert', 'arrayMove', 'arrayPop', 'arrayPush', 'arrayRemove', 'arrayRemoveAll', 'arrayShift', 'arraySplice', 'arraySwap', 'arrayUnshift', 'asyncErrors', 'asyncValidate', 'asyncValidating', 'blur', 'change', 'destroy', 'destroyOnUnmount', 'forceUnregisterOnUnmount', 'dirty', 'dispatch', 'enableReinitialize', 'error', 'focus', 'form', 'getFormState', 'initialize', 'initialized', 'initialValues', 'invalid', 'keepDirtyOnReinitialize', 'pristine', 'propNamespace', 'registeredFields', 'registerField', 'reset', 'setSubmitFailed', 'setSubmitSucceeded', 'shouldAsyncValidate', 'shouldValidate', 'startAsyncValidation', 'startSubmit', 'stopAsyncValidation', 'stopSubmit', 'submitting', 'submitFailed', 'submitSucceeded', 'touch', 'touchOnBlur', 'touchOnChange', 'persistentSubmitErrors', 'syncErrors', 'syncWarnings', 'unregisterField', 'untouch', 'updateSyncErrors', 'updateSyncWarnings', 'valid', 'validExceptSubmit', 'values', 'warning']);
	            /* eslint-enable no-unused-vars */


	            var reduxFormProps = _extends({
	              anyTouched: anyTouched,
	              asyncValidate: this.asyncValidate,
	              asyncValidating: asyncValidating
	            }, (0, _redux.bindActionCreators)({ blur: blur, change: change }, dispatch), {
	              destroy: destroy,
	              dirty: dirty,
	              dispatch: dispatch,
	              error: error,
	              form: form,
	              handleSubmit: this.submit,
	              initialize: initialize,
	              initialized: initialized,
	              initialValues: initialValues,
	              invalid: invalid,
	              pristine: pristine,
	              reset: reset,
	              submitting: submitting,
	              submitFailed: submitFailed,
	              submitSucceeded: submitSucceeded,
	              touch: touch,
	              untouch: untouch,
	              valid: valid,
	              warning: warning
	            });
	            var propsToPass = _extends({}, propNamespace ? _defineProperty({}, propNamespace, reduxFormProps) : reduxFormProps, rest);
	            if (isClassComponent(WrappedComponent)) {
	              propsToPass.ref = 'wrapped';
	            }
	            return (0, _react.createElement)(WrappedComponent, propsToPass);
	          }
	        }]);

	        return Form;
	      }(_react.Component);

	      Form.displayName = 'Form(' + (0, _getDisplayName2.default)(WrappedComponent) + ')';
	      Form.WrappedComponent = WrappedComponent;
	      Form.childContextTypes = {
	        _reduxForm: _react.PropTypes.object.isRequired
	      };
	      Form.propTypes = {
	        destroyOnUnmount: _react.PropTypes.bool,
	        forceUnregisterOnUnmount: _react.PropTypes.bool,
	        form: _react.PropTypes.string.isRequired,
	        initialValues: _react.PropTypes.object,
	        getFormState: _react.PropTypes.func,
	        onSubmitFail: _react.PropTypes.func,
	        onSubmitSuccess: _react.PropTypes.func,
	        propNameSpace: _react.PropTypes.string,
	        validate: _react.PropTypes.func,
	        warn: _react.PropTypes.func,
	        touchOnBlur: _react.PropTypes.bool,
	        touchOnChange: _react.PropTypes.bool,
	        triggerSubmit: _react.PropTypes.bool,
	        persistentSubmitErrors: _react.PropTypes.bool,
	        registeredFields: _react.PropTypes.any
	      };

	      var connector = (0, _reactRedux.connect)(function (state, props) {
	        var form = props.form,
	            getFormState = props.getFormState,
	            initialValues = props.initialValues,
	            enableReinitialize = props.enableReinitialize,
	            keepDirtyOnReinitialize = props.keepDirtyOnReinitialize;

	        var formState = getIn(getFormState(state) || empty, form) || empty;
	        var stateInitial = getIn(formState, 'initial');
	        var initialized = !!stateInitial;

	        var shouldUpdateInitialValues = enableReinitialize && initialized && !deepEqual(initialValues, stateInitial);
	        var shouldResetValues = shouldUpdateInitialValues && !keepDirtyOnReinitialize;

	        var initial = initialValues || stateInitial || empty;

	        if (shouldUpdateInitialValues) {
	          initial = stateInitial || empty;
	        }

	        var values = getIn(formState, 'values') || initial;

	        if (shouldResetValues) {
	          values = initial;
	        }

	        var pristine = shouldResetValues || deepEqual(initial, values);
	        var asyncErrors = getIn(formState, 'asyncErrors');
	        var syncErrors = getIn(formState, 'syncErrors') || {};
	        var syncWarnings = getIn(formState, 'syncWarnings') || {};
	        var registeredFields = getIn(formState, 'registeredFields');
	        var valid = isValid(form, getFormState, false)(state);
	        var validExceptSubmit = isValid(form, getFormState, true)(state);
	        var anyTouched = !!getIn(formState, 'anyTouched');
	        var submitting = !!getIn(formState, 'submitting');
	        var submitFailed = !!getIn(formState, 'submitFailed');
	        var submitSucceeded = !!getIn(formState, 'submitSucceeded');
	        var error = getIn(formState, 'error');
	        var warning = getIn(formState, 'warning');
	        var triggerSubmit = getIn(formState, 'triggerSubmit');
	        return {
	          anyTouched: anyTouched,
	          asyncErrors: asyncErrors,
	          asyncValidating: getIn(formState, 'asyncValidating') || false,
	          dirty: !pristine,
	          error: error,
	          initialized: initialized,
	          invalid: !valid,
	          pristine: pristine,
	          registeredFields: registeredFields,
	          submitting: submitting,
	          submitFailed: submitFailed,
	          submitSucceeded: submitSucceeded,
	          syncErrors: syncErrors,
	          syncWarnings: syncWarnings,
	          triggerSubmit: triggerSubmit,
	          values: values,
	          valid: valid,
	          validExceptSubmit: validExceptSubmit,
	          warning: warning
	        };
	      }, function (dispatch, initialProps) {
	        var bindForm = function bindForm(actionCreator) {
	          return actionCreator.bind(null, initialProps.form);
	        };

	        // Bind the first parameter on `props.form`
	        var boundFormACs = (0, _mapValues3.default)(formActions, bindForm);
	        var boundArrayACs = (0, _mapValues3.default)(arrayActions, bindForm);
	        var boundBlur = function boundBlur(field, value) {
	          return blur(initialProps.form, field, value, !!initialProps.touchOnBlur);
	        };
	        var boundChange = function boundChange(field, value) {
	          return change(initialProps.form, field, value, !!initialProps.touchOnChange, !!initialProps.persistentSubmitErrors);
	        };
	        var boundFocus = bindForm(focus);

	        // Wrap action creators with `dispatch`
	        var connectedFormACs = (0, _redux.bindActionCreators)(boundFormACs, dispatch);
	        var connectedArrayACs = {
	          insert: (0, _redux.bindActionCreators)(boundArrayACs.arrayInsert, dispatch),
	          move: (0, _redux.bindActionCreators)(boundArrayACs.arrayMove, dispatch),
	          pop: (0, _redux.bindActionCreators)(boundArrayACs.arrayPop, dispatch),
	          push: (0, _redux.bindActionCreators)(boundArrayACs.arrayPush, dispatch),
	          remove: (0, _redux.bindActionCreators)(boundArrayACs.arrayRemove, dispatch),
	          removeAll: (0, _redux.bindActionCreators)(boundArrayACs.arrayRemoveAll, dispatch),
	          shift: (0, _redux.bindActionCreators)(boundArrayACs.arrayShift, dispatch),
	          splice: (0, _redux.bindActionCreators)(boundArrayACs.arraySplice, dispatch),
	          swap: (0, _redux.bindActionCreators)(boundArrayACs.arraySwap, dispatch),
	          unshift: (0, _redux.bindActionCreators)(boundArrayACs.arrayUnshift, dispatch)
	        };

	        var computedActions = _extends({}, connectedFormACs, boundArrayACs, {
	          blur: boundBlur,
	          change: boundChange,
	          array: connectedArrayACs,
	          focus: boundFocus,
	          dispatch: dispatch
	        });

	        return function () {
	          return computedActions;
	        };
	      }, undefined, { withRef: true });
	      var ConnectedForm = (0, _hoistNonReactStatics2.default)(connector(Form), WrappedComponent);
	      ConnectedForm.defaultProps = config;

	      // build outer component to expose instance api
	      return function (_Component2) {
	        _inherits(ReduxForm, _Component2);

	        function ReduxForm() {
	          _classCallCheck(this, ReduxForm);

	          return _possibleConstructorReturn(this, (ReduxForm.__proto__ || Object.getPrototypeOf(ReduxForm)).apply(this, arguments));
	        }

	        _createClass(ReduxForm, [{
	          key: 'submit',
	          value: function submit() {
	            return this.refs.wrapped.getWrappedInstance().submit();
	          }
	        }, {
	          key: 'reset',
	          value: function reset() {
	            return this.refs.wrapped.getWrappedInstance().reset();
	          }
	        }, {
	          key: 'render',
	          value: function render() {
	            var _props9 = this.props,
	                initialValues = _props9.initialValues,
	                rest = _objectWithoutProperties(_props9, ['initialValues']);

	            return (0, _react.createElement)(ConnectedForm, _extends({}, rest, {
	              ref: 'wrapped',
	              // convert initialValues if need to
	              initialValues: fromJS(initialValues)
	            }));
	          }
	        }, {
	          key: 'valid',
	          get: function get() {
	            return this.refs.wrapped.getWrappedInstance().isValid();
	          }
	        }, {
	          key: 'invalid',
	          get: function get() {
	            return !this.valid;
	          }
	        }, {
	          key: 'pristine',
	          get: function get() {
	            return this.refs.wrapped.getWrappedInstance().isPristine();
	          }
	        }, {
	          key: 'dirty',
	          get: function get() {
	            return !this.pristine;
	          }
	        }, {
	          key: 'values',
	          get: function get() {
	            return this.refs.wrapped.getWrappedInstance().getValues();
	          }
	        }, {
	          key: 'fieldList',
	          get: function get() {
	            // mainly provided for testing
	            return this.refs.wrapped.getWrappedInstance().getFieldList();
	          }
	        }, {
	          key: 'wrappedInstance',
	          get: function get() {
	            // for testine
	            return this.refs.wrapped.getWrappedInstance().refs.wrapped;
	          }
	        }]);

	        return ReduxForm;
	      }(_react.Component);
	    };
	  };
	};

	exports.default = createReduxForm;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var baseMerge = __webpack_require__(69),
	    createAssigner = __webpack_require__(113);

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	module.exports = merge;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(70),
	    assignMergeValue = __webpack_require__(76),
	    baseFor = __webpack_require__(79),
	    baseMergeDeep = __webpack_require__(81),
	    isObject = __webpack_require__(40),
	    keysIn = __webpack_require__(107);

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    if (isObject(srcValue)) {
	      stack || (stack = new Stack);
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	module.exports = baseMerge;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(49),
	    stackClear = __webpack_require__(71),
	    stackDelete = __webpack_require__(72),
	    stackGet = __webpack_require__(73),
	    stackHas = __webpack_require__(74),
	    stackSet = __webpack_require__(75);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(49);

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	module.exports = stackClear;


/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	module.exports = stackDelete;


/***/ },
/* 73 */
/***/ function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	module.exports = stackGet;


/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	module.exports = stackHas;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(49),
	    Map = __webpack_require__(57),
	    MapCache = __webpack_require__(32);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	module.exports = stackSet;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(77),
	    eq = __webpack_require__(53);

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignMergeValue;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(78);

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(37);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(80);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ },
/* 80 */
/***/ function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var assignMergeValue = __webpack_require__(76),
	    cloneBuffer = __webpack_require__(82),
	    cloneTypedArray = __webpack_require__(84),
	    copyArray = __webpack_require__(19),
	    initCloneObject = __webpack_require__(87),
	    isArguments = __webpack_require__(92),
	    isArray = __webpack_require__(20),
	    isArrayLikeObject = __webpack_require__(94),
	    isBuffer = __webpack_require__(97),
	    isFunction = __webpack_require__(39),
	    isObject = __webpack_require__(40),
	    isPlainObject = __webpack_require__(99),
	    isTypedArray = __webpack_require__(100),
	    toPlainObject = __webpack_require__(104);

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = object[key],
	      srcValue = source[key],
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	module.exports = baseMergeDeep;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(24);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(83)(module)))

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(85);

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	module.exports = cloneTypedArray;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var Uint8Array = __webpack_require__(86);

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	module.exports = cloneArrayBuffer;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(24);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(88),
	    getPrototype = __webpack_require__(89),
	    isPrototype = __webpack_require__(91);

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	module.exports = initCloneObject;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(40);

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	module.exports = baseCreate;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(90);

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	module.exports = getPrototype;


/***/ },
/* 90 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ },
/* 91 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(93),
	    isObjectLike = __webpack_require__(28);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(22),
	    isObjectLike = __webpack_require__(28);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(95),
	    isObjectLike = __webpack_require__(28);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(39),
	    isLength = __webpack_require__(96);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ },
/* 96 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(24),
	    stubFalse = __webpack_require__(98);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(83)(module)))

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(22),
	    getPrototype = __webpack_require__(89),
	    isObjectLike = __webpack_require__(28);

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	module.exports = isPlainObject;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(101),
	    baseUnary = __webpack_require__(102),
	    nodeUtil = __webpack_require__(103);

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	module.exports = isTypedArray;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(22),
	    isLength = __webpack_require__(96),
	    isObjectLike = __webpack_require__(28);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	module.exports = baseIsTypedArray;


/***/ },
/* 102 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(25);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(83)(module)))

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(105),
	    keysIn = __webpack_require__(107);

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}

	module.exports = toPlainObject;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(106),
	    baseAssignValue = __webpack_require__(77);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(77),
	    eq = __webpack_require__(53);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(108),
	    baseKeysIn = __webpack_require__(111),
	    isArrayLike = __webpack_require__(95);

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	module.exports = keysIn;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(109),
	    isArguments = __webpack_require__(92),
	    isArray = __webpack_require__(20),
	    isBuffer = __webpack_require__(97),
	    isIndex = __webpack_require__(110),
	    isTypedArray = __webpack_require__(100);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ },
/* 110 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(40),
	    isPrototype = __webpack_require__(91),
	    nativeKeysIn = __webpack_require__(112);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeysIn;


/***/ },
/* 112 */
/***/ function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(114),
	    isIterateeCall = __webpack_require__(122);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(115),
	    overRest = __webpack_require__(116),
	    setToString = __webpack_require__(118);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(117);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(119),
	    shortOut = __webpack_require__(121);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(120),
	    defineProperty = __webpack_require__(78),
	    identity = __webpack_require__(115);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ },
/* 120 */
/***/ function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ },
/* 121 */
/***/ function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(53),
	    isArrayLike = __webpack_require__(95),
	    isIndex = __webpack_require__(110),
	    isObject = __webpack_require__(40);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(77),
	    baseForOwn = __webpack_require__(124),
	    baseIteratee = __webpack_require__(128);

	/**
	 * Creates an object with the same keys as `object` and values generated
	 * by running each own enumerable string keyed property of `object` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapKeys
	 * @example
	 *
	 * var users = {
	 *   'fred':    { 'user': 'fred',    'age': 40 },
	 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	 * };
	 *
	 * _.mapValues(users, function(o) { return o.age; });
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.mapValues(users, 'age');
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 */
	function mapValues(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee(iteratee, 3);

	  baseForOwn(object, function(value, key, object) {
	    baseAssignValue(result, key, iteratee(value, key, object));
	  });
	  return result;
	}

	module.exports = mapValues;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(79),
	    keys = __webpack_require__(125);

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	module.exports = baseForOwn;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(108),
	    baseKeys = __webpack_require__(126),
	    isArrayLike = __webpack_require__(95);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = keys;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(91),
	    nativeKeys = __webpack_require__(127);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeys;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(90);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(129),
	    baseMatchesProperty = __webpack_require__(157),
	    identity = __webpack_require__(115),
	    isArray = __webpack_require__(20),
	    property = __webpack_require__(165);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(130),
	    getMatchData = __webpack_require__(154),
	    matchesStrictComparable = __webpack_require__(156);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(70),
	    baseIsEqual = __webpack_require__(131);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(132),
	    isObjectLike = __webpack_require__(28);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	module.exports = baseIsEqual;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(70),
	    equalArrays = __webpack_require__(133),
	    equalByTag = __webpack_require__(139),
	    equalObjects = __webpack_require__(142),
	    getTag = __webpack_require__(149),
	    isArray = __webpack_require__(20),
	    isBuffer = __webpack_require__(97),
	    isTypedArray = __webpack_require__(100);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(134),
	    arraySome = __webpack_require__(137),
	    cacheHas = __webpack_require__(138);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(32),
	    setCacheAdd = __webpack_require__(135),
	    setCacheHas = __webpack_require__(136);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ },
/* 135 */
/***/ function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ },
/* 137 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(23),
	    Uint8Array = __webpack_require__(86),
	    eq = __webpack_require__(53),
	    equalArrays = __webpack_require__(133),
	    mapToArray = __webpack_require__(140),
	    setToArray = __webpack_require__(141);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ },
/* 140 */
/***/ function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	module.exports = mapToArray;


/***/ },
/* 141 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var getAllKeys = __webpack_require__(143);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetAllKeys = __webpack_require__(144),
	    getSymbols = __webpack_require__(146),
	    keys = __webpack_require__(125);

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	module.exports = getAllKeys;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(145),
	    isArray = __webpack_require__(20);

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	module.exports = baseGetAllKeys;


/***/ },
/* 145 */
/***/ function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(147),
	    stubArray = __webpack_require__(148);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	module.exports = getSymbols;


/***/ },
/* 147 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ },
/* 148 */
/***/ function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(150),
	    Map = __webpack_require__(57),
	    Promise = __webpack_require__(151),
	    Set = __webpack_require__(152),
	    WeakMap = __webpack_require__(153),
	    baseGetTag = __webpack_require__(22),
	    toSource = __webpack_require__(43);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	module.exports = getTag;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(37),
	    root = __webpack_require__(24);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	module.exports = DataView;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(37),
	    root = __webpack_require__(24);

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	module.exports = Promise;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(37),
	    root = __webpack_require__(24);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(37),
	    root = __webpack_require__(24);

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	module.exports = WeakMap;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(155),
	    keys = __webpack_require__(125);

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	module.exports = getMatchData;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(40);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	module.exports = isStrictComparable;


/***/ },
/* 156 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	module.exports = matchesStrictComparable;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(131),
	    get = __webpack_require__(158),
	    hasIn = __webpack_require__(162),
	    isKey = __webpack_require__(161),
	    isStrictComparable = __webpack_require__(155),
	    matchesStrictComparable = __webpack_require__(156),
	    toKey = __webpack_require__(64);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(159);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(160),
	    toKey = __webpack_require__(64);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(20),
	    isKey = __webpack_require__(161),
	    stringToPath = __webpack_require__(29),
	    toString = __webpack_require__(65);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	module.exports = castPath;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(20),
	    isSymbol = __webpack_require__(21);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(163),
	    hasPath = __webpack_require__(164);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ },
/* 163 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	module.exports = baseHasIn;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(160),
	    isArguments = __webpack_require__(92),
	    isArray = __webpack_require__(20),
	    isIndex = __webpack_require__(110),
	    isLength = __webpack_require__(96),
	    toKey = __webpack_require__(64);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(166),
	    basePropertyDeep = __webpack_require__(167),
	    isKey = __webpack_require__(161),
	    toKey = __webpack_require__(64);

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = property;


/***/ },
/* 166 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(159);

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	module.exports = basePropertyDeep;


/***/ },
/* 168 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';

	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};

	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};

	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);

	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }

	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {

	                }
	            }
	        }
	    }

	    return targetComponent;
	};


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.connect = exports.connectAdvanced = exports.Provider = undefined;

	var _Provider = __webpack_require__(170);

	var _Provider2 = _interopRequireDefault(_Provider);

	var _connectAdvanced = __webpack_require__(175);

	var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

	var _connect = __webpack_require__(177);

	var _connect2 = _interopRequireDefault(_connect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Provider = _Provider2.default;
	exports.connectAdvanced = _connectAdvanced2.default;
	exports.connect = _connect2.default;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports.__esModule = true;
	exports.default = undefined;

	var _react = __webpack_require__(1);

	var _Subscription = __webpack_require__(172);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _storeShape = __webpack_require__(173);

	var _storeShape2 = _interopRequireDefault(_storeShape);

	var _warning = __webpack_require__(174);

	var _warning2 = _interopRequireDefault(_warning);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;

	  (0, _warning2.default)('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}

	var Provider = function (_Component) {
	  _inherits(Provider, _Component);

	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store, storeSubscription: null };
	  };

	  function Provider(props, context) {
	    _classCallCheck(this, Provider);

	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

	    _this.store = props.store;
	    return _this;
	  }

	  Provider.prototype.render = function render() {
	    return _react.Children.only(this.props.children);
	  };

	  return Provider;
	}(_react.Component);

	exports.default = Provider;


	if (process.env.NODE_ENV !== 'production') {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;


	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}

	Provider.propTypes = {
	  store: _storeShape2.default.isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2.default.isRequired,
	  storeSubscription: _react.PropTypes.instanceOf(_Subscription2.default)
	};
	Provider.displayName = 'Provider';
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(171)))

/***/ },
/* 171 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 172 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// encapsulates the subscription logic for connecting a component to the redux store, as
	// well as nesting subscriptions of descendant components, so that we can ensure the
	// ancestor components re-render before descendants

	var CLEARED = null;
	var nullListeners = {
	  notify: function notify() {}
	};

	function createListenerCollection() {
	  // the current/next pattern is copied from redux's createStore code.
	  // TODO: refactor+expose that code to be reusable here?
	  var current = [];
	  var next = [];

	  return {
	    clear: function clear() {
	      next = CLEARED;
	      current = CLEARED;
	    },
	    notify: function notify() {
	      var listeners = current = next;
	      for (var i = 0; i < listeners.length; i++) {
	        listeners[i]();
	      }
	    },
	    subscribe: function subscribe(listener) {
	      var isSubscribed = true;
	      if (next === current) next = current.slice();
	      next.push(listener);

	      return function unsubscribe() {
	        if (!isSubscribed || current === CLEARED) return;
	        isSubscribed = false;

	        if (next === current) next = current.slice();
	        next.splice(next.indexOf(listener), 1);
	      };
	    }
	  };
	}

	var Subscription = function () {
	  function Subscription(store, parentSub) {
	    _classCallCheck(this, Subscription);

	    this.store = store;
	    this.parentSub = parentSub;
	    this.unsubscribe = null;
	    this.listeners = nullListeners;
	  }

	  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
	    this.trySubscribe();
	    return this.listeners.subscribe(listener);
	  };

	  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
	    this.listeners.notify();
	  };

	  Subscription.prototype.isSubscribed = function isSubscribed() {
	    return Boolean(this.unsubscribe);
	  };

	  Subscription.prototype.trySubscribe = function trySubscribe() {
	    if (!this.unsubscribe) {
	      // this.onStateChange is set by connectAdvanced.initSubscription()
	      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

	      this.listeners = createListenerCollection();
	    }
	  };

	  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
	    if (this.unsubscribe) {
	      this.unsubscribe();
	      this.unsubscribe = null;
	      this.listeners.clear();
	      this.listeners = nullListeners;
	    }
	  };

	  return Subscription;
	}();

	exports.default = Subscription;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(1);

	exports.default = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 174 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.default = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = connectAdvanced;

	var _hoistNonReactStatics = __webpack_require__(168);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	var _invariant = __webpack_require__(176);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _react = __webpack_require__(1);

	var _Subscription = __webpack_require__(172);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _storeShape = __webpack_require__(173);

	var _storeShape2 = _interopRequireDefault(_storeShape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var hotReloadingVersion = 0;
	function connectAdvanced(
	/*
	  selectorFactory is a func that is responsible for returning the selector function used to
	  compute new props from state, props, and dispatch. For example:
	     export default connectAdvanced((dispatch, options) => (state, props) => ({
	      thing: state.things[props.thingId],
	      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
	    }))(YourComponent)
	   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
	  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
	  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
	   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
	  props. Do not use connectAdvanced directly without memoizing results between calls to your
	  selector, otherwise the Connect component will re-render on every state or props change.
	*/
	selectorFactory) {
	  var _contextTypes, _childContextTypes;

	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$getDisplayName = _ref.getDisplayName,
	      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
	    return 'ConnectAdvanced(' + name + ')';
	  } : _ref$getDisplayName,
	      _ref$methodName = _ref.methodName,
	      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
	      _ref$renderCountProp = _ref.renderCountProp,
	      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
	      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
	      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
	      _ref$storeKey = _ref.storeKey,
	      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
	      _ref$withRef = _ref.withRef,
	      withRef = _ref$withRef === undefined ? false : _ref$withRef,
	      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

	  var subscriptionKey = storeKey + 'Subscription';
	  var version = hotReloadingVersion++;

	  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = _storeShape2.default, _contextTypes[subscriptionKey] = _react.PropTypes.instanceOf(_Subscription2.default), _contextTypes);
	  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = _react.PropTypes.instanceOf(_Subscription2.default), _childContextTypes);

	  return function wrapWithConnect(WrappedComponent) {
	    (0, _invariant2.default)(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + ('connect. Instead received ' + WrappedComponent));

	    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

	    var displayName = getDisplayName(wrappedComponentName);

	    var selectorFactoryOptions = _extends({}, connectOptions, {
	      getDisplayName: getDisplayName,
	      methodName: methodName,
	      renderCountProp: renderCountProp,
	      shouldHandleStateChanges: shouldHandleStateChanges,
	      storeKey: storeKey,
	      withRef: withRef,
	      displayName: displayName,
	      wrappedComponentName: wrappedComponentName,
	      WrappedComponent: WrappedComponent
	    });

	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);

	      function Connect(props, context) {
	        _classCallCheck(this, Connect);

	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

	        _this.version = version;
	        _this.state = {};
	        _this.renderCount = 0;
	        _this.store = _this.props[storeKey] || _this.context[storeKey];
	        _this.parentSub = props[subscriptionKey] || context[subscriptionKey];

	        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

	        (0, _invariant2.default)(_this.store, 'Could not find "' + storeKey + '" in either the context or ' + ('props of "' + displayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

	        // make sure `getState` is properly bound in order to avoid breaking
	        // custom store implementations that rely on the store's context
	        _this.getState = _this.store.getState.bind(_this.store);

	        _this.initSelector();
	        _this.initSubscription();
	        return _this;
	      }

	      Connect.prototype.getChildContext = function getChildContext() {
	        var _ref2;

	        return _ref2 = {}, _ref2[subscriptionKey] = this.subscription || this.parentSub, _ref2;
	      };

	      Connect.prototype.componentDidMount = function componentDidMount() {
	        if (!shouldHandleStateChanges) return;

	        // componentWillMount fires during server side rendering, but componentDidMount and
	        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
	        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
	        // To handle the case where a child component may have triggered a state change by
	        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
	        // re-render.
	        this.subscription.trySubscribe();
	        this.selector.run(this.props);
	        if (this.selector.shouldComponentUpdate) this.forceUpdate();
	      };

	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        this.selector.run(nextProps);
	      };

	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return this.selector.shouldComponentUpdate;
	      };

	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        if (this.subscription) this.subscription.tryUnsubscribe();
	        // these are just to guard against extra memory leakage if a parent element doesn't
	        // dereference this instance properly, such as an async callback that never finishes
	        this.subscription = null;
	        this.store = null;
	        this.parentSub = null;
	        this.selector.run = function () {};
	      };

	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2.default)(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
	        return this.wrappedInstance;
	      };

	      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
	        this.wrappedInstance = ref;
	      };

	      Connect.prototype.initSelector = function initSelector() {
	        var dispatch = this.store.dispatch;
	        var getState = this.getState;

	        var sourceSelector = selectorFactory(dispatch, selectorFactoryOptions);

	        // wrap the selector in an object that tracks its results between runs
	        var selector = this.selector = {
	          shouldComponentUpdate: true,
	          props: sourceSelector(getState(), this.props),
	          run: function runComponentSelector(props) {
	            try {
	              var nextProps = sourceSelector(getState(), props);
	              if (selector.error || nextProps !== selector.props) {
	                selector.shouldComponentUpdate = true;
	                selector.props = nextProps;
	                selector.error = null;
	              }
	            } catch (error) {
	              selector.shouldComponentUpdate = true;
	              selector.error = error;
	            }
	          }
	        };
	      };

	      Connect.prototype.initSubscription = function initSubscription() {
	        var _this2 = this;

	        if (shouldHandleStateChanges) {
	          (function () {
	            var subscription = _this2.subscription = new _Subscription2.default(_this2.store, _this2.parentSub);
	            var dummyState = {};

	            subscription.onStateChange = function onStateChange() {
	              this.selector.run(this.props);

	              if (!this.selector.shouldComponentUpdate) {
	                subscription.notifyNestedSubs();
	              } else {
	                this.componentDidUpdate = function componentDidUpdate() {
	                  this.componentDidUpdate = undefined;
	                  subscription.notifyNestedSubs();
	                };

	                this.setState(dummyState);
	              }
	            }.bind(_this2);
	          })();
	        }
	      };

	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return Boolean(this.subscription) && this.subscription.isSubscribed();
	      };

	      Connect.prototype.addExtraProps = function addExtraProps(props) {
	        if (!withRef && !renderCountProp) return props;
	        // make a shallow copy so that fields added don't leak to the original selector.
	        // this is especially important for 'ref' since that's a reference back to the component
	        // instance. a singleton memoized selector would then be holding a reference to the
	        // instance, preventing the instance from being garbage collected, and that would be bad
	        var withExtras = _extends({}, props);
	        if (withRef) withExtras.ref = this.setWrappedInstance;
	        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
	        return withExtras;
	      };

	      Connect.prototype.render = function render() {
	        var selector = this.selector;
	        selector.shouldComponentUpdate = false;

	        if (selector.error) {
	          throw selector.error;
	        } else {
	          return (0, _react.createElement)(WrappedComponent, this.addExtraProps(selector.props));
	        }
	      };

	      return Connect;
	    }(_react.Component);

	    Connect.WrappedComponent = WrappedComponent;
	    Connect.displayName = displayName;
	    Connect.childContextTypes = childContextTypes;
	    Connect.contextTypes = contextTypes;
	    Connect.propTypes = contextTypes;

	    if (process.env.NODE_ENV !== 'production') {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        // We are hot reloading!
	        if (this.version !== version) {
	          this.version = version;
	          this.initSelector();

	          if (this.subscription) this.subscription.tryUnsubscribe();
	          this.initSubscription();
	          if (shouldHandleStateChanges) this.subscription.trySubscribe();
	        }
	      };
	    }

	    return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(171)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(171)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.createConnect = createConnect;

	var _connectAdvanced = __webpack_require__(175);

	var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

	var _shallowEqual = __webpack_require__(178);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	var _mapDispatchToProps = __webpack_require__(179);

	var _mapDispatchToProps2 = _interopRequireDefault(_mapDispatchToProps);

	var _mapStateToProps = __webpack_require__(192);

	var _mapStateToProps2 = _interopRequireDefault(_mapStateToProps);

	var _mergeProps = __webpack_require__(193);

	var _mergeProps2 = _interopRequireDefault(_mergeProps);

	var _selectorFactory = __webpack_require__(194);

	var _selectorFactory2 = _interopRequireDefault(_selectorFactory);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	/*
	  connect is a facade over connectAdvanced. It turns its args into a compatible
	  selectorFactory, which has the signature:

	    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
	  
	  connect passes its args to connectAdvanced as options, which will in turn pass them to
	  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

	  selectorFactory returns a final props selector from its mapStateToProps,
	  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
	  mergePropsFactories, and pure args.

	  The resulting final props selector is called by the Connect component instance whenever
	  it receives new props or store state.
	 */

	function match(arg, factories, name) {
	  for (var i = factories.length - 1; i >= 0; i--) {
	    var result = factories[i](arg);
	    if (result) return result;
	  }

	  return function (dispatch, options) {
	    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
	  };
	}

	function strictEqual(a, b) {
	  return a === b;
	}

	// createConnect with default args builds the 'official' connect behavior. Calling it with
	// different options opens up some testing and extensibility scenarios
	function createConnect() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref$connectHOC = _ref.connectHOC,
	      connectHOC = _ref$connectHOC === undefined ? _connectAdvanced2.default : _ref$connectHOC,
	      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
	      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? _mapStateToProps2.default : _ref$mapStateToPropsF,
	      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
	      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? _mapDispatchToProps2.default : _ref$mapDispatchToPro,
	      _ref$mergePropsFactor = _ref.mergePropsFactories,
	      mergePropsFactories = _ref$mergePropsFactor === undefined ? _mergeProps2.default : _ref$mergePropsFactor,
	      _ref$selectorFactory = _ref.selectorFactory,
	      selectorFactory = _ref$selectorFactory === undefined ? _selectorFactory2.default : _ref$selectorFactory;

	  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
	        _ref2$pure = _ref2.pure,
	        pure = _ref2$pure === undefined ? true : _ref2$pure,
	        _ref2$areStatesEqual = _ref2.areStatesEqual,
	        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
	        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
	        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? _shallowEqual2.default : _ref2$areOwnPropsEqua,
	        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
	        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? _shallowEqual2.default : _ref2$areStatePropsEq,
	        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
	        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? _shallowEqual2.default : _ref2$areMergedPropsE,
	        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

	    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
	    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
	    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

	    return connectHOC(selectorFactory, _extends({
	      // used in error messages
	      methodName: 'connect',

	      // used to compute Connect's displayName from the wrapped component's displayName.
	      getDisplayName: function getDisplayName(name) {
	        return 'Connect(' + name + ')';
	      },

	      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
	      shouldHandleStateChanges: Boolean(mapStateToProps),

	      // passed through to selectorFactory
	      initMapStateToProps: initMapStateToProps,
	      initMapDispatchToProps: initMapDispatchToProps,
	      initMergeProps: initMergeProps,
	      pure: pure,
	      areStatesEqual: areStatesEqual,
	      areOwnPropsEqual: areOwnPropsEqual,
	      areStatePropsEqual: areStatePropsEqual,
	      areMergedPropsEqual: areMergedPropsEqual

	    }, extraOptions));
	  };
	}

	exports.default = createConnect();

/***/ },
/* 178 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.default = shallowEqual;
	var hasOwn = Object.prototype.hasOwnProperty;

	function shallowEqual(a, b) {
	  if (a === b) return true;

	  var countA = 0;
	  var countB = 0;

	  for (var key in a) {
	    if (hasOwn.call(a, key) && a[key] !== b[key]) return false;
	    countA++;
	  }

	  for (var _key in b) {
	    if (hasOwn.call(b, _key)) countB++;
	  }

	  return countA === countB;
	}

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.whenMapDispatchToPropsIsFunction = whenMapDispatchToPropsIsFunction;
	exports.whenMapDispatchToPropsIsMissing = whenMapDispatchToPropsIsMissing;
	exports.whenMapDispatchToPropsIsObject = whenMapDispatchToPropsIsObject;

	var _redux = __webpack_require__(180);

	var _wrapMapToProps = __webpack_require__(190);

	function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
	  return typeof mapDispatchToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapDispatchToProps, 'mapDispatchToProps') : undefined;
	}

	function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
	  return !mapDispatchToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
	    return { dispatch: dispatch };
	  }) : undefined;
	}

	function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
	  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
	    return (0, _redux.bindActionCreators)(mapDispatchToProps, dispatch);
	  }) : undefined;
	}

	exports.default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

	var _createStore = __webpack_require__(181);

	var _createStore2 = _interopRequireDefault(_createStore);

	var _combineReducers = __webpack_require__(185);

	var _combineReducers2 = _interopRequireDefault(_combineReducers);

	var _bindActionCreators = __webpack_require__(187);

	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

	var _applyMiddleware = __webpack_require__(188);

	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

	var _compose = __webpack_require__(189);

	var _compose2 = _interopRequireDefault(_compose);

	var _warning = __webpack_require__(186);

	var _warning2 = _interopRequireDefault(_warning);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}

	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}

	exports.createStore = _createStore2['default'];
	exports.combineReducers = _combineReducers2['default'];
	exports.bindActionCreators = _bindActionCreators2['default'];
	exports.applyMiddleware = _applyMiddleware2['default'];
	exports.compose = _compose2['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(171)))

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports['default'] = createStore;

	var _isPlainObject = __webpack_require__(99);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _symbolObservable = __webpack_require__(182);

	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};

	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [preloadedState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;

	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }

	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }

	    return enhancer(createStore)(reducer, preloadedState);
	  }

	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }

	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;

	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }

	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }

	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }

	    var isSubscribed = true;

	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);

	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }

	      isSubscribed = false;

	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }

	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2['default'])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }

	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }

	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }

	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }

	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }

	    return action;
	  }

	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }

	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }

	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;

	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }

	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }

	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2['default']] = function () {
	      return this;
	    }, _ref;
	  }

	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });

	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
	}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(183);


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _ponyfill = __webpack_require__(184);

	var _ponyfill2 = _interopRequireDefault(_ponyfill);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var root; /* global window */


	if (typeof self !== 'undefined') {
	  root = self;
	} else if (typeof window !== 'undefined') {
	  root = window;
	} else if (typeof global !== 'undefined') {
	  root = global;
	} else if (true) {
	  root = module;
	} else {
	  root = Function('return this')();
	}

	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(83)(module)))

/***/ },
/* 184 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;

		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}

		return result;
	};

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports.__esModule = true;
	exports['default'] = combineReducers;

	var _createStore = __webpack_require__(181);

	var _isPlainObject = __webpack_require__(99);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _warning = __webpack_require__(186);

	var _warning2 = _interopRequireDefault(_warning);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}

	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }

	  if (!(0, _isPlainObject2['default'])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }

	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
	  });

	  unexpectedKeys.forEach(function (key) {
	    unexpectedKeyCache[key] = true;
	  });

	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}

	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }

	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}

	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];

	    if (process.env.NODE_ENV !== 'production') {
	      if (typeof reducers[key] === 'undefined') {
	        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
	      }
	    }

	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);

	  if (process.env.NODE_ENV !== 'production') {
	    var unexpectedKeyCache = {};
	  }

	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }

	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];

	    if (sanityError) {
	      throw sanityError;
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
	      if (warningMessage) {
	        (0, _warning2['default'])(warningMessage);
	      }
	    }

	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(171)))

/***/ },
/* 186 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 187 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}

	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }

	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }

	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = applyMiddleware;

	var _compose = __webpack_require__(189);

	var _compose2 = _interopRequireDefault(_compose);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }

	  return function (createStore) {
	    return function (reducer, preloadedState, enhancer) {
	      var store = createStore(reducer, preloadedState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];

	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);

	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 189 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */

	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }

	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }

	  if (funcs.length === 1) {
	    return funcs[0];
	  }

	  var last = funcs[funcs.length - 1];
	  var rest = funcs.slice(0, -1);
	  return function () {
	    return rest.reduceRight(function (composed, f) {
	      return f(composed);
	    }, last.apply(undefined, arguments));
	  };
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports.__esModule = true;
	exports.wrapMapToPropsConstant = wrapMapToPropsConstant;
	exports.getDependsOnOwnProps = getDependsOnOwnProps;
	exports.wrapMapToPropsFunc = wrapMapToPropsFunc;

	var _verifyPlainObject = __webpack_require__(191);

	var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function wrapMapToPropsConstant(getConstant) {
	  return function initConstantSelector(dispatch, options) {
	    var constant = getConstant(dispatch, options);

	    function constantSelector() {
	      return constant;
	    }
	    constantSelector.dependsOnOwnProps = false;
	    return constantSelector;
	  };
	}

	// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
	// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
	// whether mapToProps needs to be invoked when props have changed.
	// 
	// A length of one signals that mapToProps does not depend on props from the parent component.
	// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
	// therefore not reporting its length accurately..
	function getDependsOnOwnProps(mapToProps) {
	  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
	}

	// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
	// this function wraps mapToProps in a proxy function which does several things:
	// 
	//  * Detects whether the mapToProps function being called depends on props, which
	//    is used by selectorFactory to decide if it should reinvoke on props changes.
	//    
	//  * On first call, handles mapToProps if returns another function, and treats that
	//    new function as the true mapToProps for subsequent calls.
	//    
	//  * On first call, verifies the first result is a plain object, in order to warn
	//    the developer that their mapToProps function is not returning a valid result.
	//    
	function wrapMapToPropsFunc(mapToProps, methodName) {
	  return function initProxySelector(dispatch, _ref) {
	    var displayName = _ref.displayName;

	    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
	      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
	    };

	    proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);

	    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
	      proxy.mapToProps = mapToProps;
	      var props = proxy(stateOrDispatch, ownProps);

	      if (typeof props === 'function') {
	        proxy.mapToProps = props;
	        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
	        props = proxy(stateOrDispatch, ownProps);
	      }

	      if (process.env.NODE_ENV !== 'production') (0, _verifyPlainObject2.default)(props, displayName, methodName);

	      return props;
	    };

	    return proxy;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(171)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.default = verifyPlainObject;

	var _isPlainObject = __webpack_require__(99);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _warning = __webpack_require__(174);

	var _warning2 = _interopRequireDefault(_warning);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function verifyPlainObject(value, displayName, methodName) {
	  if (!(0, _isPlainObject2.default)(value)) {
	    (0, _warning2.default)(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
	  }
	}

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.whenMapStateToPropsIsFunction = whenMapStateToPropsIsFunction;
	exports.whenMapStateToPropsIsMissing = whenMapStateToPropsIsMissing;

	var _wrapMapToProps = __webpack_require__(190);

	function whenMapStateToPropsIsFunction(mapStateToProps) {
	  return typeof mapStateToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapStateToProps, 'mapStateToProps') : undefined;
	}

	function whenMapStateToPropsIsMissing(mapStateToProps) {
	  return !mapStateToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function () {
	    return {};
	  }) : undefined;
	}

	exports.default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.defaultMergeProps = defaultMergeProps;
	exports.wrapMergePropsFunc = wrapMergePropsFunc;
	exports.whenMergePropsIsFunction = whenMergePropsIsFunction;
	exports.whenMergePropsIsOmitted = whenMergePropsIsOmitted;

	var _verifyPlainObject = __webpack_require__(191);

	var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function defaultMergeProps(stateProps, dispatchProps, ownProps) {
	  return _extends({}, ownProps, stateProps, dispatchProps);
	}

	function wrapMergePropsFunc(mergeProps) {
	  return function initMergePropsProxy(dispatch, _ref) {
	    var displayName = _ref.displayName,
	        pure = _ref.pure,
	        areMergedPropsEqual = _ref.areMergedPropsEqual;

	    var hasRunOnce = false;
	    var mergedProps = void 0;

	    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
	      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

	      if (hasRunOnce) {
	        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
	      } else {
	        hasRunOnce = true;
	        mergedProps = nextMergedProps;

	        if (process.env.NODE_ENV !== 'production') (0, _verifyPlainObject2.default)(mergedProps, displayName, 'mergeProps');
	      }

	      return mergedProps;
	    };
	  };
	}

	function whenMergePropsIsFunction(mergeProps) {
	  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
	}

	function whenMergePropsIsOmitted(mergeProps) {
	  return !mergeProps ? function () {
	    return defaultMergeProps;
	  } : undefined;
	}

	exports.default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(171)))

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports.__esModule = true;
	exports.impureFinalPropsSelectorFactory = impureFinalPropsSelectorFactory;
	exports.pureFinalPropsSelectorFactory = pureFinalPropsSelectorFactory;
	exports.default = finalPropsSelectorFactory;

	var _verifySubselectors = __webpack_require__(195);

	var _verifySubselectors2 = _interopRequireDefault(_verifySubselectors);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
	  return function impureFinalPropsSelector(state, ownProps) {
	    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
	  };
	}

	function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
	  var areStatesEqual = _ref.areStatesEqual,
	      areOwnPropsEqual = _ref.areOwnPropsEqual,
	      areStatePropsEqual = _ref.areStatePropsEqual;

	  var hasRunAtLeastOnce = false;
	  var state = void 0;
	  var ownProps = void 0;
	  var stateProps = void 0;
	  var dispatchProps = void 0;
	  var mergedProps = void 0;

	  function handleFirstCall(firstState, firstOwnProps) {
	    state = firstState;
	    ownProps = firstOwnProps;
	    stateProps = mapStateToProps(state, ownProps);
	    dispatchProps = mapDispatchToProps(dispatch, ownProps);
	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    hasRunAtLeastOnce = true;
	    return mergedProps;
	  }

	  function handleNewPropsAndNewState() {
	    stateProps = mapStateToProps(state, ownProps);

	    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    return mergedProps;
	  }

	  function handleNewProps() {
	    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

	    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    return mergedProps;
	  }

	  function handleNewState() {
	    var nextStateProps = mapStateToProps(state, ownProps);
	    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
	    stateProps = nextStateProps;

	    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

	    return mergedProps;
	  }

	  function handleSubsequentCalls(nextState, nextOwnProps) {
	    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
	    var stateChanged = !areStatesEqual(nextState, state);
	    state = nextState;
	    ownProps = nextOwnProps;

	    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
	    if (propsChanged) return handleNewProps();
	    if (stateChanged) return handleNewState();
	    return mergedProps;
	  }

	  return function pureFinalPropsSelector(nextState, nextOwnProps) {
	    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
	  };
	}

	// TODO: Add more comments

	// If pure is true, the selector returned by selectorFactory will memoize its results,
	// allowing connectAdvanced's shouldComponentUpdate to return false if final
	// props have not changed. If false, the selector will always return a new
	// object and shouldComponentUpdate will always return true.

	function finalPropsSelectorFactory(dispatch, _ref2) {
	  var initMapStateToProps = _ref2.initMapStateToProps,
	      initMapDispatchToProps = _ref2.initMapDispatchToProps,
	      initMergeProps = _ref2.initMergeProps,
	      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

	  var mapStateToProps = initMapStateToProps(dispatch, options);
	  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
	  var mergeProps = initMergeProps(dispatch, options);

	  if (process.env.NODE_ENV !== 'production') {
	    (0, _verifySubselectors2.default)(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
	  }

	  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

	  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(171)))

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.default = verifySubselectors;

	var _warning = __webpack_require__(174);

	var _warning2 = _interopRequireDefault(_warning);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function verify(selector, methodName, displayName) {
	  if (!selector) {
	    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
	  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
	    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
	      (0, _warning2.default)('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
	    }
	  }
	}

	function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
	  verify(mapStateToProps, 'mapStateToProps', displayName);
	  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
	  verify(mergeProps, 'mergeProps', displayName);
	}

/***/ },
/* 196 */
/***/ function(module, exports) {

	module.exports = isPromise;

	function isPromise(obj) {
	  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
	}


/***/ },
/* 197 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var getDisplayName = function getDisplayName(Comp) {
	  return Comp.displayName || Comp.name || 'Component';
	};

	exports.default = getDisplayName;

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateSyncWarnings = exports.updateSyncErrors = exports.untouch = exports.unregisterField = exports.touch = exports.setSubmitSucceeded = exports.setSubmitFailed = exports.submit = exports.stopSubmit = exports.stopAsyncValidation = exports.startSubmit = exports.startAsyncValidation = exports.reset = exports.registerField = exports.initialize = exports.focus = exports.destroy = exports.clearAsyncError = exports.clearSubmit = exports.change = exports.blur = exports.autofill = exports.arrayUnshift = exports.arraySwap = exports.arraySplice = exports.arrayShift = exports.arrayRemoveAll = exports.arrayRemove = exports.arrayPush = exports.arrayPop = exports.arrayMove = exports.arrayInsert = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _actionTypes = __webpack_require__(15);

	var arrayInsert = exports.arrayInsert = function arrayInsert(form, field, index, value) {
	  return { type: _actionTypes.ARRAY_INSERT, meta: { form: form, field: field, index: index }, payload: value };
	};

	var arrayMove = exports.arrayMove = function arrayMove(form, field, from, to) {
	  return { type: _actionTypes.ARRAY_MOVE, meta: { form: form, field: field, from: from, to: to } };
	};

	var arrayPop = exports.arrayPop = function arrayPop(form, field) {
	  return { type: _actionTypes.ARRAY_POP, meta: { form: form, field: field } };
	};

	var arrayPush = exports.arrayPush = function arrayPush(form, field, value) {
	  return { type: _actionTypes.ARRAY_PUSH, meta: { form: form, field: field }, payload: value };
	};

	var arrayRemove = exports.arrayRemove = function arrayRemove(form, field, index) {
	  return { type: _actionTypes.ARRAY_REMOVE, meta: { form: form, field: field, index: index } };
	};

	var arrayRemoveAll = exports.arrayRemoveAll = function arrayRemoveAll(form, field) {
	  return { type: _actionTypes.ARRAY_REMOVE_ALL, meta: { form: form, field: field } };
	};

	var arrayShift = exports.arrayShift = function arrayShift(form, field) {
	  return { type: _actionTypes.ARRAY_SHIFT, meta: { form: form, field: field } };
	};

	var arraySplice = exports.arraySplice = function arraySplice(form, field, index, removeNum, value) {
	  var action = {
	    type: _actionTypes.ARRAY_SPLICE,
	    meta: { form: form, field: field, index: index, removeNum: removeNum }
	  };
	  if (value !== undefined) {
	    action.payload = value;
	  }
	  return action;
	};

	var arraySwap = exports.arraySwap = function arraySwap(form, field, indexA, indexB) {
	  if (indexA === indexB) {
	    throw new Error('Swap indices cannot be equal');
	  }
	  if (indexA < 0 || indexB < 0) {
	    throw new Error('Swap indices cannot be negative');
	  }
	  return { type: _actionTypes.ARRAY_SWAP, meta: { form: form, field: field, indexA: indexA, indexB: indexB } };
	};

	var arrayUnshift = exports.arrayUnshift = function arrayUnshift(form, field, value) {
	  return { type: _actionTypes.ARRAY_UNSHIFT, meta: { form: form, field: field }, payload: value };
	};

	var autofill = exports.autofill = function autofill(form, field, value) {
	  return { type: _actionTypes.AUTOFILL, meta: { form: form, field: field }, payload: value };
	};

	var blur = exports.blur = function blur(form, field, value, touch) {
	  return { type: _actionTypes.BLUR, meta: { form: form, field: field, touch: touch }, payload: value };
	};

	var change = exports.change = function change(form, field, value, touch, persistentSubmitErrors) {
	  return { type: _actionTypes.CHANGE, meta: { form: form, field: field, touch: touch, persistentSubmitErrors: persistentSubmitErrors }, payload: value };
	};

	var clearSubmit = exports.clearSubmit = function clearSubmit(form) {
	  return { type: _actionTypes.CLEAR_SUBMIT, meta: { form: form } };
	};

	var clearAsyncError = exports.clearAsyncError = function clearAsyncError(form, field) {
	  return { type: _actionTypes.CLEAR_ASYNC_ERROR, meta: { form: form, field: field } };
	};

	var destroy = exports.destroy = function destroy() {
	  for (var _len = arguments.length, form = Array(_len), _key = 0; _key < _len; _key++) {
	    form[_key] = arguments[_key];
	  }

	  return { type: _actionTypes.DESTROY, meta: { form: form } };
	};

	var focus = exports.focus = function focus(form, field) {
	  return { type: _actionTypes.FOCUS, meta: { form: form, field: field } };
	};

	var initialize = exports.initialize = function initialize(form, values, keepDirty) {
	  var otherMeta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	  if (keepDirty instanceof Object) {
	    otherMeta = keepDirty;
	    keepDirty = false;
	  }
	  return { type: _actionTypes.INITIALIZE, meta: _extends({ form: form, keepDirty: keepDirty }, otherMeta), payload: values };
	};

	var registerField = exports.registerField = function registerField(form, name, type) {
	  return { type: _actionTypes.REGISTER_FIELD, meta: { form: form }, payload: { name: name, type: type } };
	};

	var reset = exports.reset = function reset(form) {
	  return { type: _actionTypes.RESET, meta: { form: form } };
	};

	var startAsyncValidation = exports.startAsyncValidation = function startAsyncValidation(form, field) {
	  return { type: _actionTypes.START_ASYNC_VALIDATION, meta: { form: form, field: field } };
	};

	var startSubmit = exports.startSubmit = function startSubmit(form) {
	  return { type: _actionTypes.START_SUBMIT, meta: { form: form } };
	};

	var stopAsyncValidation = exports.stopAsyncValidation = function stopAsyncValidation(form, errors) {
	  var action = {
	    type: _actionTypes.STOP_ASYNC_VALIDATION,
	    meta: { form: form },
	    payload: errors
	  };
	  if (errors && Object.keys(errors).length) {
	    action.error = true;
	  }
	  return action;
	};

	var stopSubmit = exports.stopSubmit = function stopSubmit(form, errors) {
	  var action = {
	    type: _actionTypes.STOP_SUBMIT,
	    meta: { form: form },
	    payload: errors
	  };
	  if (errors && Object.keys(errors).length) {
	    action.error = true;
	  }
	  return action;
	};

	var submit = exports.submit = function submit(form) {
	  return { type: _actionTypes.SUBMIT, meta: { form: form } };
	};

	var setSubmitFailed = exports.setSubmitFailed = function setSubmitFailed(form) {
	  for (var _len2 = arguments.length, fields = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    fields[_key2 - 1] = arguments[_key2];
	  }

	  return { type: _actionTypes.SET_SUBMIT_FAILED, meta: { form: form, fields: fields }, error: true };
	};

	var setSubmitSucceeded = exports.setSubmitSucceeded = function setSubmitSucceeded(form) {
	  for (var _len3 = arguments.length, fields = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	    fields[_key3 - 1] = arguments[_key3];
	  }

	  return { type: _actionTypes.SET_SUBMIT_SUCCEEDED, meta: { form: form, fields: fields }, error: false };
	};

	var touch = exports.touch = function touch(form) {
	  for (var _len4 = arguments.length, fields = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	    fields[_key4 - 1] = arguments[_key4];
	  }

	  return { type: _actionTypes.TOUCH, meta: { form: form, fields: fields } };
	};

	var unregisterField = exports.unregisterField = function unregisterField(form, name) {
	  var destroyOnUnmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	  return { type: _actionTypes.UNREGISTER_FIELD, meta: { form: form }, payload: { name: name, destroyOnUnmount: destroyOnUnmount } };
	};

	var untouch = exports.untouch = function untouch(form) {
	  for (var _len5 = arguments.length, fields = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
	    fields[_key5 - 1] = arguments[_key5];
	  }

	  return { type: _actionTypes.UNTOUCH, meta: { form: form, fields: fields } };
	};

	var updateSyncErrors = exports.updateSyncErrors = function updateSyncErrors(form) {
	  var syncErrors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var error = arguments[2];
	  return { type: _actionTypes.UPDATE_SYNC_ERRORS, meta: { form: form }, payload: { syncErrors: syncErrors, error: error } };
	};

	var updateSyncWarnings = exports.updateSyncWarnings = function updateSyncWarnings(form) {
	  var syncWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var warning = arguments[2];
	  return { type: _actionTypes.UPDATE_SYNC_WARNINGS, meta: { form: form }, payload: { syncWarnings: syncWarnings, warning: warning } };
	};

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _isPromise = __webpack_require__(196);

	var _isPromise2 = _interopRequireDefault(_isPromise);

	var _SubmissionError = __webpack_require__(200);

	var _SubmissionError2 = _interopRequireDefault(_SubmissionError);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {
	  var dispatch = props.dispatch,
	      onSubmitFail = props.onSubmitFail,
	      onSubmitSuccess = props.onSubmitSuccess,
	      startSubmit = props.startSubmit,
	      stopSubmit = props.stopSubmit,
	      setSubmitFailed = props.setSubmitFailed,
	      setSubmitSucceeded = props.setSubmitSucceeded,
	      syncErrors = props.syncErrors,
	      touch = props.touch,
	      values = props.values,
	      persistentSubmitErrors = props.persistentSubmitErrors;


	  touch.apply(undefined, _toConsumableArray(fields)); // mark all fields as touched

	  if (valid || persistentSubmitErrors) {
	    var _ret = function () {
	      var doSubmit = function doSubmit() {
	        var result = void 0;
	        try {
	          result = submit(values, dispatch, props);
	        } catch (submitError) {
	          var error = submitError instanceof _SubmissionError2.default ? submitError.errors : undefined;
	          stopSubmit(error);
	          setSubmitFailed.apply(undefined, _toConsumableArray(fields));
	          if (onSubmitFail) {
	            onSubmitFail(error, dispatch, submitError, props);
	          }
	          if (error || onSubmitFail) {
	            // if you've provided an onSubmitFail callback, don't re-throw the error
	            return error;
	          } else {
	            throw submitError;
	          }
	        }
	        if ((0, _isPromise2.default)(result)) {
	          startSubmit();
	          return result.then(function (submitResult) {
	            stopSubmit();
	            setSubmitSucceeded();
	            if (onSubmitSuccess) {
	              onSubmitSuccess(submitResult, dispatch, props);
	            }
	            return submitResult;
	          }, function (submitError) {
	            var error = submitError instanceof _SubmissionError2.default ? submitError.errors : undefined;
	            stopSubmit(error);
	            setSubmitFailed.apply(undefined, _toConsumableArray(fields));
	            if (onSubmitFail) {
	              onSubmitFail(error, dispatch, submitError, props);
	            }
	            if (error || onSubmitFail) {
	              // if you've provided an onSubmitFail callback, don't re-throw the error
	              return error;
	            } else {
	              throw submitError;
	            }
	          });
	        } else {
	          setSubmitSucceeded();
	          if (onSubmitSuccess) {
	            onSubmitSuccess(result, dispatch, props);
	          }
	        }
	        return result;
	      };

	      var asyncValidateResult = asyncValidate && asyncValidate();
	      if (asyncValidateResult) {
	        return {
	          v: asyncValidateResult.then(function (asyncErrors) {
	            if (asyncErrors) {
	              throw asyncErrors;
	            }
	            return doSubmit();
	          }).catch(function (asyncErrors) {
	            setSubmitFailed.apply(undefined, _toConsumableArray(fields));
	            if (onSubmitFail) {
	              onSubmitFail(asyncErrors, dispatch, null, props);
	            }
	            return Promise.reject(asyncErrors);
	          })
	        };
	      } else {
	        return {
	          v: doSubmit()
	        };
	      }
	    }();

	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  } else {
	    setSubmitFailed.apply(undefined, _toConsumableArray(fields));
	    if (onSubmitFail) {
	      onSubmitFail(syncErrors, dispatch, null, props);
	    }
	    return syncErrors;
	  }
	};

	exports.default = handleSubmit;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _es6Error = __webpack_require__(201);

	var _es6Error2 = _interopRequireDefault(_es6Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SubmissionError = function (_ExtendableError) {
	  _inherits(SubmissionError, _ExtendableError);

	  function SubmissionError(errors) {
	    _classCallCheck(this, SubmissionError);

	    var _this = _possibleConstructorReturn(this, (SubmissionError.__proto__ || Object.getPrototypeOf(SubmissionError)).call(this, 'Submit Validation Failed'));

	    _this.errors = errors;
	    return _this;
	  }

	  return SubmissionError;
	}(_es6Error2.default);

	exports.default = SubmissionError;

/***/ },
/* 201 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    cls.apply(this, arguments);
	  }

	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });

	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }

	  return ExtendableBuiltin;
	}

	var ExtendableError = function (_extendableBuiltin2) {
	  _inherits(ExtendableError, _extendableBuiltin2);

	  function ExtendableError() {
	    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	    _classCallCheck(this, ExtendableError);

	    // extending Error is weird and does not propagate `message`
	    var _this = _possibleConstructorReturn(this, (ExtendableError.__proto__ || Object.getPrototypeOf(ExtendableError)).call(this, message));

	    Object.defineProperty(_this, 'message', {
	      configurable: true,
	      enumerable: false,
	      value: message,
	      writable: true
	    });

	    Object.defineProperty(_this, 'name', {
	      configurable: true,
	      enumerable: false,
	      value: _this.constructor.name,
	      writable: true
	    });

	    if (Error.hasOwnProperty('captureStackTrace')) {
	      Error.captureStackTrace(_this, _this.constructor);
	      return _possibleConstructorReturn(_this);
	    }

	    Object.defineProperty(_this, 'stack', {
	      configurable: true,
	      enumerable: false,
	      value: new Error(message).stack,
	      writable: true
	    });
	    return _this;
	  }

	  return ExtendableError;
	}(_extendableBuiltin(Error));

	exports.default = ExtendableError;
	module.exports = exports['default'];


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _isEvent = __webpack_require__(203);

	var _isEvent2 = _interopRequireDefault(_isEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var silenceEvent = function silenceEvent(event) {
	  var is = (0, _isEvent2.default)(event);
	  if (is) {
	    event.preventDefault();
	  }
	  return is;
	};

	exports.default = silenceEvent;

/***/ },
/* 203 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var isEvent = function isEvent(candidate) {
	  return !!(candidate && candidate.stopPropagation && candidate.preventDefault);
	};

	exports.default = isEvent;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _silenceEvent = __webpack_require__(202);

	var _silenceEvent2 = _interopRequireDefault(_silenceEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var silenceEvents = function silenceEvents(fn) {
	  return function (event) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    return (0, _silenceEvent2.default)(event) ? fn.apply(undefined, args) : fn.apply(undefined, [event].concat(args));
	  };
	};

	exports.default = silenceEvents;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _isPromise = __webpack_require__(196);

	var _isPromise2 = _interopRequireDefault(_isPromise);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var asyncValidation = function asyncValidation(fn, start, stop, field) {
	  start(field);
	  var promise = fn();
	  if (!(0, _isPromise2.default)(promise)) {
	    throw new Error('asyncValidate function passed to reduxForm must return a promise');
	  }
	  var handleErrors = function handleErrors(rejected) {
	    return function (errors) {
	      if (errors && Object.keys(errors).length) {
	        stop(errors);
	        return errors;
	      } else if (rejected) {
	        stop();
	        throw new Error('Asynchronous validation promise was rejected without errors.');
	      }
	      stop();
	      return Promise.resolve();
	    };
	  };
	  return promise.then(handleErrors(false), handleErrors(true));
	};

	exports.default = asyncValidation;

/***/ },
/* 206 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var defaultShouldAsyncValidate = function defaultShouldAsyncValidate(_ref) {
	  var initialized = _ref.initialized,
	      trigger = _ref.trigger,
	      pristine = _ref.pristine,
	      syncValidationPasses = _ref.syncValidationPasses;

	  if (!syncValidationPasses) {
	    return false;
	  }
	  switch (trigger) {
	    case 'blur':
	      // blurring
	      return true;
	    case 'submit':
	      // submitting, so only async validate if form is dirty or was never initialized
	      // conversely, DON'T async validate if the form is pristine just as it was initialized
	      return !pristine || !initialized;
	    default:
	      return false;
	  }
	};

	exports.default = defaultShouldAsyncValidate;

/***/ },
/* 207 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var defaultShouldValidate = function defaultShouldValidate(_ref) {
	  var values = _ref.values,
	      nextProps = _ref.nextProps,
	      initialRender = _ref.initialRender,
	      lastFieldValidatorKeys = _ref.lastFieldValidatorKeys,
	      fieldValidatorKeys = _ref.fieldValidatorKeys,
	      structure = _ref.structure;

	  if (initialRender) {
	    return true;
	  }
	  return !structure.deepEqual(values, nextProps.values) || !structure.deepEqual(lastFieldValidatorKeys, fieldValidatorKeys);
	};

	exports.default = defaultShouldValidate;

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _splice = __webpack_require__(209);

	var _splice2 = _interopRequireDefault(_splice);

	var _getIn = __webpack_require__(210);

	var _getIn2 = _interopRequireDefault(_getIn);

	var _setIn = __webpack_require__(211);

	var _setIn2 = _interopRequireDefault(_setIn);

	var _deepEqual = __webpack_require__(212);

	var _deepEqual2 = _interopRequireDefault(_deepEqual);

	var _deleteIn = __webpack_require__(214);

	var _deleteIn2 = _interopRequireDefault(_deleteIn);

	var _keys = __webpack_require__(215);

	var _keys2 = _interopRequireDefault(_keys);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var structure = {
	  empty: {},
	  emptyList: [],
	  getIn: _getIn2.default,
	  setIn: _setIn2.default,
	  deepEqual: _deepEqual2.default,
	  deleteIn: _deleteIn2.default,
	  fromJS: function fromJS(value) {
	    return value;
	  },
	  keys: _keys2.default,
	  size: function size(array) {
	    return array ? array.length : 0;
	  },
	  splice: _splice2.default,
	  toJS: function toJS(value) {
	    return value;
	  }
	};

	exports.default = structure;

/***/ },
/* 209 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var splice = function splice(array, index, removeNum, value) {
	  array = array || [];

	  if (index < array.length) {
	    if (value === undefined && !removeNum) {
	      // inserting undefined
	      var _copy2 = [].concat(_toConsumableArray(array));
	      _copy2.splice(index, 0, null);
	      _copy2[index] = undefined;
	      return _copy2;
	    }
	    if (value != null) {
	      var _copy3 = [].concat(_toConsumableArray(array));
	      _copy3.splice(index, removeNum, value); // removing and adding
	      return _copy3;
	    }
	    var _copy = [].concat(_toConsumableArray(array));
	    _copy.splice(index, removeNum); // removing
	    return _copy;
	  }
	  if (removeNum) {
	    // trying to remove non-existant item: return original array
	    return array;
	  }
	  // trying to add outside of range: just set value
	  var copy = [].concat(_toConsumableArray(array));
	  copy[index] = value;
	  return copy;
	};

	exports.default = splice;

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _toPath2 = __webpack_require__(17);

	var _toPath3 = _interopRequireDefault(_toPath2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var getIn = function getIn(state, field) {
	  if (!state) {
	    return state;
	  }

	  var path = (0, _toPath3.default)(field);
	  var length = path.length;
	  if (!length) {
	    return undefined;
	  }

	  var result = state;
	  for (var i = 0; i < length && !!result; ++i) {
	    result = result[path[i]];
	  }

	  return result;
	};

	exports.default = getIn;

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _toPath2 = __webpack_require__(17);

	var _toPath3 = _interopRequireDefault(_toPath2);

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var setInWithPath = function setInWithPath(state, value, path, pathIndex) {
	  if (pathIndex >= path.length) {
	    return value;
	  }

	  var first = path[pathIndex];
	  var next = setInWithPath(state && state[first], value, path, pathIndex + 1);

	  if (!state) {
	    var initialized = isNaN(first) ? {} : [];
	    initialized[first] = next;
	    return initialized;
	  }

	  if (Array.isArray(state)) {
	    var copy = [].concat(state);
	    copy[first] = next;
	    return copy;
	  }

	  return _extends({}, state, _defineProperty({}, first, next));
	};

	var setIn = function setIn(state, field, value) {
	  return setInWithPath(state, value, (0, _toPath3.default)(field), 0);
	};

	exports.default = setIn;

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _isEqualWith2 = __webpack_require__(213);

	var _isEqualWith3 = _interopRequireDefault(_isEqualWith2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var customizer = function customizer(obj, other) {
	  if (obj === other) return true;
	  if ((obj == null || obj === '' || obj === false) && (other == null || other === '' || other === false)) return true;

	  if (obj && other && obj._error !== other._error) return false;
	  if (obj && other && obj._warning !== other._warning) return false;
	};

	var deepEqual = function deepEqual(a, b) {
	  return (0, _isEqualWith3.default)(a, b, customizer);
	};

	exports.default = deepEqual;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(131);

	/**
	 * This method is like `_.isEqual` except that it accepts `customizer` which
	 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	 * are handled by the method instead. The `customizer` is invoked with up to
	 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * function isGreeting(value) {
	 *   return /^h(?:i|ello)$/.test(value);
	 * }
	 *
	 * function customizer(objValue, othValue) {
	 *   if (isGreeting(objValue) && isGreeting(othValue)) {
	 *     return true;
	 *   }
	 * }
	 *
	 * var array = ['hello', 'goodbye'];
	 * var other = ['hi', 'goodbye'];
	 *
	 * _.isEqualWith(array, other, customizer);
	 * // => true
	 */
	function isEqualWith(value, other, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  var result = customizer ? customizer(value, other) : undefined;
	  return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	}

	module.exports = isEqualWith;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _toPath2 = __webpack_require__(17);

	var _toPath3 = _interopRequireDefault(_toPath2);

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var deleteInWithPath = function deleteInWithPath(state, first) {
	  for (var _len = arguments.length, rest = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    rest[_key - 2] = arguments[_key];
	  }

	  if (state === undefined || first === undefined) {
	    return state;
	  }
	  if (rest.length) {
	    if (Array.isArray(state)) {
	      if (first < state.length) {
	        var result = deleteInWithPath.apply(undefined, [state && state[first]].concat(rest));
	        if (result !== state[first]) {
	          var copy = [].concat(_toConsumableArray(state));
	          copy[first] = result;
	          return copy;
	        }
	      }
	      return state;
	    }
	    if (first in state) {
	      var _result = deleteInWithPath.apply(undefined, [state && state[first]].concat(rest));
	      return state[first] === _result ? state : _extends({}, state, _defineProperty({}, first, _result));
	    }
	    return state;
	  }
	  if (Array.isArray(state)) {
	    if (isNaN(first)) {
	      throw new Error('Cannot delete non-numerical index from an array');
	    }
	    if (first < state.length) {
	      var _copy = [].concat(_toConsumableArray(state));
	      _copy.splice(first, 1);
	      return _copy;
	    }
	    return state;
	  }
	  if (first in state) {
	    var _copy2 = _extends({}, state);
	    delete _copy2[first];
	    return _copy2;
	  }
	  return state;
	};

	var deleteIn = function deleteIn(state, field) {
	  return deleteInWithPath.apply(undefined, [state].concat(_toConsumableArray((0, _toPath3.default)(field))));
	};

	exports.default = deleteIn;

/***/ },
/* 215 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var keys = function keys(value) {
	  return value ? Object.keys(value) : [];
	};

	exports.default = keys;

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _plain = __webpack_require__(208);

	var _plain2 = _interopRequireDefault(_plain);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var toArray = function toArray(value) {
	  return Array.isArray(value) ? value : [value];
	};

	var getError = function getError(value, values, props, validators) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = toArray(validators)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var validator = _step.value;

	      var error = validator(value, values, props);
	      if (error) {
	        return error;
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	};

	var generateValidator = function generateValidator(validators, _ref) {
	  var getIn = _ref.getIn;
	  return function (values, props) {
	    var errors = {};
	    Object.keys(validators).forEach(function (name) {
	      var value = getIn(values, name);
	      var error = getError(value, values, props, validators[name]);
	      if (error) {
	        errors = _plain2.default.setIn(errors, name, error);
	      }
	    });
	    return errors;
	  };
	};

	exports.default = generateValidator;

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _hasError = __webpack_require__(218);

	var _hasError2 = _interopRequireDefault(_hasError);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var createIsValid = function createIsValid(structure) {
	  var getIn = structure.getIn,
	      keys = structure.keys;

	  var hasError = (0, _hasError2.default)(structure);
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    var ignoreSubmitErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    return function (state) {
	      var formState = getFormState(state);
	      var syncError = getIn(formState, form + '.syncError');
	      if (syncError) {
	        return false;
	      }
	      if (!ignoreSubmitErrors) {
	        var error = getIn(formState, form + '.error');
	        if (error) {
	          return false;
	        }
	      }
	      var syncErrors = getIn(formState, form + '.syncErrors');
	      var asyncErrors = getIn(formState, form + '.asyncErrors');
	      var submitErrors = ignoreSubmitErrors ? undefined : getIn(formState, form + '.submitErrors');
	      if (!syncErrors && !asyncErrors && !submitErrors) {
	        return true;
	      }

	      var registeredFields = getIn(formState, form + '.registeredFields');
	      if (!registeredFields) {
	        return true;
	      }

	      return !keys(registeredFields).filter(function (name) {
	        return getIn(registeredFields, '[\'' + name + '\'].count') > 0;
	      }).some(function (name) {
	        return hasError(getIn(registeredFields, '[\'' + name + '\']'), syncErrors, asyncErrors, submitErrors);
	      });
	    };
	  };
	};

	exports.default = createIsValid;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _getIn = __webpack_require__(210);

	var _getIn2 = _interopRequireDefault(_getIn);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var getErrorKeys = function getErrorKeys(name, type) {
	  switch (type) {
	    case 'Field':
	      return [name, name + '._error'];
	    case 'FieldArray':
	      return [name + '._error'];
	  }
	};

	var createHasError = function createHasError(_ref) {
	  var getIn = _ref.getIn;

	  var hasError = function hasError(field, syncErrors, asyncErrors, submitErrors) {
	    if (!syncErrors && !asyncErrors && !submitErrors) {
	      return false;
	    }

	    var name = getIn(field, 'name');
	    var type = getIn(field, 'type');
	    return getErrorKeys(name, type).some(function (key) {
	      return (0, _getIn2.default)(syncErrors, key) || getIn(asyncErrors, key) || getIn(submitErrors, key);
	    });
	  };
	  return hasError;
	};

	exports.default = createHasError;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _invariant = __webpack_require__(176);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _ConnectedField = __webpack_require__(220);

	var _ConnectedField2 = _interopRequireDefault(_ConnectedField);

	var _shallowCompare = __webpack_require__(226);

	var _shallowCompare2 = _interopRequireDefault(_shallowCompare);

	var _prefixName = __webpack_require__(227);

	var _prefixName2 = _interopRequireDefault(_prefixName);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var createField = function createField(_ref) {
	  var deepEqual = _ref.deepEqual,
	      getIn = _ref.getIn,
	      setIn = _ref.setIn,
	      toJS = _ref.toJS;


	  var ConnectedField = (0, _ConnectedField2.default)({
	    deepEqual: deepEqual,
	    getIn: getIn,
	    toJS: toJS
	  });

	  var Field = function (_Component) {
	    _inherits(Field, _Component);

	    function Field(props, context) {
	      _classCallCheck(this, Field);

	      var _this = _possibleConstructorReturn(this, (Field.__proto__ || Object.getPrototypeOf(Field)).call(this, props, context));

	      if (!context._reduxForm) {
	        throw new Error('Field must be inside a component decorated with reduxForm()');
	      }

	      _this.normalize = _this.normalize.bind(_this);
	      return _this;
	    }

	    _createClass(Field, [{
	      key: 'shouldComponentUpdate',
	      value: function shouldComponentUpdate(nextProps, nextState) {
	        return (0, _shallowCompare2.default)(this, nextProps, nextState);
	      }
	    }, {
	      key: 'componentWillMount',
	      value: function componentWillMount() {
	        var _this2 = this;

	        this.context._reduxForm.register(this.name, 'Field', function () {
	          return _this2.props.validate;
	        }, function () {
	          return _this2.props.warn;
	        });
	      }
	    }, {
	      key: 'componentWillReceiveProps',
	      value: function componentWillReceiveProps(nextProps) {
	        if (this.props.name !== nextProps.name) {
	          // unregister old name
	          this.context._reduxForm.unregister(this.name);
	          // register new name
	          this.context._reduxForm.register((0, _prefixName2.default)(this.context, nextProps.name), 'Field');
	        }
	      }
	    }, {
	      key: 'componentWillUnmount',
	      value: function componentWillUnmount() {
	        this.context._reduxForm.unregister(this.name);
	      }
	    }, {
	      key: 'getRenderedComponent',
	      value: function getRenderedComponent() {
	        (0, _invariant2.default)(this.props.withRef, 'If you want to access getRenderedComponent(), ' + 'you must specify a withRef prop to Field');
	        return this.refs.connected.getWrappedInstance().getRenderedComponent();
	      }
	    }, {
	      key: 'normalize',
	      value: function normalize(name, value) {
	        var normalize = this.props.normalize;

	        if (!normalize) {
	          return value;
	        }
	        var previousValues = this.context._reduxForm.getValues();
	        var previousValue = this.value;
	        var nextValues = setIn(previousValues, name, value);
	        return normalize(value, previousValue, nextValues, previousValues);
	      }
	    }, {
	      key: 'render',
	      value: function render() {
	        return (0, _react.createElement)(ConnectedField, _extends({}, this.props, {
	          name: this.name,
	          normalize: this.normalize,
	          _reduxForm: this.context._reduxForm,
	          ref: 'connected'
	        }));
	      }
	    }, {
	      key: 'name',
	      get: function get() {
	        return (0, _prefixName2.default)(this.context, this.props.name);
	      }
	    }, {
	      key: 'dirty',
	      get: function get() {
	        return !this.pristine;
	      }
	    }, {
	      key: 'pristine',
	      get: function get() {
	        return this.refs.connected.getWrappedInstance().isPristine();
	      }
	    }, {
	      key: 'value',
	      get: function get() {
	        return this.refs.connected && this.refs.connected.getWrappedInstance().getValue();
	      }
	    }]);

	    return Field;
	  }(_react.Component);

	  Field.propTypes = {
	    name: _react.PropTypes.string.isRequired,
	    component: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]).isRequired,
	    format: _react.PropTypes.func,
	    normalize: _react.PropTypes.func,
	    onBlur: _react.PropTypes.func,
	    onChange: _react.PropTypes.func,
	    onFocus: _react.PropTypes.func,
	    onDragStart: _react.PropTypes.func,
	    onDrop: _react.PropTypes.func,
	    parse: _react.PropTypes.func,
	    props: _react.PropTypes.object
	  };
	  Field.contextTypes = {
	    _reduxForm: _react.PropTypes.object
	  };

	  return Field;
	};

	exports.default = createField;

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _reactRedux = __webpack_require__(169);

	var _createFieldProps2 = __webpack_require__(221);

	var _createFieldProps3 = _interopRequireDefault(_createFieldProps2);

	var _plain = __webpack_require__(208);

	var _plain2 = _interopRequireDefault(_plain);

	var _onChangeValue = __webpack_require__(222);

	var _onChangeValue2 = _interopRequireDefault(_onChangeValue);

	var _eventConsts = __webpack_require__(225);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var propsToNotUpdateFor = ['_reduxForm'];

	var createConnectedField = function createConnectedField(_ref) {
	  var deepEqual = _ref.deepEqual,
	      getIn = _ref.getIn,
	      toJS = _ref.toJS;


	  var getSyncError = function getSyncError(syncErrors, name) {
	    var error = _plain2.default.getIn(syncErrors, name);
	    // Because the error for this field might not be at a level in the error structure where
	    // it can be set directly, it might need to be unwrapped from the _error property
	    return error && error._error ? error._error : error;
	  };

	  var getSyncWarning = function getSyncWarning(syncWarnings, name) {
	    var warning = _plain2.default.getIn(syncWarnings, name);
	    // Because the warning for this field might not be at a level in the warning structure where
	    // it can be set directly, it might need to be unwrapped from the _warning property
	    return warning && warning._warning ? warning._warning : warning;
	  };

	  var ConnectedField = function (_Component) {
	    _inherits(ConnectedField, _Component);

	    function ConnectedField(props) {
	      _classCallCheck(this, ConnectedField);

	      var _this = _possibleConstructorReturn(this, (ConnectedField.__proto__ || Object.getPrototypeOf(ConnectedField)).call(this, props));

	      _this.handleChange = _this.handleChange.bind(_this);
	      _this.handleFocus = _this.handleFocus.bind(_this);
	      _this.handleBlur = _this.handleBlur.bind(_this);
	      _this.handleDragStart = _this.handleDragStart.bind(_this);
	      _this.handleDrop = _this.handleDrop.bind(_this);
	      return _this;
	    }

	    _createClass(ConnectedField, [{
	      key: 'shouldComponentUpdate',
	      value: function shouldComponentUpdate(nextProps) {
	        var _this2 = this;

	        var nextPropsKeys = Object.keys(nextProps);
	        var thisPropsKeys = Object.keys(this.props);
	        return nextPropsKeys.length !== thisPropsKeys.length || nextPropsKeys.some(function (prop) {
	          return !~propsToNotUpdateFor.indexOf(prop) && !deepEqual(_this2.props[prop], nextProps[prop]);
	        });
	      }
	    }, {
	      key: 'isPristine',
	      value: function isPristine() {
	        return this.props.pristine;
	      }
	    }, {
	      key: 'getValue',
	      value: function getValue() {
	        return this.props.value;
	      }
	    }, {
	      key: 'getRenderedComponent',
	      value: function getRenderedComponent() {
	        return this.refs.renderedComponent;
	      }
	    }, {
	      key: 'handleChange',
	      value: function handleChange(event) {
	        var _props = this.props,
	            name = _props.name,
	            dispatch = _props.dispatch,
	            parse = _props.parse,
	            normalize = _props.normalize,
	            onChange = _props.onChange,
	            _reduxForm = _props._reduxForm,
	            previousValue = _props.value;

	        var newValue = (0, _onChangeValue2.default)(event, { name: name, parse: parse, normalize: normalize });

	        var defaultPrevented = false;
	        if (onChange) {
	          onChange(_extends({}, event, {
	            preventDefault: function preventDefault() {
	              defaultPrevented = true;
	              return event.preventDefault();
	            }
	          }), newValue, previousValue);
	        }
	        if (!defaultPrevented) {
	          // dispatch change action
	          dispatch(_reduxForm.change(name, newValue));
	        }
	      }
	    }, {
	      key: 'handleFocus',
	      value: function handleFocus(event) {
	        var _props2 = this.props,
	            name = _props2.name,
	            dispatch = _props2.dispatch,
	            onFocus = _props2.onFocus,
	            _reduxForm = _props2._reduxForm;


	        var defaultPrevented = false;
	        if (onFocus) {
	          onFocus(_extends({}, event, {
	            preventDefault: function preventDefault() {
	              defaultPrevented = true;
	              return event.preventDefault();
	            }
	          }));
	        }

	        if (!defaultPrevented) {
	          dispatch(_reduxForm.focus(name));
	        }
	      }
	    }, {
	      key: 'handleBlur',
	      value: function handleBlur(event) {
	        var _props3 = this.props,
	            name = _props3.name,
	            dispatch = _props3.dispatch,
	            parse = _props3.parse,
	            normalize = _props3.normalize,
	            onBlur = _props3.onBlur,
	            _reduxForm = _props3._reduxForm,
	            _value = _props3._value,
	            previousValue = _props3.value;

	        var newValue = (0, _onChangeValue2.default)(event, { name: name, parse: parse, normalize: normalize });

	        // for checkbox and radio, if the value property of checkbox or radio equals
	        // the value passed by blur event, then fire blur action with previousValue.
	        if (newValue === _value && _value !== undefined) {
	          newValue = previousValue;
	        }

	        var defaultPrevented = false;
	        if (onBlur) {
	          onBlur(_extends({}, event, {
	            preventDefault: function preventDefault() {
	              defaultPrevented = true;
	              return event.preventDefault();
	            }
	          }), newValue, previousValue);
	        }

	        if (!defaultPrevented) {
	          // dispatch blur action
	          dispatch(_reduxForm.blur(name, newValue));

	          // call post-blur callback
	          if (_reduxForm.asyncValidate) {
	            _reduxForm.asyncValidate(name, newValue);
	          }
	        }
	      }
	    }, {
	      key: 'handleDragStart',
	      value: function handleDragStart(event) {
	        var _props4 = this.props,
	            onDragStart = _props4.onDragStart,
	            value = _props4.value;

	        event.dataTransfer.setData(_eventConsts.dataKey, value == null ? '' : value);

	        if (onDragStart) {
	          onDragStart(event);
	        }
	      }
	    }, {
	      key: 'handleDrop',
	      value: function handleDrop(event) {
	        var _props5 = this.props,
	            name = _props5.name,
	            dispatch = _props5.dispatch,
	            onDrop = _props5.onDrop,
	            _reduxForm = _props5._reduxForm,
	            previousValue = _props5.value;

	        var newValue = event.dataTransfer.getData(_eventConsts.dataKey);

	        var defaultPrevented = false;
	        if (onDrop) {
	          onDrop(_extends({}, event, {
	            preventDefault: function preventDefault() {
	              defaultPrevented = true;
	              return event.preventDefault();
	            }
	          }), newValue, previousValue);
	        }

	        if (!defaultPrevented) {
	          // dispatch change action
	          dispatch(_reduxForm.change(name, newValue));
	          event.preventDefault();
	        }
	      }
	    }, {
	      key: 'render',
	      value: function render() {
	        var _props6 = this.props,
	            component = _props6.component,
	            withRef = _props6.withRef,
	            name = _props6.name,
	            _reduxForm = _props6._reduxForm,
	            normalize = _props6.normalize,
	            onBlur = _props6.onBlur,
	            onChange = _props6.onChange,
	            onFocus = _props6.onFocus,
	            onDragStart = _props6.onDragStart,
	            onDrop = _props6.onDrop,
	            rest = _objectWithoutProperties(_props6, ['component', 'withRef', 'name', '_reduxForm', 'normalize', 'onBlur', 'onChange', 'onFocus', 'onDragStart', 'onDrop']);

	        var _createFieldProps = (0, _createFieldProps3.default)({ getIn: getIn, toJS: toJS }, name, _extends({}, rest, {
	          form: _reduxForm.form,
	          onBlur: this.handleBlur,
	          onChange: this.handleChange,
	          onDrop: this.handleDrop,
	          onDragStart: this.handleDragStart,
	          onFocus: this.handleFocus
	        })),
	            custom = _createFieldProps.custom,
	            props = _objectWithoutProperties(_createFieldProps, ['custom']);

	        if (withRef) {
	          custom.ref = 'renderedComponent';
	        }
	        if (typeof component === 'string') {
	          var input = props.input,
	              meta = props.meta; // eslint-disable-line no-unused-vars
	          // flatten input into other props

	          return (0, _react.createElement)(component, _extends({}, input, custom));
	        } else {
	          return (0, _react.createElement)(component, _extends({}, props, custom));
	        }
	      }
	    }]);

	    return ConnectedField;
	  }(_react.Component);

	  ConnectedField.propTypes = {
	    component: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]).isRequired,
	    props: _react.PropTypes.object
	  };

	  var connector = (0, _reactRedux.connect)(function (state, ownProps) {
	    var name = ownProps.name,
	        _ownProps$_reduxForm = ownProps._reduxForm,
	        initialValues = _ownProps$_reduxForm.initialValues,
	        getFormState = _ownProps$_reduxForm.getFormState;

	    var formState = getFormState(state);
	    var initialState = getIn(formState, 'initial.' + name);
	    var initial = initialState !== undefined ? initialState : initialValues && getIn(initialValues, name);
	    var value = getIn(formState, 'values.' + name);
	    var submitting = getIn(formState, 'submitting');
	    var syncError = getSyncError(getIn(formState, 'syncErrors'), name);
	    var syncWarning = getSyncWarning(getIn(formState, 'syncWarnings'), name);
	    var pristine = value === initial;
	    return {
	      asyncError: getIn(formState, 'asyncErrors.' + name),
	      asyncValidating: getIn(formState, 'asyncValidating') === name,
	      dirty: !pristine,
	      pristine: pristine,
	      state: getIn(formState, 'fields.' + name),
	      submitError: getIn(formState, 'submitErrors.' + name),
	      submitFailed: getIn(formState, 'submitFailed'),
	      submitting: submitting,
	      syncError: syncError,
	      syncWarning: syncWarning,
	      value: value,
	      _value: ownProps.value // save value passed in (for checkboxes)
	    };
	  }, undefined, undefined, { withRef: true });
	  return connector(ConnectedField);
	};

	exports.default = createConnectedField;

/***/ },
/* 221 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var processProps = function processProps(type, props, _value) {
	  var value = props.value;

	  if (type === 'checkbox') {
	    return _extends({}, props, {
	      checked: !!value
	    });
	  }
	  if (type === 'radio') {
	    return _extends({}, props, {
	      checked: value === _value,
	      value: _value
	    });
	  }
	  if (type === 'select-multiple') {
	    return _extends({}, props, {
	      value: value || []
	    });
	  }
	  if (type === 'file') {
	    return _extends({}, props, {
	      value: value || undefined
	    });
	  }
	  return props;
	};

	var createFieldProps = function createFieldProps(_ref2, name, _ref) {
	  var getIn = _ref2.getIn,
	      toJS = _ref2.toJS;

	  var asyncError = _ref.asyncError,
	      asyncValidating = _ref.asyncValidating,
	      onBlur = _ref.onBlur,
	      onChange = _ref.onChange,
	      onDrop = _ref.onDrop,
	      onDragStart = _ref.onDragStart,
	      dirty = _ref.dirty,
	      dispatch = _ref.dispatch,
	      onFocus = _ref.onFocus,
	      form = _ref.form,
	      format = _ref.format,
	      parse = _ref.parse,
	      pristine = _ref.pristine,
	      props = _ref.props,
	      state = _ref.state,
	      submitError = _ref.submitError,
	      submitFailed = _ref.submitFailed,
	      submitting = _ref.submitting,
	      syncError = _ref.syncError,
	      syncWarning = _ref.syncWarning,
	      validate = _ref.validate,
	      value = _ref.value,
	      _value = _ref._value,
	      warn = _ref.warn,
	      custom = _objectWithoutProperties(_ref, ['asyncError', 'asyncValidating', 'onBlur', 'onChange', 'onDrop', 'onDragStart', 'dirty', 'dispatch', 'onFocus', 'form', 'format', 'parse', 'pristine', 'props', 'state', 'submitError', 'submitFailed', 'submitting', 'syncError', 'syncWarning', 'validate', 'value', '_value', 'warn']);

	  var error = syncError || asyncError || submitError;
	  var warning = syncWarning;

	  var formatFieldValue = function formatFieldValue(value, format) {
	    if (format === null) {
	      return value;
	    }
	    var defaultFormattedValue = value == null ? '' : value;
	    return format ? format(value, name) : defaultFormattedValue;
	  };

	  var formattedFieldValue = formatFieldValue(value, format);

	  return {
	    input: processProps(custom.type, {
	      name: name,
	      onBlur: onBlur,
	      onChange: onChange,
	      onDragStart: onDragStart,
	      onDrop: onDrop,
	      onFocus: onFocus,
	      value: formattedFieldValue
	    }, _value),
	    meta: _extends({}, toJS(state), {
	      active: !!(state && getIn(state, 'active')),
	      asyncValidating: asyncValidating,
	      autofilled: !!(state && getIn(state, 'autofilled')),
	      dirty: dirty,
	      dispatch: dispatch,
	      error: error,
	      form: form,
	      warning: warning,
	      invalid: !!error,
	      pristine: pristine,
	      submitting: !!submitting,
	      submitFailed: !!submitFailed,
	      touched: !!(state && getIn(state, 'touched')),
	      valid: !error,
	      visited: !!(state && getIn(state, 'visited'))
	    }),
	    custom: _extends({}, custom, props)
	  };
	};

	exports.default = createFieldProps;

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _getValue = __webpack_require__(223);

	var _getValue2 = _interopRequireDefault(_getValue);

	var _isReactNative = __webpack_require__(224);

	var _isReactNative2 = _interopRequireDefault(_isReactNative);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var onChangeValue = function onChangeValue(event, _ref) {
	  var name = _ref.name,
	      parse = _ref.parse,
	      normalize = _ref.normalize;

	  // read value from input
	  var value = (0, _getValue2.default)(event, _isReactNative2.default);

	  // parse value if we have a parser
	  if (parse) {
	    value = parse(value, name);
	  }

	  // normalize value
	  if (normalize) {
	    value = normalize(name, value);
	  }

	  return value;
	};

	exports.default = onChangeValue;

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _isEvent = __webpack_require__(203);

	var _isEvent2 = _interopRequireDefault(_isEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var getSelectedValues = function getSelectedValues(options) {
	  var result = [];
	  if (options) {
	    for (var index = 0; index < options.length; index++) {
	      var option = options[index];
	      if (option.selected) {
	        result.push(option.value);
	      }
	    }
	  }
	  return result;
	};

	var getValue = function getValue(event, isReactNative) {
	  if ((0, _isEvent2.default)(event)) {
	    if (!isReactNative && event.nativeEvent && event.nativeEvent.text !== undefined) {
	      return event.nativeEvent.text;
	    }
	    if (isReactNative && event.nativeEvent !== undefined) {
	      return event.nativeEvent.text;
	    }
	    var _event$target = event.target,
	        type = _event$target.type,
	        value = _event$target.value,
	        checked = _event$target.checked,
	        files = _event$target.files,
	        dataTransfer = event.dataTransfer;

	    if (type === 'checkbox') {
	      return checked;
	    }
	    if (type === 'file') {
	      return files || dataTransfer && dataTransfer.files;
	    }
	    if (type === 'select-multiple') {
	      return getSelectedValues(event.target.options);
	    }
	    return value;
	  }
	  return event;
	};

	exports.default = getValue;

/***/ },
/* 224 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var isReactNative = typeof window !== 'undefined' && window.navigator && window.navigator.product && window.navigator.product === 'ReactNative';

	exports.default = isReactNative;

/***/ },
/* 225 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var dataKey = exports.dataKey = 'text';

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _isEqualWith2 = __webpack_require__(213);

	var _isEqualWith3 = _interopRequireDefault(_isEqualWith2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var customizer = function customizer(objectValue, otherValue, indexOrkey, object, other, stack) {
	  // https://lodash.com/docs/4.17.4#isEqualWith
	  if (stack) {
	    // Shallow compares
	    // For 1st level, stack === undefined.
	    //   -> Do nothing (and implicitly return undefined so that it goes to compare 2nd level)
	    // For 2nd level and up, stack !== undefined.
	    //   -> Compare by === operator
	    return objectValue === otherValue;
	  }
	};

	var shallowCompare = function shallowCompare(instance, nextProps, nextState) {
	  return !(0, _isEqualWith3.default)(instance.props, nextProps, customizer) || !(0, _isEqualWith3.default)(instance.state, nextState, customizer);
	};

	exports.default = shallowCompare;

/***/ },
/* 227 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = formatName;
	function formatName(context, name) {
	  var sectionPrefix = context._reduxForm.sectionPrefix;

	  return !sectionPrefix ? name : sectionPrefix + "." + name;
	}

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _invariant = __webpack_require__(176);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _ConnectedFields = __webpack_require__(229);

	var _ConnectedFields2 = _interopRequireDefault(_ConnectedFields);

	var _shallowCompare = __webpack_require__(226);

	var _shallowCompare2 = _interopRequireDefault(_shallowCompare);

	var _plain = __webpack_require__(208);

	var _plain2 = _interopRequireDefault(_plain);

	var _prefixName = __webpack_require__(227);

	var _prefixName2 = _interopRequireDefault(_prefixName);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var validateNameProp = function validateNameProp(prop) {
	  if (!prop) {
	    return new Error('No "names" prop was specified <Fields/>');
	  }
	  if (!Array.isArray(prop) && !prop._isFieldArray) {
	    return new Error('Invalid prop "names" supplied to <Fields/>. Must be either an array of strings or the fields array generated by FieldArray.');
	  }
	};

	var createFields = function createFields(_ref) {
	  var deepEqual = _ref.deepEqual,
	      getIn = _ref.getIn,
	      toJS = _ref.toJS,
	      size = _ref.size;


	  var ConnectedFields = (0, _ConnectedFields2.default)({
	    deepEqual: deepEqual,
	    getIn: getIn,
	    toJS: toJS,
	    size: size
	  });

	  var Fields = function (_Component) {
	    _inherits(Fields, _Component);

	    function Fields(props, context) {
	      _classCallCheck(this, Fields);

	      var _this = _possibleConstructorReturn(this, (Fields.__proto__ || Object.getPrototypeOf(Fields)).call(this, props, context));

	      if (!context._reduxForm) {
	        throw new Error('Fields must be inside a component decorated with reduxForm()');
	      }
	      return _this;
	    }

	    _createClass(Fields, [{
	      key: 'shouldComponentUpdate',
	      value: function shouldComponentUpdate(nextProps, nextState) {
	        return (0, _shallowCompare2.default)(this, nextProps, nextState);
	      }
	    }, {
	      key: 'componentWillMount',
	      value: function componentWillMount() {
	        var error = validateNameProp(this.props.names);
	        if (error) {
	          throw error;
	        }
	        var context = this.context;
	        var register = context._reduxForm.register;

	        this.names.forEach(function (name) {
	          return register(name, 'Field');
	        });
	      }
	    }, {
	      key: 'componentWillReceiveProps',
	      value: function componentWillReceiveProps(nextProps) {
	        var _this2 = this;

	        if (!_plain2.default.deepEqual(this.props.names, nextProps.names)) {
	          (function () {
	            var context = _this2.context;
	            var _context$_reduxForm = context._reduxForm,
	                register = _context$_reduxForm.register,
	                unregister = _context$_reduxForm.unregister;
	            // unregister old name

	            _this2.props.names.forEach(function (name) {
	              return unregister((0, _prefixName2.default)(context, name));
	            });
	            // register new name
	            nextProps.names.forEach(function (name) {
	              return register((0, _prefixName2.default)(context, name), 'Field');
	            });
	          })();
	        }
	      }
	    }, {
	      key: 'componentWillUnmount',
	      value: function componentWillUnmount() {
	        var context = this.context;
	        var unregister = context._reduxForm.unregister;

	        this.props.names.forEach(function (name) {
	          return unregister((0, _prefixName2.default)(context, name));
	        });
	      }
	    }, {
	      key: 'getRenderedComponent',
	      value: function getRenderedComponent() {
	        (0, _invariant2.default)(this.props.withRef, 'If you want to access getRenderedComponent(), ' + 'you must specify a withRef prop to Fields');
	        return this.refs.connected.getWrappedInstance().getRenderedComponent();
	      }
	    }, {
	      key: 'render',
	      value: function render() {
	        var context = this.context;

	        return (0, _react.createElement)(ConnectedFields, _extends({}, this.props, {
	          names: this.props.names.map(function (name) {
	            return (0, _prefixName2.default)(context, name);
	          }),
	          _reduxForm: this.context._reduxForm,
	          ref: 'connected'
	        }));
	      }
	    }, {
	      key: 'names',
	      get: function get() {
	        var context = this.context;

	        return this.props.names.map(function (name) {
	          return (0, _prefixName2.default)(context, name);
	        });
	      }
	    }, {
	      key: 'dirty',
	      get: function get() {
	        return this.refs.connected.getWrappedInstance().isDirty();
	      }
	    }, {
	      key: 'pristine',
	      get: function get() {
	        return !this.dirty;
	      }
	    }, {
	      key: 'values',
	      get: function get() {
	        return this.refs.connected && this.refs.connected.getWrappedInstance().getValues();
	      }
	    }]);

	    return Fields;
	  }(_react.Component);

	  Fields.propTypes = {
	    names: function names(props, propName) {
	      return validateNameProp(props[propName]);
	    },
	    component: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]).isRequired,
	    format: _react.PropTypes.func,
	    parse: _react.PropTypes.func,
	    props: _react.PropTypes.object
	  };
	  Fields.contextTypes = {
	    _reduxForm: _react.PropTypes.object
	  };

	  return Fields;
	};

	exports.default = createFields;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _reactRedux = __webpack_require__(169);

	var _createFieldProps2 = __webpack_require__(221);

	var _createFieldProps3 = _interopRequireDefault(_createFieldProps2);

	var _plain = __webpack_require__(208);

	var _plain2 = _interopRequireDefault(_plain);

	var _onChangeValue = __webpack_require__(222);

	var _onChangeValue2 = _interopRequireDefault(_onChangeValue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var propsToNotUpdateFor = ['_reduxForm'];

	var createConnectedFields = function createConnectedFields(_ref) {
	  var deepEqual = _ref.deepEqual,
	      getIn = _ref.getIn,
	      toJS = _ref.toJS,
	      size = _ref.size;


	  var getSyncError = function getSyncError(syncErrors, name) {
	    var error = _plain2.default.getIn(syncErrors, name);
	    // Because the error for this field might not be at a level in the error structure where
	    // it can be set directly, it might need to be unwrapped from the _error property
	    return error && error._error ? error._error : error;
	  };

	  var getSyncWarning = function getSyncWarning(syncWarnings, name) {
	    var warning = _plain2.default.getIn(syncWarnings, name);
	    // Because the warning for this field might not be at a level in the warning structure where
	    // it can be set directly, it might need to be unwrapped from the _warning property
	    return warning && warning._warning ? warning._warning : warning;
	  };

	  var ConnectedFields = function (_Component) {
	    _inherits(ConnectedFields, _Component);

	    function ConnectedFields(props) {
	      _classCallCheck(this, ConnectedFields);

	      var _this = _possibleConstructorReturn(this, (ConnectedFields.__proto__ || Object.getPrototypeOf(ConnectedFields)).call(this, props));

	      _this.handleChange = _this.handleChange.bind(_this);
	      _this.handleFocus = _this.handleFocus.bind(_this);
	      _this.handleBlur = _this.handleBlur.bind(_this);

	      _this.onChangeFns = props.names.reduce(function (acc, name) {
	        acc[name] = function (event) {
	          return _this.handleChange(name, event);
	        };
	        return acc;
	      }, {});

	      _this.onFocusFns = props.names.reduce(function (acc, name) {
	        acc[name] = function () {
	          return _this.handleFocus(name);
	        };
	        return acc;
	      }, {});

	      _this.onBlurFns = props.names.reduce(function (acc, name) {
	        acc[name] = function (event) {
	          return _this.handleBlur(name, event);
	        };
	        return acc;
	      }, {});
	      return _this;
	    }

	    _createClass(ConnectedFields, [{
	      key: 'componentWillReceiveProps',
	      value: function componentWillReceiveProps(nextProps) {
	        var _this2 = this;

	        if (this.props.names !== nextProps.names && (size(this.props.names) !== size(nextProps.names) || nextProps.names.some(function (nextName) {
	          return !_this2.props._fields[nextName];
	        }))) {

	          // names is changed. The cached event handlers need to be updated
	          this.onChangeFns = nextProps.names.reduce(function (acc, name) {
	            acc[name] = function (event) {
	              return _this2.handleChange(name, event);
	            };
	            return acc;
	          }, {});

	          this.onFocusFns = nextProps.names.reduce(function (acc, name) {
	            acc[name] = function () {
	              return _this2.handleFocus(name);
	            };
	            return acc;
	          }, {});

	          this.onBlurFns = nextProps.names.reduce(function (acc, name) {
	            acc[name] = function (event) {
	              return _this2.handleBlur(name, event);
	            };
	            return acc;
	          }, {});
	        }
	      }
	    }, {
	      key: 'shouldComponentUpdate',
	      value: function shouldComponentUpdate(nextProps) {
	        var _this3 = this;

	        var nextPropsKeys = Object.keys(nextProps);
	        var thisPropsKeys = Object.keys(this.props);
	        return nextPropsKeys.length !== thisPropsKeys.length || nextPropsKeys.some(function (prop) {
	          return !~propsToNotUpdateFor.indexOf(prop) && !deepEqual(_this3.props[prop], nextProps[prop]);
	        });
	      }
	    }, {
	      key: 'isDirty',
	      value: function isDirty() {
	        var _fields = this.props._fields;

	        return Object.keys(_fields).some(function (name) {
	          return _fields[name].dirty;
	        });
	      }
	    }, {
	      key: 'getValues',
	      value: function getValues() {
	        var _fields = this.props._fields;

	        return Object.keys(_fields).reduce(function (accumulator, name) {
	          return _plain2.default.setIn(accumulator, name, _fields[name].value);
	        }, {});
	      }
	    }, {
	      key: 'getRenderedComponent',
	      value: function getRenderedComponent() {
	        return this.refs.renderedComponent;
	      }
	    }, {
	      key: 'handleChange',
	      value: function handleChange(name, event) {
	        var _props = this.props,
	            dispatch = _props.dispatch,
	            parse = _props.parse,
	            normalize = _props.normalize,
	            _reduxForm = _props._reduxForm;

	        var value = (0, _onChangeValue2.default)(event, { name: name, parse: parse, normalize: normalize });

	        dispatch(_reduxForm.change(name, value));
	      }
	    }, {
	      key: 'handleFocus',
	      value: function handleFocus(name) {
	        var _props2 = this.props,
	            dispatch = _props2.dispatch,
	            _reduxForm = _props2._reduxForm;

	        dispatch(_reduxForm.focus(name));
	      }
	    }, {
	      key: 'handleBlur',
	      value: function handleBlur(name, event) {
	        var _props3 = this.props,
	            dispatch = _props3.dispatch,
	            parse = _props3.parse,
	            normalize = _props3.normalize,
	            _reduxForm = _props3._reduxForm;

	        var value = (0, _onChangeValue2.default)(event, { name: name, parse: parse, normalize: normalize });

	        // dispatch blur action
	        dispatch(_reduxForm.blur(name, value));

	        // call post-blur callback
	        if (_reduxForm.asyncValidate) {
	          _reduxForm.asyncValidate(name, value);
	        }
	      }
	    }, {
	      key: 'render',
	      value: function render() {
	        var _this4 = this;

	        var _props4 = this.props,
	            component = _props4.component,
	            withRef = _props4.withRef,
	            _fields = _props4._fields,
	            _reduxForm = _props4._reduxForm,
	            rest = _objectWithoutProperties(_props4, ['component', 'withRef', '_fields', '_reduxForm']);

	        var sectionPrefix = _reduxForm.sectionPrefix;

	        var _Object$keys$reduce = Object.keys(_fields).reduce(function (accumulator, name) {
	          var connectedProps = _fields[name];

	          var _createFieldProps = (0, _createFieldProps3.default)({ getIn: getIn, toJS: toJS }, name, _extends({}, connectedProps, rest, {
	            onBlur: _this4.onBlurFns[name],
	            onChange: _this4.onChangeFns[name],
	            onFocus: _this4.onFocusFns[name]
	          })),
	              custom = _createFieldProps.custom,
	              fieldProps = _objectWithoutProperties(_createFieldProps, ['custom']);

	          accumulator.custom = custom;
	          var fieldName = sectionPrefix ? name.replace(sectionPrefix + '.', '') : name;
	          return _plain2.default.setIn(accumulator, fieldName, fieldProps);
	        }, {}),
	            custom = _Object$keys$reduce.custom,
	            props = _objectWithoutProperties(_Object$keys$reduce, ['custom']);

	        if (withRef) {
	          props.ref = 'renderedComponent';
	        }

	        return (0, _react.createElement)(component, _extends({}, props, custom));
	      }
	    }]);

	    return ConnectedFields;
	  }(_react.Component);

	  ConnectedFields.propTypes = {
	    component: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]).isRequired,
	    _fields: _react.PropTypes.object.isRequired,
	    props: _react.PropTypes.object
	  };

	  var connector = (0, _reactRedux.connect)(function (state, ownProps) {
	    var names = ownProps.names,
	        _ownProps$_reduxForm = ownProps._reduxForm,
	        initialValues = _ownProps$_reduxForm.initialValues,
	        getFormState = _ownProps$_reduxForm.getFormState;

	    var formState = getFormState(state);
	    return {
	      _fields: names.reduce(function (accumulator, name) {
	        var initialState = getIn(formState, 'initial.' + name);
	        var initial = initialState !== undefined ? initialState : initialValues && getIn(initialValues, name);
	        var value = getIn(formState, 'values.' + name);
	        var syncError = getSyncError(getIn(formState, 'syncErrors'), name);
	        var syncWarning = getSyncWarning(getIn(formState, 'syncWarnings'), name);
	        var submitting = getIn(formState, 'submitting');
	        var pristine = value === initial;
	        accumulator[name] = {
	          asyncError: getIn(formState, 'asyncErrors.' + name),
	          asyncValidating: getIn(formState, 'asyncValidating') === name,
	          dirty: !pristine,
	          pristine: pristine,
	          state: getIn(formState, 'fields.' + name),
	          submitError: getIn(formState, 'submitErrors.' + name),
	          submitFailed: getIn(formState, 'submitFailed'),
	          submitting: submitting,
	          syncError: syncError,
	          syncWarning: syncWarning,
	          value: value,
	          _value: ownProps.value // save value passed in (for checkboxes)
	        };
	        return accumulator;
	      }, {})
	    };
	  }, undefined, undefined, { withRef: true });
	  return connector(ConnectedFields);
	};

	exports.default = createConnectedFields;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _invariant = __webpack_require__(176);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _ConnectedFieldArray = __webpack_require__(231);

	var _ConnectedFieldArray2 = _interopRequireDefault(_ConnectedFieldArray);

	var _shallowCompare = __webpack_require__(226);

	var _shallowCompare2 = _interopRequireDefault(_shallowCompare);

	var _prefixName = __webpack_require__(227);

	var _prefixName2 = _interopRequireDefault(_prefixName);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var toArray = function toArray(value) {
	  return Array.isArray(value) ? value : [value];
	};

	var wrapError = function wrapError(fn, key) {
	  return fn && function () {
	    var validators = toArray(fn);
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = validators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var validator = _step.value;

	        var result = validator.apply(undefined, arguments);
	        if (result) {
	          return _defineProperty({}, key, result);
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  };
	};

	var createFieldArray = function createFieldArray(_ref2) {
	  var deepEqual = _ref2.deepEqual,
	      getIn = _ref2.getIn,
	      size = _ref2.size;


	  var ConnectedFieldArray = (0, _ConnectedFieldArray2.default)({ deepEqual: deepEqual, getIn: getIn, size: size });

	  var FieldArray = function (_Component) {
	    _inherits(FieldArray, _Component);

	    function FieldArray(props, context) {
	      _classCallCheck(this, FieldArray);

	      var _this = _possibleConstructorReturn(this, (FieldArray.__proto__ || Object.getPrototypeOf(FieldArray)).call(this, props, context));

	      if (!context._reduxForm) {
	        throw new Error('FieldArray must be inside a component decorated with reduxForm()');
	      }
	      return _this;
	    }

	    _createClass(FieldArray, [{
	      key: 'shouldComponentUpdate',
	      value: function shouldComponentUpdate(nextProps, nextState) {
	        return (0, _shallowCompare2.default)(this, nextProps, nextState);
	      }
	    }, {
	      key: 'componentWillMount',
	      value: function componentWillMount() {
	        var _this2 = this;

	        this.context._reduxForm.register(this.name, 'FieldArray', function () {
	          return wrapError(_this2.props.validate, '_error');
	        }, function () {
	          return wrapError(_this2.props.warn, '_warning');
	        });
	      }
	    }, {
	      key: 'componentWillReceiveProps',
	      value: function componentWillReceiveProps(nextProps) {
	        if (this.props.name !== nextProps.name) {
	          // unregister old name
	          this.context._reduxForm.unregister(this.name);
	          // register new name
	          this.context._reduxForm.register((0, _prefixName2.default)(this.context, nextProps.name), 'FieldArray');
	        }
	      }
	    }, {
	      key: 'componentWillUnmount',
	      value: function componentWillUnmount() {
	        this.context._reduxForm.unregister(this.name);
	      }
	    }, {
	      key: 'getRenderedComponent',
	      value: function getRenderedComponent() {
	        (0, _invariant2.default)(this.props.withRef, 'If you want to access getRenderedComponent(), ' + 'you must specify a withRef prop to FieldArray');
	        return this.refs.connected.getWrappedInstance().getRenderedComponent();
	      }
	    }, {
	      key: 'render',
	      value: function render() {
	        return (0, _react.createElement)(ConnectedFieldArray, _extends({}, this.props, {
	          name: this.name,
	          syncError: this.syncError,
	          syncWarning: this.syncWarning,
	          _reduxForm: this.context._reduxForm,
	          ref: 'connected'
	        }));
	      }
	    }, {
	      key: 'name',
	      get: function get() {
	        return (0, _prefixName2.default)(this.context, this.props.name);
	      }
	    }, {
	      key: 'dirty',
	      get: function get() {
	        return this.refs.connected.getWrappedInstance().dirty;
	      }
	    }, {
	      key: 'pristine',
	      get: function get() {
	        return this.refs.connected.getWrappedInstance().pristine;
	      }
	    }, {
	      key: 'value',
	      get: function get() {
	        return this.refs.connected.getWrappedInstance().value;
	      }
	    }]);

	    return FieldArray;
	  }(_react.Component);

	  FieldArray.propTypes = {
	    name: _react.PropTypes.string.isRequired,
	    component: _react.PropTypes.func.isRequired,
	    props: _react.PropTypes.object
	  };
	  FieldArray.contextTypes = {
	    _reduxForm: _react.PropTypes.object
	  };

	  return FieldArray;
	};

	exports.default = createFieldArray;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _mapValues2 = __webpack_require__(123);

	var _mapValues3 = _interopRequireDefault(_mapValues2);

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _reactRedux = __webpack_require__(169);

	var _redux = __webpack_require__(180);

	var _createFieldArrayProps = __webpack_require__(232);

	var _createFieldArrayProps2 = _interopRequireDefault(_createFieldArrayProps);

	var _plain = __webpack_require__(208);

	var _plain2 = _interopRequireDefault(_plain);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var propsToNotUpdateFor = ['_reduxForm', 'value'];

	var createConnectedFieldArray = function createConnectedFieldArray(_ref) {
	  var deepEqual = _ref.deepEqual,
	      getIn = _ref.getIn,
	      size = _ref.size;


	  var getSyncError = function getSyncError(syncErrors, name) {
	    // For an array, the error can _ONLY_ be under _error.
	    // This is why this getSyncError is not the same as the
	    // one in Field.
	    return _plain2.default.getIn(syncErrors, name + '._error');
	  };

	  var getSyncWarning = function getSyncWarning(syncWarnings, name) {
	    // For an array, the warning can _ONLY_ be under _warning.
	    // This is why this getSyncError is not the same as the
	    // one in Field.
	    return _plain2.default.getIn(syncWarnings, name + '._warning');
	  };

	  var ConnectedFieldArray = function (_Component) {
	    _inherits(ConnectedFieldArray, _Component);

	    function ConnectedFieldArray() {
	      _classCallCheck(this, ConnectedFieldArray);

	      var _this = _possibleConstructorReturn(this, (ConnectedFieldArray.__proto__ || Object.getPrototypeOf(ConnectedFieldArray)).call(this));

	      _this.getValue = _this.getValue.bind(_this);
	      return _this;
	    }

	    _createClass(ConnectedFieldArray, [{
	      key: 'shouldComponentUpdate',
	      value: function shouldComponentUpdate(nextProps) {
	        var _this2 = this;

	        var nextPropsKeys = Object.keys(nextProps);
	        var thisPropsKeys = Object.keys(this.props);
	        return nextPropsKeys.length !== thisPropsKeys.length || nextPropsKeys.some(function (prop) {
	          // useful to debug rerenders
	          // if (!plain.deepEqual(this.props[ prop ], nextProps[ prop ])) {
	          //   console.info(prop, 'changed', this.props[ prop ], '==>', nextProps[ prop ])
	          // }
	          return !~propsToNotUpdateFor.indexOf(prop) && !deepEqual(_this2.props[prop], nextProps[prop]);
	        });
	      }
	    }, {
	      key: 'getRenderedComponent',
	      value: function getRenderedComponent() {
	        return this.refs.renderedComponent;
	      }
	    }, {
	      key: 'getValue',
	      value: function getValue(index) {
	        return this.props.value && getIn(this.props.value, index);
	      }
	    }, {
	      key: 'render',
	      value: function render() {
	        var _props = this.props,
	            component = _props.component,
	            withRef = _props.withRef,
	            name = _props.name,
	            _reduxForm = _props._reduxForm,
	            validate = _props.validate,
	            warn = _props.warn,
	            rest = _objectWithoutProperties(_props, ['component', 'withRef', 'name', '_reduxForm', 'validate', 'warn']);

	        var props = (0, _createFieldArrayProps2.default)(getIn, name, _reduxForm.sectionPrefix, this.getValue, rest);
	        if (withRef) {
	          props.ref = 'renderedComponent';
	        }
	        return (0, _react.createElement)(component, props);
	      }
	    }, {
	      key: 'dirty',
	      get: function get() {
	        return this.props.dirty;
	      }
	    }, {
	      key: 'pristine',
	      get: function get() {
	        return this.props.pristine;
	      }
	    }, {
	      key: 'value',
	      get: function get() {
	        return this.props.value;
	      }
	    }]);

	    return ConnectedFieldArray;
	  }(_react.Component);

	  ConnectedFieldArray.propTypes = {
	    component: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]).isRequired,
	    props: _react.PropTypes.object
	  };

	  ConnectedFieldArray.contextTypes = {
	    _reduxForm: _react.PropTypes.object
	  };

	  var connector = (0, _reactRedux.connect)(function (state, ownProps) {
	    var name = ownProps.name,
	        _ownProps$_reduxForm = ownProps._reduxForm,
	        initialValues = _ownProps$_reduxForm.initialValues,
	        getFormState = _ownProps$_reduxForm.getFormState;

	    var formState = getFormState(state);
	    var initial = getIn(formState, 'initial.' + name) || initialValues && getIn(initialValues, name);
	    var value = getIn(formState, 'values.' + name);
	    var submitting = getIn(formState, 'submitting');
	    var syncError = getSyncError(getIn(formState, 'syncErrors'), name);
	    var syncWarning = getSyncWarning(getIn(formState, 'syncWarnings'), name);
	    var pristine = deepEqual(value, initial);
	    return {
	      asyncError: getIn(formState, 'asyncErrors.' + name + '._error'),
	      dirty: !pristine,
	      pristine: pristine,
	      state: getIn(formState, 'fields.' + name),
	      submitError: getIn(formState, 'submitErrors.' + name + '._error'),
	      submitting: submitting,
	      syncError: syncError,
	      syncWarning: syncWarning,
	      value: value,
	      length: size(value)
	    };
	  }, function (dispatch, ownProps) {
	    var name = ownProps.name,
	        _reduxForm = ownProps._reduxForm;
	    var arrayInsert = _reduxForm.arrayInsert,
	        arrayMove = _reduxForm.arrayMove,
	        arrayPop = _reduxForm.arrayPop,
	        arrayPush = _reduxForm.arrayPush,
	        arrayRemove = _reduxForm.arrayRemove,
	        arrayRemoveAll = _reduxForm.arrayRemoveAll,
	        arrayShift = _reduxForm.arrayShift,
	        arraySplice = _reduxForm.arraySplice,
	        arraySwap = _reduxForm.arraySwap,
	        arrayUnshift = _reduxForm.arrayUnshift;

	    return (0, _mapValues3.default)({
	      arrayInsert: arrayInsert,
	      arrayMove: arrayMove,
	      arrayPop: arrayPop,
	      arrayPush: arrayPush,
	      arrayRemove: arrayRemove,
	      arrayRemoveAll: arrayRemoveAll,
	      arrayShift: arrayShift,
	      arraySplice: arraySplice,
	      arraySwap: arraySwap,
	      arrayUnshift: arrayUnshift
	    }, function (actionCreator) {
	      return (0, _redux.bindActionCreators)(actionCreator.bind(null, name), dispatch);
	    });
	  }, undefined, { withRef: true });
	  return connector(ConnectedFieldArray);
	};

	exports.default = createConnectedFieldArray;

/***/ },
/* 232 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var createFieldArrayProps = function createFieldArrayProps(getIn, name, sectionPrefix, getValue, _ref) {
	  var arrayInsert = _ref.arrayInsert,
	      arrayMove = _ref.arrayMove,
	      arrayPop = _ref.arrayPop,
	      arrayPush = _ref.arrayPush,
	      arrayRemove = _ref.arrayRemove,
	      arrayRemoveAll = _ref.arrayRemoveAll,
	      arrayShift = _ref.arrayShift,
	      arraySplice = _ref.arraySplice,
	      arraySwap = _ref.arraySwap,
	      arrayUnshift = _ref.arrayUnshift,
	      asyncError = _ref.asyncError,
	      dirty = _ref.dirty,
	      length = _ref.length,
	      pristine = _ref.pristine,
	      submitError = _ref.submitError,
	      state = _ref.state,
	      submitFailed = _ref.submitFailed,
	      submitting = _ref.submitting,
	      syncError = _ref.syncError,
	      syncWarning = _ref.syncWarning,
	      value = _ref.value,
	      props = _ref.props,
	      rest = _objectWithoutProperties(_ref, ['arrayInsert', 'arrayMove', 'arrayPop', 'arrayPush', 'arrayRemove', 'arrayRemoveAll', 'arrayShift', 'arraySplice', 'arraySwap', 'arrayUnshift', 'asyncError', 'dirty', 'length', 'pristine', 'submitError', 'state', 'submitFailed', 'submitting', 'syncError', 'syncWarning', 'value', 'props']);

	  var error = syncError || asyncError || submitError;
	  var warning = syncWarning;
	  var fieldName = sectionPrefix ? name.replace(sectionPrefix + '.', '') : name;
	  var finalProps = _extends({
	    fields: {
	      _isFieldArray: true,
	      forEach: function forEach(callback) {
	        return (value || []).forEach(function (item, index) {
	          return callback(fieldName + '[' + index + ']', index, finalProps.fields);
	        });
	      },
	      get: getValue,
	      getAll: function getAll() {
	        return value;
	      },
	      insert: arrayInsert,
	      length: length,
	      map: function map(callback) {
	        return (value || []).map(function (item, index) {
	          return callback(fieldName + '[' + index + ']', index, finalProps.fields);
	        });
	      },
	      move: arrayMove,
	      name: name,
	      pop: function pop() {
	        arrayPop();
	        return getIn(value, length - 1);
	      },
	      push: arrayPush,
	      reduce: function reduce(callback, initial) {
	        return (value || []).reduce(function (accumulator, item, index) {
	          return callback(accumulator, fieldName + '[' + index + ']', index, finalProps.fields);
	        }, initial);
	      },
	      remove: arrayRemove,
	      removeAll: arrayRemoveAll,
	      shift: function shift() {
	        arrayShift();
	        return getIn(value, 0);
	      },
	      swap: arraySwap,
	      unshift: arrayUnshift
	    },
	    meta: {
	      dirty: dirty,
	      error: error,
	      warning: warning,
	      invalid: !!error,
	      pristine: pristine,
	      submitting: submitting,
	      touched: !!(state && getIn(state, 'touched')),
	      valid: !error
	    }
	  }, props, rest);
	  return finalProps;
	};

	exports.default = createFieldArrayProps;

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _invariant = __webpack_require__(176);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _plain = __webpack_require__(208);

	var _plain2 = _interopRequireDefault(_plain);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var createFormValueSelector = function createFormValueSelector(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };

	    (0, _invariant2.default)(form, 'Form value must be specified');
	    return function (state) {
	      for (var _len = arguments.length, fields = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        fields[_key - 1] = arguments[_key];
	      }

	      (0, _invariant2.default)(fields.length, 'No fields specified');
	      return fields.length === 1 ?
	      // only selecting one field, so return its value
	      getIn(getFormState(state), form + '.values.' + fields[0]) :
	      // selecting many fields, so return an object of field values
	      fields.reduce(function (accumulator, field) {
	        var value = getIn(getFormState(state), form + '.values.' + field);
	        return value === undefined ? accumulator : _plain2.default.setIn(accumulator, field, value);
	      }, {});
	    };
	  };
	};

	exports.default = createFormValueSelector;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _reactRedux = __webpack_require__(169);

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var createValues = function createValues(_ref) {
	  var getIn = _ref.getIn;
	  return function (config) {
	    var _prop$getFormState$co = _extends({
	      prop: 'values',
	      getFormState: function getFormState(state) {
	        return getIn(state, 'form');
	      }
	    }, config),
	        form = _prop$getFormState$co.form,
	        prop = _prop$getFormState$co.prop,
	        getFormState = _prop$getFormState$co.getFormState;

	    return (0, _reactRedux.connect)(function (state) {
	      return _defineProperty({}, prop, getIn(getFormState(state), form + '.values'));
	    }, function () {
	      return {};
	    } // ignore dispatch
	    );
	  };
	};

	exports.default = createValues;

/***/ },
/* 235 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createGetFormValues = function createGetFormValues(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      return getIn(getFormState(state), form + '.values');
	    };
	  };
	};

	exports.default = createGetFormValues;

/***/ },
/* 236 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createGetFormInitialValues = function createGetFormInitialValues(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      return getIn(getFormState(state), form + '.initial');
	    };
	  };
	};

	exports.default = createGetFormInitialValues;

/***/ },
/* 237 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createGetFormSyncErrors = function createGetFormSyncErrors(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      return getIn(getFormState(state), form + '.syncErrors');
	    };
	  };
	};

	exports.default = createGetFormSyncErrors;

/***/ },
/* 238 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createGetFormAsyncErrors = function createGetFormAsyncErrors(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      return getIn(getFormState(state), form + '.asyncErrors');
	    };
	  };
	};

	exports.default = createGetFormAsyncErrors;

/***/ },
/* 239 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createGetFormSubmitErrors = function createGetFormSubmitErrors(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      return getIn(getFormState(state), form + '.submitErrors');
	    };
	  };
	};

	exports.default = createGetFormSubmitErrors;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _isPristine = __webpack_require__(241);

	var _isPristine2 = _interopRequireDefault(_isPristine);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var createIsDirty = function createIsDirty(structure) {
	  return function (form, getFormState) {
	    var isPristine = (0, _isPristine2.default)(structure)(form, getFormState);
	    return function (state) {
	      return !isPristine(state);
	    };
	  };
	};

	exports.default = createIsDirty;

/***/ },
/* 241 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createIsPristine = function createIsPristine(_ref) {
	  var deepEqual = _ref.deepEqual,
	      empty = _ref.empty,
	      getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      var formState = getFormState(state);
	      var initial = getIn(formState, form + '.initial') || empty;
	      var values = getIn(formState, form + '.values') || initial;
	      return deepEqual(initial, values);
	    };
	  };
	};

	exports.default = createIsPristine;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _isValid = __webpack_require__(217);

	var _isValid2 = _interopRequireDefault(_isValid);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var createIsInvalid = function createIsInvalid(structure) {
	  return function (form, getFormState) {
	    var isValid = (0, _isValid2.default)(structure)(form, getFormState);
	    return function (state) {
	      return !isValid(state);
	    };
	  };
	};

	exports.default = createIsInvalid;

/***/ },
/* 243 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createIsSubmitting = function createIsSubmitting(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      var formState = getFormState(state);
	      return getIn(formState, form + '.submitting') || false;
	    };
	  };
	};

	exports.default = createIsSubmitting;

/***/ },
/* 244 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createHasSubmitSucceeded = function createHasSubmitSucceeded(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      var formState = getFormState(state);
	      return getIn(formState, form + '.submitSucceeded') || false;
	    };
	  };
	};

	exports.default = createHasSubmitSucceeded;

/***/ },
/* 245 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var createHasSubmitFailed = function createHasSubmitFailed(_ref) {
	  var getIn = _ref.getIn;
	  return function (form) {
	    var getFormState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
	      return getIn(state, 'form');
	    };
	    return function (state) {
	      var formState = getFormState(state);
	      return getIn(formState, form + '.submitFailed') || false;
	    };
	  };
	};

	exports.default = createHasSubmitFailed;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Form = function (_Component) {
	  _inherits(Form, _Component);

	  function Form(props, context) {
	    _classCallCheck(this, Form);

	    var _this = _possibleConstructorReturn(this, (Form.__proto__ || Object.getPrototypeOf(Form)).call(this, props, context));

	    if (!context._reduxForm) {
	      throw new Error('Form must be inside a component decorated with reduxForm()');
	    }
	    return _this;
	  }

	  _createClass(Form, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      this.context._reduxForm.registerInnerOnSubmit(this.props.onSubmit);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('form', this.props);
	    }
	  }]);

	  return Form;
	}(_react.Component);

	Form.propTypes = {
	  onSubmit: _react.PropTypes.func.isRequired
	};
	Form.contextTypes = {
	  _reduxForm: _react.PropTypes.object
	};

	exports.default = Form;

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _prefixName = __webpack_require__(227);

	var _prefixName2 = _interopRequireDefault(_prefixName);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FormSection = function (_Component) {
	  _inherits(FormSection, _Component);

	  function FormSection(props, context) {
	    _classCallCheck(this, FormSection);

	    var _this = _possibleConstructorReturn(this, (FormSection.__proto__ || Object.getPrototypeOf(FormSection)).call(this, props, context));

	    if (!context._reduxForm) {
	      throw new Error('FormSection must be inside a component decorated with reduxForm()');
	    }
	    return _this;
	  }

	  _createClass(FormSection, [{
	    key: 'getChildContext',
	    value: function getChildContext() {
	      var context = this.context,
	          name = this.props.name;

	      return {
	        _reduxForm: _extends({}, context._reduxForm, {
	          sectionPrefix: (0, _prefixName2.default)(context, name)
	        })
	      };
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          children = _props.children,
	          name = _props.name,
	          component = _props.component,
	          rest = _objectWithoutProperties(_props, ['children', 'name', 'component']);

	      if (_react2.default.isValidElement(children)) {
	        return children;
	      }

	      return (0, _react.createElement)(component, _extends({}, rest, {
	        children: children
	      }));
	    }
	  }]);

	  return FormSection;
	}(_react.Component);

	FormSection.propTypes = {
	  name: _react.PropTypes.string.isRequired,
	  component: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string])
	};

	FormSection.defaultProps = {
	  component: 'div'
	};

	FormSection.childContextTypes = {
	  _reduxForm: _react.PropTypes.object.isRequired
	};

	FormSection.contextTypes = {
	  _reduxForm: _react.PropTypes.object
	};

	exports.default = FormSection;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(1);

	var any = _react.PropTypes.any,
	    bool = _react.PropTypes.bool,
	    func = _react.PropTypes.func,
	    shape = _react.PropTypes.shape;


	var propTypes = {
	  // State:
	  asyncValidating: bool.isRequired, // true if async validation is running
	  dirty: bool.isRequired, // true if any values are different from initialValues
	  error: any, // form-wide error from '_error' key in validation result
	  warning: any, // form-wide warning from '_warning' key in validation result
	  invalid: bool.isRequired, // true if there are any validation errors
	  initialized: bool.isRequired, // true if the form has been initialized
	  pristine: bool.isRequired, // true if the values are the same as initialValues
	  submitting: bool.isRequired, // true if the form is in the process of being submitted
	  submitFailed: bool.isRequired, // true if the form was submitted and failed for any reason
	  submitSucceeded: bool.isRequired, // true if the form was successfully submitted
	  valid: bool.isRequired, // true if there are no validation errors
	  // Actions:
	  array: shape({
	    insert: func.isRequired, // function to insert a value into an array field
	    move: func.isRequired, // function to move a value within an array field
	    pop: func.isRequired, // function to pop a value off of an array field
	    push: func.isRequired, // function to push a value onto an array field
	    remove: func.isRequired, // function to remove a value from an array field
	    removeAll: func.isRequired, // function to remove all the values from an array field
	    shift: func.isRequired, // function to shift a value out of an array field
	    splice: func.isRequired, // function to splice a value into an array field
	    swap: func.isRequired, // function to swap values in an array field
	    unshift: func.isRequired // function to unshift a value into an array field
	  }),
	  asyncValidate: func.isRequired, // function to trigger async validation
	  blur: func.isRequired, // action to mark a field as blurred
	  change: func.isRequired, // action to change the value of a field
	  destroy: func.isRequired, // action to destroy the form's data in Redux
	  dispatch: func.isRequired, // the Redux dispatch action
	  handleSubmit: func.isRequired, // function to submit the form
	  initialize: func.isRequired, // action to initialize form data
	  reset: func.isRequired, // action to reset the form data to previously initialized values
	  touch: func.isRequired, // action to mark fields as touched
	  untouch: func.isRequired // action to mark fields as untouched
	};

	exports.default = propTypes;

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: modal.js v3.3.7
	 * http://getbootstrap.com/javascript/#modals
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // MODAL CLASS DEFINITION
	  // ======================

	  var Modal = function (element, options) {
	    this.options             = options
	    this.$body               = $(document.body)
	    this.$element            = $(element)
	    this.$dialog             = this.$element.find('.modal-dialog')
	    this.$backdrop           = null
	    this.isShown             = null
	    this.originalBodyPad     = null
	    this.scrollbarWidth      = 0
	    this.ignoreBackdropClick = false

	    if (this.options.remote) {
	      this.$element
	        .find('.modal-content')
	        .load(this.options.remote, $.proxy(function () {
	          this.$element.trigger('loaded.bs.modal')
	        }, this))
	    }
	  }

	  Modal.VERSION  = '3.3.7'

	  Modal.TRANSITION_DURATION = 300
	  Modal.BACKDROP_TRANSITION_DURATION = 150

	  Modal.DEFAULTS = {
	    backdrop: true,
	    keyboard: true,
	    show: true
	  }

	  Modal.prototype.toggle = function (_relatedTarget) {
	    return this.isShown ? this.hide() : this.show(_relatedTarget)
	  }

	  Modal.prototype.show = function (_relatedTarget) {
	    var that = this
	    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

	    this.$element.trigger(e)

	    if (this.isShown || e.isDefaultPrevented()) return

	    this.isShown = true

	    this.checkScrollbar()
	    this.setScrollbar()
	    this.$body.addClass('modal-open')

	    this.escape()
	    this.resize()

	    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

	    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
	      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
	        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
	      })
	    })

	    this.backdrop(function () {
	      var transition = $.support.transition && that.$element.hasClass('fade')

	      if (!that.$element.parent().length) {
	        that.$element.appendTo(that.$body) // don't move modals dom position
	      }

	      that.$element
	        .show()
	        .scrollTop(0)

	      that.adjustDialog()

	      if (transition) {
	        that.$element[0].offsetWidth // force reflow
	      }

	      that.$element.addClass('in')

	      that.enforceFocus()

	      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

	      transition ?
	        that.$dialog // wait for modal to slide in
	          .one('bsTransitionEnd', function () {
	            that.$element.trigger('focus').trigger(e)
	          })
	          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	        that.$element.trigger('focus').trigger(e)
	    })
	  }

	  Modal.prototype.hide = function (e) {
	    if (e) e.preventDefault()

	    e = $.Event('hide.bs.modal')

	    this.$element.trigger(e)

	    if (!this.isShown || e.isDefaultPrevented()) return

	    this.isShown = false

	    this.escape()
	    this.resize()

	    $(document).off('focusin.bs.modal')

	    this.$element
	      .removeClass('in')
	      .off('click.dismiss.bs.modal')
	      .off('mouseup.dismiss.bs.modal')

	    this.$dialog.off('mousedown.dismiss.bs.modal')

	    $.support.transition && this.$element.hasClass('fade') ?
	      this.$element
	        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
	        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	      this.hideModal()
	  }

	  Modal.prototype.enforceFocus = function () {
	    $(document)
	      .off('focusin.bs.modal') // guard against infinite focus loop
	      .on('focusin.bs.modal', $.proxy(function (e) {
	        if (document !== e.target &&
	            this.$element[0] !== e.target &&
	            !this.$element.has(e.target).length) {
	          this.$element.trigger('focus')
	        }
	      }, this))
	  }

	  Modal.prototype.escape = function () {
	    if (this.isShown && this.options.keyboard) {
	      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
	        e.which == 27 && this.hide()
	      }, this))
	    } else if (!this.isShown) {
	      this.$element.off('keydown.dismiss.bs.modal')
	    }
	  }

	  Modal.prototype.resize = function () {
	    if (this.isShown) {
	      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
	    } else {
	      $(window).off('resize.bs.modal')
	    }
	  }

	  Modal.prototype.hideModal = function () {
	    var that = this
	    this.$element.hide()
	    this.backdrop(function () {
	      that.$body.removeClass('modal-open')
	      that.resetAdjustments()
	      that.resetScrollbar()
	      that.$element.trigger('hidden.bs.modal')
	    })
	  }

	  Modal.prototype.removeBackdrop = function () {
	    this.$backdrop && this.$backdrop.remove()
	    this.$backdrop = null
	  }

	  Modal.prototype.backdrop = function (callback) {
	    var that = this
	    var animate = this.$element.hasClass('fade') ? 'fade' : ''

	    if (this.isShown && this.options.backdrop) {
	      var doAnimate = $.support.transition && animate

	      this.$backdrop = $(document.createElement('div'))
	        .addClass('modal-backdrop ' + animate)
	        .appendTo(this.$body)

	      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
	        if (this.ignoreBackdropClick) {
	          this.ignoreBackdropClick = false
	          return
	        }
	        if (e.target !== e.currentTarget) return
	        this.options.backdrop == 'static'
	          ? this.$element[0].focus()
	          : this.hide()
	      }, this))

	      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

	      this.$backdrop.addClass('in')

	      if (!callback) return

	      doAnimate ?
	        this.$backdrop
	          .one('bsTransitionEnd', callback)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callback()

	    } else if (!this.isShown && this.$backdrop) {
	      this.$backdrop.removeClass('in')

	      var callbackRemove = function () {
	        that.removeBackdrop()
	        callback && callback()
	      }
	      $.support.transition && this.$element.hasClass('fade') ?
	        this.$backdrop
	          .one('bsTransitionEnd', callbackRemove)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callbackRemove()

	    } else if (callback) {
	      callback()
	    }
	  }

	  // these following methods are used to handle overflowing modals

	  Modal.prototype.handleUpdate = function () {
	    this.adjustDialog()
	  }

	  Modal.prototype.adjustDialog = function () {
	    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

	    this.$element.css({
	      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
	      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
	    })
	  }

	  Modal.prototype.resetAdjustments = function () {
	    this.$element.css({
	      paddingLeft: '',
	      paddingRight: ''
	    })
	  }

	  Modal.prototype.checkScrollbar = function () {
	    var fullWindowWidth = window.innerWidth
	    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
	      var documentElementRect = document.documentElement.getBoundingClientRect()
	      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
	    }
	    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
	    this.scrollbarWidth = this.measureScrollbar()
	  }

	  Modal.prototype.setScrollbar = function () {
	    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
	    this.originalBodyPad = document.body.style.paddingRight || ''
	    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
	  }

	  Modal.prototype.resetScrollbar = function () {
	    this.$body.css('padding-right', this.originalBodyPad)
	  }

	  Modal.prototype.measureScrollbar = function () { // thx walsh
	    var scrollDiv = document.createElement('div')
	    scrollDiv.className = 'modal-scrollbar-measure'
	    this.$body.append(scrollDiv)
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
	    this.$body[0].removeChild(scrollDiv)
	    return scrollbarWidth
	  }


	  // MODAL PLUGIN DEFINITION
	  // =======================

	  function Plugin(option, _relatedTarget) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.modal')
	      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

	      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
	      if (typeof option == 'string') data[option](_relatedTarget)
	      else if (options.show) data.show(_relatedTarget)
	    })
	  }

	  var old = $.fn.modal

	  $.fn.modal             = Plugin
	  $.fn.modal.Constructor = Modal


	  // MODAL NO CONFLICT
	  // =================

	  $.fn.modal.noConflict = function () {
	    $.fn.modal = old
	    return this
	  }


	  // MODAL DATA-API
	  // ==============

	  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
	    var $this   = $(this)
	    var href    = $this.attr('href')
	    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
	    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

	    if ($this.is('a')) e.preventDefault()

	    $target.one('show.bs.modal', function (showEvent) {
	      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
	      $target.one('hidden.bs.modal', function () {
	        $this.is(':visible') && $this.trigger('focus')
	      })
	    })
	    Plugin.call($target, option, this)
	  })

	}(jQuery);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: dropdown.js v3.3.7
	 * http://getbootstrap.com/javascript/#dropdowns
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // DROPDOWN CLASS DEFINITION
	  // =========================

	  var backdrop = '.dropdown-backdrop'
	  var toggle   = '[data-toggle="dropdown"]'
	  var Dropdown = function (element) {
	    $(element).on('click.bs.dropdown', this.toggle)
	  }

	  Dropdown.VERSION = '3.3.7'

	  function getParent($this) {
	    var selector = $this.attr('data-target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    var $parent = selector && $(selector)

	    return $parent && $parent.length ? $parent : $this.parent()
	  }

	  function clearMenus(e) {
	    if (e && e.which === 3) return
	    $(backdrop).remove()
	    $(toggle).each(function () {
	      var $this         = $(this)
	      var $parent       = getParent($this)
	      var relatedTarget = { relatedTarget: this }

	      if (!$parent.hasClass('open')) return

	      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

	      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

	      if (e.isDefaultPrevented()) return

	      $this.attr('aria-expanded', 'false')
	      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
	    })
	  }

	  Dropdown.prototype.toggle = function (e) {
	    var $this = $(this)

	    if ($this.is('.disabled, :disabled')) return

	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')

	    clearMenus()

	    if (!isActive) {
	      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
	        // if mobile we use a backdrop because click events don't delegate
	        $(document.createElement('div'))
	          .addClass('dropdown-backdrop')
	          .insertAfter($(this))
	          .on('click', clearMenus)
	      }

	      var relatedTarget = { relatedTarget: this }
	      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

	      if (e.isDefaultPrevented()) return

	      $this
	        .trigger('focus')
	        .attr('aria-expanded', 'true')

	      $parent
	        .toggleClass('open')
	        .trigger($.Event('shown.bs.dropdown', relatedTarget))
	    }

	    return false
	  }

	  Dropdown.prototype.keydown = function (e) {
	    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

	    var $this = $(this)

	    e.preventDefault()
	    e.stopPropagation()

	    if ($this.is('.disabled, :disabled')) return

	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')

	    if (!isActive && e.which != 27 || isActive && e.which == 27) {
	      if (e.which == 27) $parent.find(toggle).trigger('focus')
	      return $this.trigger('click')
	    }

	    var desc = ' li:not(.disabled):visible a'
	    var $items = $parent.find('.dropdown-menu' + desc)

	    if (!$items.length) return

	    var index = $items.index(e.target)

	    if (e.which == 38 && index > 0)                 index--         // up
	    if (e.which == 40 && index < $items.length - 1) index++         // down
	    if (!~index)                                    index = 0

	    $items.eq(index).trigger('focus')
	  }


	  // DROPDOWN PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.dropdown')

	      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }

	  var old = $.fn.dropdown

	  $.fn.dropdown             = Plugin
	  $.fn.dropdown.Constructor = Dropdown


	  // DROPDOWN NO CONFLICT
	  // ====================

	  $.fn.dropdown.noConflict = function () {
	    $.fn.dropdown = old
	    return this
	  }


	  // APPLY TO STANDARD DROPDOWN ELEMENTS
	  // ===================================

	  $(document)
	    .on('click.bs.dropdown.data-api', clearMenus)
	    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
	    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
	    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

	}(jQuery);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: tooltip.js v3.3.7
	 * http://getbootstrap.com/javascript/#tooltip
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // TOOLTIP PUBLIC CLASS DEFINITION
	  // ===============================

	  var Tooltip = function (element, options) {
	    this.type       = null
	    this.options    = null
	    this.enabled    = null
	    this.timeout    = null
	    this.hoverState = null
	    this.$element   = null
	    this.inState    = null

	    this.init('tooltip', element, options)
	  }

	  Tooltip.VERSION  = '3.3.7'

	  Tooltip.TRANSITION_DURATION = 150

	  Tooltip.DEFAULTS = {
	    animation: true,
	    placement: 'top',
	    selector: false,
	    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
	    trigger: 'hover focus',
	    title: '',
	    delay: 0,
	    html: false,
	    container: false,
	    viewport: {
	      selector: 'body',
	      padding: 0
	    }
	  }

	  Tooltip.prototype.init = function (type, element, options) {
	    this.enabled   = true
	    this.type      = type
	    this.$element  = $(element)
	    this.options   = this.getOptions(options)
	    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
	    this.inState   = { click: false, hover: false, focus: false }

	    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
	      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
	    }

	    var triggers = this.options.trigger.split(' ')

	    for (var i = triggers.length; i--;) {
	      var trigger = triggers[i]

	      if (trigger == 'click') {
	        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	      } else if (trigger != 'manual') {
	        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
	        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

	        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
	        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	      }
	    }

	    this.options.selector ?
	      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	      this.fixTitle()
	  }

	  Tooltip.prototype.getDefaults = function () {
	    return Tooltip.DEFAULTS
	  }

	  Tooltip.prototype.getOptions = function (options) {
	    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

	    if (options.delay && typeof options.delay == 'number') {
	      options.delay = {
	        show: options.delay,
	        hide: options.delay
	      }
	    }

	    return options
	  }

	  Tooltip.prototype.getDelegateOptions = function () {
	    var options  = {}
	    var defaults = this.getDefaults()

	    this._options && $.each(this._options, function (key, value) {
	      if (defaults[key] != value) options[key] = value
	    })

	    return options
	  }

	  Tooltip.prototype.enter = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)

	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }

	    if (obj instanceof $.Event) {
	      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
	    }

	    if (self.tip().hasClass('in') || self.hoverState == 'in') {
	      self.hoverState = 'in'
	      return
	    }

	    clearTimeout(self.timeout)

	    self.hoverState = 'in'

	    if (!self.options.delay || !self.options.delay.show) return self.show()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'in') self.show()
	    }, self.options.delay.show)
	  }

	  Tooltip.prototype.isInStateTrue = function () {
	    for (var key in this.inState) {
	      if (this.inState[key]) return true
	    }

	    return false
	  }

	  Tooltip.prototype.leave = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)

	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }

	    if (obj instanceof $.Event) {
	      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
	    }

	    if (self.isInStateTrue()) return

	    clearTimeout(self.timeout)

	    self.hoverState = 'out'

	    if (!self.options.delay || !self.options.delay.hide) return self.hide()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'out') self.hide()
	    }, self.options.delay.hide)
	  }

	  Tooltip.prototype.show = function () {
	    var e = $.Event('show.bs.' + this.type)

	    if (this.hasContent() && this.enabled) {
	      this.$element.trigger(e)

	      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
	      if (e.isDefaultPrevented() || !inDom) return
	      var that = this

	      var $tip = this.tip()

	      var tipId = this.getUID(this.type)

	      this.setContent()
	      $tip.attr('id', tipId)
	      this.$element.attr('aria-describedby', tipId)

	      if (this.options.animation) $tip.addClass('fade')

	      var placement = typeof this.options.placement == 'function' ?
	        this.options.placement.call(this, $tip[0], this.$element[0]) :
	        this.options.placement

	      var autoToken = /\s?auto?\s?/i
	      var autoPlace = autoToken.test(placement)
	      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

	      $tip
	        .detach()
	        .css({ top: 0, left: 0, display: 'block' })
	        .addClass(placement)
	        .data('bs.' + this.type, this)

	      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
	      this.$element.trigger('inserted.bs.' + this.type)

	      var pos          = this.getPosition()
	      var actualWidth  = $tip[0].offsetWidth
	      var actualHeight = $tip[0].offsetHeight

	      if (autoPlace) {
	        var orgPlacement = placement
	        var viewportDim = this.getPosition(this.$viewport)

	        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
	                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
	                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
	                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
	                    placement

	        $tip
	          .removeClass(orgPlacement)
	          .addClass(placement)
	      }

	      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

	      this.applyPlacement(calculatedOffset, placement)

	      var complete = function () {
	        var prevHoverState = that.hoverState
	        that.$element.trigger('shown.bs.' + that.type)
	        that.hoverState = null

	        if (prevHoverState == 'out') that.leave(that)
	      }

	      $.support.transition && this.$tip.hasClass('fade') ?
	        $tip
	          .one('bsTransitionEnd', complete)
	          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	        complete()
	    }
	  }

	  Tooltip.prototype.applyPlacement = function (offset, placement) {
	    var $tip   = this.tip()
	    var width  = $tip[0].offsetWidth
	    var height = $tip[0].offsetHeight

	    // manually read margins because getBoundingClientRect includes difference
	    var marginTop = parseInt($tip.css('margin-top'), 10)
	    var marginLeft = parseInt($tip.css('margin-left'), 10)

	    // we must check for NaN for ie 8/9
	    if (isNaN(marginTop))  marginTop  = 0
	    if (isNaN(marginLeft)) marginLeft = 0

	    offset.top  += marginTop
	    offset.left += marginLeft

	    // $.fn.offset doesn't round pixel values
	    // so we use setOffset directly with our own function B-0
	    $.offset.setOffset($tip[0], $.extend({
	      using: function (props) {
	        $tip.css({
	          top: Math.round(props.top),
	          left: Math.round(props.left)
	        })
	      }
	    }, offset), 0)

	    $tip.addClass('in')

	    // check to see if placing tip in new offset caused the tip to resize itself
	    var actualWidth  = $tip[0].offsetWidth
	    var actualHeight = $tip[0].offsetHeight

	    if (placement == 'top' && actualHeight != height) {
	      offset.top = offset.top + height - actualHeight
	    }

	    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

	    if (delta.left) offset.left += delta.left
	    else offset.top += delta.top

	    var isVertical          = /top|bottom/.test(placement)
	    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
	    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

	    $tip.offset(offset)
	    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
	  }

	  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
	    this.arrow()
	      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
	      .css(isVertical ? 'top' : 'left', '')
	  }

	  Tooltip.prototype.setContent = function () {
	    var $tip  = this.tip()
	    var title = this.getTitle()

	    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	    $tip.removeClass('fade in top bottom left right')
	  }

	  Tooltip.prototype.hide = function (callback) {
	    var that = this
	    var $tip = $(this.$tip)
	    var e    = $.Event('hide.bs.' + this.type)

	    function complete() {
	      if (that.hoverState != 'in') $tip.detach()
	      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.
	        that.$element
	          .removeAttr('aria-describedby')
	          .trigger('hidden.bs.' + that.type)
	      }
	      callback && callback()
	    }

	    this.$element.trigger(e)

	    if (e.isDefaultPrevented()) return

	    $tip.removeClass('in')

	    $.support.transition && $tip.hasClass('fade') ?
	      $tip
	        .one('bsTransitionEnd', complete)
	        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	      complete()

	    this.hoverState = null

	    return this
	  }

	  Tooltip.prototype.fixTitle = function () {
	    var $e = this.$element
	    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
	      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	    }
	  }

	  Tooltip.prototype.hasContent = function () {
	    return this.getTitle()
	  }

	  Tooltip.prototype.getPosition = function ($element) {
	    $element   = $element || this.$element

	    var el     = $element[0]
	    var isBody = el.tagName == 'BODY'

	    var elRect    = el.getBoundingClientRect()
	    if (elRect.width == null) {
	      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
	      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
	    }
	    var isSvg = window.SVGElement && el instanceof window.SVGElement
	    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
	    // See https://github.com/twbs/bootstrap/issues/20280
	    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())
	    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
	    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

	    return $.extend({}, elRect, scroll, outerDims, elOffset)
	  }

	  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
	    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
	        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

	  }

	  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
	    var delta = { top: 0, left: 0 }
	    if (!this.$viewport) return delta

	    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
	    var viewportDimensions = this.getPosition(this.$viewport)

	    if (/right|left/.test(placement)) {
	      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
	      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
	      if (topEdgeOffset < viewportDimensions.top) { // top overflow
	        delta.top = viewportDimensions.top - topEdgeOffset
	      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
	        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
	      }
	    } else {
	      var leftEdgeOffset  = pos.left - viewportPadding
	      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
	      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
	        delta.left = viewportDimensions.left - leftEdgeOffset
	      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
	        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
	      }
	    }

	    return delta
	  }

	  Tooltip.prototype.getTitle = function () {
	    var title
	    var $e = this.$element
	    var o  = this.options

	    title = $e.attr('data-original-title')
	      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

	    return title
	  }

	  Tooltip.prototype.getUID = function (prefix) {
	    do prefix += ~~(Math.random() * 1000000)
	    while (document.getElementById(prefix))
	    return prefix
	  }

	  Tooltip.prototype.tip = function () {
	    if (!this.$tip) {
	      this.$tip = $(this.options.template)
	      if (this.$tip.length != 1) {
	        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
	      }
	    }
	    return this.$tip
	  }

	  Tooltip.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
	  }

	  Tooltip.prototype.enable = function () {
	    this.enabled = true
	  }

	  Tooltip.prototype.disable = function () {
	    this.enabled = false
	  }

	  Tooltip.prototype.toggleEnabled = function () {
	    this.enabled = !this.enabled
	  }

	  Tooltip.prototype.toggle = function (e) {
	    var self = this
	    if (e) {
	      self = $(e.currentTarget).data('bs.' + this.type)
	      if (!self) {
	        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
	        $(e.currentTarget).data('bs.' + this.type, self)
	      }
	    }

	    if (e) {
	      self.inState.click = !self.inState.click
	      if (self.isInStateTrue()) self.enter(self)
	      else self.leave(self)
	    } else {
	      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
	    }
	  }

	  Tooltip.prototype.destroy = function () {
	    var that = this
	    clearTimeout(this.timeout)
	    this.hide(function () {
	      that.$element.off('.' + that.type).removeData('bs.' + that.type)
	      if (that.$tip) {
	        that.$tip.detach()
	      }
	      that.$tip = null
	      that.$arrow = null
	      that.$viewport = null
	      that.$element = null
	    })
	  }


	  // TOOLTIP PLUGIN DEFINITION
	  // =========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.tooltip')
	      var options = typeof option == 'object' && option

	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.tooltip

	  $.fn.tooltip             = Plugin
	  $.fn.tooltip.Constructor = Tooltip


	  // TOOLTIP NO CONFLICT
	  // ===================

	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }

	}(jQuery);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 252 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }
/******/ ])
});
;